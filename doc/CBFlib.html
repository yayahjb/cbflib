<HTML>
<HEAD>
<TITLE>CBFlib Manual</TITLE>
</HEAD>
<body bgcolor="#FAFAFF" text="#000000"
BACKGROUND="../html_graphics/cbflibbackground.jpg">
<a href="http://www.iucr.org/iucr-top/welcome.html">
<img alt="[IUCr Home Page]" src="../html_graphics/iucrhome.jpg"></a>
<a href="http://www.iucr.org/iucr-top/cif/home.html">
<img alt="[CIF Home Page]" src="../html_graphics/cifhome.jpg"></a>
<A HREF="cbf_definition_rev.html"><IMG SRC="../html_graphics/CBFbutton.jpg"
ALT="[CBF/imgCIF]"></A>
<IMG SRC="../html_graphics/cbflibbutton.jpg">
<hr>
<CENTER>
| <a href="http://www.iucr.org/iucr-top/welcome.html">IUCr Home Page</a>
| <a href="http://www.iucr.org/iucr-top/cif/home.html">CIF Home Page</a>
| <A HREF="cbf_definition_rev.html">CBF/imgCIF</a>
| CBFlib
|<br />
| <A HREF = "CBFlib_NOTICES.html">NOTICE</A>
| <a href=gpl.txt>GPL</a>
| <a href=lgpl.txt>LGPL</a>
| <a href="cif_img.html">imgCIF dictionary</a>
|<br />
| <a href="http://arcib.dowling.edu/donation.shtml">Click Here to Make a Donation</a>
|<P>
<IMG  SRC="../html_graphics/cbflibbig.jpg" ALT="">
</CENTER>
<font color="#0808A0">
<H2 ALIGN=CENTER>CBFlib</H2>
<CENTER>
<b>An API for CBF/imgCIF<br />
Crystallographic Binary Files with ASCII Support</b><br />
Version 0.7.6<br />
15 July 2006<br />
<p>
</CENTER>
</font><font color="#000000">
<p>
<CENTER>
by<br />
Paul J. Ellis<br />
Stanford Synchrotron Radiation Laboratory<br />
<p>
and<br />
Herbert J. Bernstein<br />
Bernstein + Sons<br />
<script language="javascript" type="text/javascript">
<!--
      var name = "yaya@";
      var domain = "bernstein-plus-sons";
      var domext = ".com";
      document.write ("<a href=\"mailto:" + name + domain + domext + "\">" + name + domain + domext+"</a>");
// -->
</script>
<noscript>
yaya&#64;bernstein-plus-sons&#46;com
</noscript>
<p>
&#169; Copyright 2006 Herbert J. Bernstein
<P>
<hr>
<b>YOU MAY REDISTRIBUTE THE CBFLIB PACKAGE UNDER THE TERMS OF THE <a href=gpl.txt>GPL</a>.
<P>
 ALTERNATIVELY YOU MAY REDISTRIBUTE THE CBFLIB API UNDER THE TERMS
 OF THE <a href=lgpl.txt>LGPL<a/>.</b>

</CENTER>
<p>
<HR>
<H3 ALIGN=CENTER>
Before using this software, please read the <br />
<A HREF = "CBFlib_NOTICES.html"> <IMG SRC="../html_graphics/noticeButton.jpg" ALT="NOTICE"></A><br />
for important disclaimers and the IUCr Policy
 on the Use of the Crystallographic Information File (CIF) and for other important
information.
</H3>
<p>
<HR>
</font><font color="#0808A0">
<h2 ALIGN=CENTER>Version History</H2>
</font><font color="#000000">
<p>
<TABLE>
<TR><TH ALIGN=LEFT>Version
<TH ALIGN=LEFT>Date<TH ALIGN=LEFT>By<TH ALIGN=LEFT>Description
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;0.1<TD VALIGN=TOP>&nbsp;&nbsp;Apr. 1998<TD VALIGN=TOP>&nbsp;&nbsp;PJE<TD>&nbsp;&nbsp;This was the
first CBFlib release.  It
supported binary CBF files using binary strings.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.2">0.2</A><TD VALIGN=TOP>&nbsp;&nbsp;Aug. 1998<TD VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release
added ascii imgCIF support using MIME-encoded binary sections, added
the option of MIME headers for the binary strings was well.  MIME code
adapted from mpack 1.5.  Added hooks needed for DDL1-style names without
categories.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.3">0.3</A><TD VALIGN=TOP>&nbsp;&nbsp;Sep. 1998<TD VALIGN=TOP>&nbsp;&nbsp;PJE<TD>&nbsp;&nbsp;This release
cleaned up the changes made for version 0.2, allowing multi-threaded use of
the code, and removing dependence on the mpack package.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.4">0.4</A><TD VALIGN=TOP>&nbsp;&nbsp;Nov. 1998<TD VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release
merged much of the message digest code into the general file reading and
writing to reduce the number of passes.  More consistency checking between the MIME header and the binary header was introduced.  The size in the MIME header was adjusted to agree with the version 0.2 documentation.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.5">0.5</A><TD VALIGN=TOP>&nbsp;&nbsp;Dec. 1998<TD VALIGN=TOP>&nbsp;&nbsp;PJE<TD>&nbsp;&nbsp;This release
greatly increased the speed of processing by allowing for deferred digest
evaluation.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.6">0.6</A><TD VALIGN=TOP>&nbsp;&nbsp;Jan. 1999<TD VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release
removed the redundant information (binary id, size, compression id)
from a binary header when there is a MIME header, removed the unused
repeat argument, and made the memory allocation for buffering and
tables with many rows sensitive to the current memory allocation already used.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.6.1">0.6.1</A><TD VALIGN=TOP>&nbsp;&nbsp;Feb. 2001<TD VALIGN=TOP>&nbsp;&nbsp;HP (per HJB)<TD>&nbsp;&nbsp;This release
fixed a memory leak due to misallocation by size of cbf_handle instead of cbf_handle_struct
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.7">0.7</A><TD VALIGN=TOP>&nbsp;&nbsp;Mar. 2001<TD VALIGN=TOP>&nbsp;&nbsp;PJE
<TD>&nbsp;&nbsp;This release added high-level instructions based on the imgCIF dictionary
version 1.1.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A href="ChangeLog.html#0.7.1">0.7.1</A><TD VALIGN=TOP>&nbsp;&nbsp;Mar. 2001<TD VALIGN=TOP>&nbsp;&nbsp;PJE
<TD>&nbsp;&nbsp;The high-level functions were revised to permit future expansion to
files with multiple images.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.7.2">0.7.2</A><TD
VALIGN=TOP>&nbsp;&nbsp;Apr. 2001<TD VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release
adjusted cbf_cimple.c to conform to cif_img.dic version 1.1.3
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.7.2.1">0.7.2.1</A><TD
VALIGN=TOP>&nbsp;&nbsp;May 2001<TD
VALIGN=TOP>&nbsp;&nbsp;PJE<TD>&nbsp;&nbsp;This release
corrected an if nesting error in the prior mod to cbf_cimple.c.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.7.3">0.7.3</A><TD
VALIGN=TOP>&nbsp;&nbsp;Oct 2002<TD
VALIGN=TOP>&nbsp;&nbsp;PJE<TD>&nbsp;&nbsp;This release
modified cbf_simple.c to
reorder image data on read so that the indices are always increasing in
memory (this behavior was undefined previously).
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.7.4">0.7.4</A><TD
VALIGN=TOP>&nbsp;&nbsp;Jan 2004<TD
VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release fixes a parse error for
quoted strings, adds code to get and set character string types, and removes compiler warnings
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.7.5">0.7.5</A><TD
VALIGN=TOP>&nbsp;&nbsp;Apr 2006<TD
VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release cleans up some
compiler warnings, corrects a parse error on quoted strings with
a leading blank as adds the new routines for support of
aliases, dictionaries and real arrays, higher level routines
to get and set pixel sizes, do cell computations, and to set beam centers,
improves support for conversion of images, picking up more data from
headers.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;<A HREF="ChangeLog.html#0.7.6">0.7.6</A><TD
VALIGN=TOP>&nbsp;&nbsp;Jul 2006<TD
VALIGN=TOP>&nbsp;&nbsp;HJB<TD>&nbsp;&nbsp;This release reorganizes the kit
into two pieces:  CBFlib_0.7.6_Data_Files and CBFlib_0.7.6.  An optional local copy
of getopt is added.  The 1.4 draft dictionary has been added.  cif2cbf
updated to support vcif2 validation.  convert_image and cif2cbf updated
to report text of error messages.  convert_image updated to support
tag and category aliases, default to adxv images.  convert_image and
img updated to support row-major images.  Support added for binning.
API Support added for validation, wide files and line folding.
Logic changed for beam center reporting.  Added new routines:

cbf_validate,
cbf_get_bin_sizes,
cbf_set_bin_sizes,
cbf_find_last_typed_child,
cbf_compose_itemname,
cbf_set_cbf_logfile,
cbf_make_widefile,
cbf_read_anyfile,
cbf_read_widefile,
cbf_write_local_file,
cbf_write_widefile,
cbf_column_number,
cbf_blockitem_number,
cbf_log,
cbf_check_category_tags,
cbf_set_beam_center



 </TABLE>

<HR>
</font><font color="#0808A0">
<h2 ALIGN=CENTER>Known Problems</H2>
</font><font color="#000000">
<P>
This version does not have support for byte-offset or predictor compression.
Code is needed to support array sub-sections.
</font><font color="#0808A0">
<h2 ALIGN=CENTER>Foreword</H2>
</font><font color="#000000">
<p>
In order to work with CBFlib, you need:
<P>
<ul>
<li>the source code, in the form
of a &quot;gzipped&quot; tar,
<A HREF="../../CBFlib_0.7.6.tar.gz">CBFlib_0.7.6.tar.gz</A>; and
<li>the test data, in the form of a &quot;gzipped&quot; tar
<A HREF="http://arcib.dowling.edu/software/CBFlib/downloads/version_0.7.6/CBFlib_0.7.6_Data_Files.tar.gz">CBFlib_0.7.6_Data_Files.tar.gz</a>
</ul>
<P>
Uncompress both of these files, and unpack them with tar:
<P>
<ul>
<li>gunzip &lt; CBFlib_0.7.6.tar.gz | tar xvf -
<li>gunzip &lt; CBFlib_0.7.6_Data_Files.tar.gz | tar xvf -
<P>   
   The data files are
compressed with bzip2.  <b>Do not &quot;bunzip2&quot;
the files in Place them
in an otherwise empty directory, and unpack it with tar.</b>
As in the past you will also need Paul Ellis's sample MAR345 image,
example.mar2300 and
Chris Nielsen's sample ADSC Quantum 315 image,
mb_LP_1_001.img as sample
data.  The Makefile will extract decompress these files
from the CBFlib_0.7.6_Data_Files directory.
<P>
Adjust the definition of CC and C++ in
Makefile to point to your C compiler, and then
<p>
<b>make all</b><br />
<b>make tests</b>

<p>
We have included <A HREF="example.html">examples</A> of
CBF/imgCIF files produced by CBFlib,
the current best draft of
the 
<A HREF="cif_img_1.4_4Jul06_draft.html">CBF Extensions Dictionary</A>, 
and of Andy Hammersley's CBF definition, updated to become a 
<A HREF="cbf_definition_rev.html">
DRAFT CBF/ImgCIF DEFINITION</A>.
<p>
<HR>


</font><font color="#0808A0">
<H2 ALIGN=CENTER>Contents</H2>
</font><font color="#000000">
<p>
<UL>
<LI><A HREF="#1. Introduction">1.   Introduction</A>
<LI><A HREF="#2.">2.   Function descriptions</A>
  <UL>
    <LI><A HREF="#2.1">2.1  General description</A>
    <UL>
      <LI><A HREF="#2.1.1">2.1.1   CBF handles</A>
      <LI><A HREF="#2.1.2">2.1.2   CBF goniometer handles</A>
      <LI><A HREF="#2.1.3">2.1.3   CBF detector handles</A>
      <LI><A HREF="#2.1.4">2.1.4   Return values</A>
    </UL>
    <LI><A HREF="#2.2">2.2   Reading and writing files containing binary sections</A>
    <UL>
      <LI><A HREF="#2.2.1">2.2.1   Reading binary sections</A>
      <LI><A HREF="#2.2.2">2.2.2   Writing binary sections</A>
      <LI><A HREF="#2.2.3">2.2.3   Summary of reading and writing files containing binary sections</A>
    </UL>
    <LI><A HREF="#2.3">2.3   Low-level function prototypes</A>
    <UL>
      <LI><A HREF="#2.3.1">2.3.1   cbf_make_handle</A>
      <LI><A HREF="#2.3.2">2.3.2   cbf_free_handle</A>
      <LI><A HREF="#2.3.3">2.3.3   cbf_read_file, cbf_read_widefile</A>
      <LI><a href="#2.3.4">2.3.4   cbf_write_file, cbf_write_widefile</a>
      <LI><A HREF="#2.3.5">2.3.5   cbf_new_datablock, cbf_new_saveframe</A>
      <LI><A HREF="#2.3.6">2.3.6   cbf_force_new_datablock, cbf_force_new_saveframe</A>
      <LI><A HREF="#2.3.7">2.3.7   cbf_new_category</A>
      <LI><A HREF="#2.3.8">2.3.8   cbf_force_new_category</A>
      <LI><A HREF="#2.3.9">2.3.9   cbf_new_column</A>
      <LI><A HREF="#2.3.10">2.3.10   cbf_new_row</A>
      <LI><A HREF="#2.3.11">2.3.11   cbf_insert_row</A>
      <LI><A HREF="#2.3.12">2.3.12   cbf_delete_row</A>
      <LI><A HREF="#2.3.13">2.3.13   cbf_set_datablockname, cbf_set_saveframename</A>
      <LI><A HREF="#2.3.14">2.3.14   cbf_reset_datablocks</A>
      <LI><A HREF="#2.3.15">2.3.15   cbf_reset_datablock, cbf_reset_saveframe</A>
      <LI><A HREF="#2.3.16">2.3.16   cbf_reset_category</A>
      <LI><A HREF="#2.3.17">2.3.17   cbf_remove_datablock, cbf_remove_saveframe</A>
      <LI><A HREF="#2.3.18">2.3.18   cbf_remove_category</A>
      <LI><A HREF="#2.3.19">2.3.19   cbf_remove_column</A>
      <LI><A HREF="#2.3.20">2.3.20   cbf_remove_row</A>
      <LI><A HREF="#2.3.21">2.3.21   cbf_rewind_datablock</A>
      <LI><A HREF="#2.3.22">2.3.22   cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A>
      <LI><A HREF="#2.3.23">2.3.23   cbf_rewind_column</A>
      <LI><A HREF="#2.3.24">2.3.24   cbf_rewind_row</A>
      <LI><A HREF="#2.3.25">2.3.25   cbf_next_datablock</A>
      <LI><A HREF="#2.3.26">2.3.26   cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A>
      <LI><A HREF="#2.3.27">2.3.27   cbf_next_column</A>
      <LI><A HREF="#2.3.28">2.3.28   cbf_next_row</A>
      <LI><A HREF="#2.3.29">2.3.29   cbf_find_datablock</A>
      <LI><A HREF="#2.3.30">2.3.30   cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A>
      <LI><A HREF="#2.3.31">2.3.31   cbf_find_column</A>
      <LI><A HREF="#2.3.32">2.3.32   cbf_find_row</A>
      <LI><A HREF="#2.3.33">2.3.33   cbf_find_nextrow</A>
      <LI><A HREF="#2.3.34">2.3.34   cbf_count_datablocks</A>
      <LI><A HREF="#2.3.35">2.3.35   cbf_count_categories, cbf_count_saveframes, cbf_count_blockitems</A>
      <LI><A HREF="#2.3.36">2.3.36   cbf_count_columns</A>
      <LI><A HREF="#2.3.37">2.3.37   cbf_count_rows</A>
      <LI><A HREF="#2.3.38">2.3.38   cbf_select_datablock</A>
      <LI><A HREF="#2.3.39">2.3.39   cbf_select_category, cbf_select_saveframe, cbf_select_blockitem</A>
      <LI><A HREF="#2.3.40">2.3.40   cbf_select_column</A>
      <LI><A HREF="#2.3.41">2.3.41   cbf_select_row</A>
      <LI><A HREF="#2.3.42">2.3.42   cbf_datablock_name</A>
      <LI><A HREF="#2.3.43">2.3.43   cbf_category_name</A>
      <LI><A HREF="#2.3.44">2.3.44   cbf_column_name</A>
      <LI><A HREF="#2.3.45">2.3.45   cbf_row_number</A>
      <LI><A HREF="#2.3.46">2.3.46   cbf_get_value, cbf_require_value</A>
      <LI><A HREF="#2.3.47">2.3.47   cbf_set_value</A>
      <LI><A HREF="#2.3.48">2.3.48   cbf_get_typeofvalue</A>
      <LI><A HREF="#2.3.49">2.3.49   cbf_set_typeofvalue</A>
      <LI><A HREF="#2.3.50">2.3.50   cbf_get_integervalue, cbf_require_integervalue</A>
      <LI><A HREF="#2.3.51">2.3.51   cbf_set_integervalue</A>
      <LI><A HREF="#2.3.52">2.3.52   cbf_get_doublevalue, cbf_require_doublevalue</A>
      <LI><A HREF="#2.3.53">2.3.53   cbf_set_doublevalue</A>
      <LI><A HREF="#2.3.54">2.3.54   cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A>
      <LI><A HREF="#2.3.55">2.3.55   cbf_get_integerarray, cbf_get_realarray</A>
      <LI><A HREF="#2.3.56">2.3.56   cbf_set_integerarray, cbf_set_realarray</A>
      <LI><A HREF="#2.3.57">2.3.57   cbf_failnez</A>
      <LI><A HREF="#2.3.58">2.3.58   cbf_onfailnez</A>
      <LI><A HREF="#2.3.59">2.3.59   cbf_require_datablock</A>
      <LI><A HREF="#2.3.60">2.3.60   cbf_require_category</A>
      <LI><A HREF="#2.3.61">2.3.61   cbf_require_column</A>
      <LI><A HREF="#2.3.62">2.3.62   cbf_require_column_value</A>
      <LI><A HREF="#2.3.63">2.3.63   cbf_require_column_integervalue</A>
      <LI><A HREF="#2.3.64">2.3.64   cbf_require_column_doublevalue</A>
      <LI><A HREF="#2.3.65">2.3.65   cbf_get_local_integer_byte_order,
       cbf_get_local_real_byte_order, cbf_get_local_real_format</A>
      <LI><A HREF="#2.3.66">2.3.66   cbf_get_dictionary, cbf_set_dictionary, cbf_require_dictionary</A>
      <LI><A HREF="#2.3.67">2.3.67   cbf_convert_dictionary</A>
      <LI><A HREF="#2.3.68">2.3.68   cbf_find_tag, cbf_find_local_tag</A>
      <LI><A HREF="#2.3.69">2.3.69   cbf_find_category_root, cbf_set_category_root, cbf_require_category_root</A>
      <LI><A HREF="#2.3.70">2.3.70   cbf_find_tag_root, cbf_set_tag_root, cbf_require_tag_root</A>
      <LI><A HREF="#2.3.71">2.3.71   cbf_find_tag_category, cbf_set_tag_category</A>


    </UL>
	<LI><A HREF="#2.4">2.4 High-level function prototypes (new for version 0.7)
	<UL>
	  <LI><A HREF="#2.4.1">2.4.1 cbf_read_template</a>
	  <LI><A HREF="#2.4.2">2.4.2 cbf_get_diffrn_id, cbf_require_diffrn_id</a>
	  <LI><A HREF="#2.4.3">2.4.3 cbf_set_diffrn_id</a>
	  <LI><A HREF="#2.4.4">2.4.4 cbf_get_crystal_id</a>
	  <LI><A HREF="#2.4.5">2.4.5 cbf_set_crystal_id</a>
	  <LI><A HREF="#2.4.6">2.4.6 cbf_get_wavelength</a>
	  <LI><A HREF="#2.4.7">2.4.7 cbf_set_wavelength</a>
	  <LI><A HREF="#2.4.8">2.4.8 cbf_get_polarization</a>
	  <LI><A HREF="#2.4.9">2.4.9 cbf_set_polarization</a>
	  <LI><A HREF="#2.4.10">2.4.10 cbf_get_divergence</a>
	  <LI><A HREF="#2.4.11">2.4.11 cbf_set_divergence</a>
	  <LI><A HREF="#2.4.12">2.4.12 cbf_count_elements</a>
	  <LI><A HREF="#2.4.13">2.4.13 cbf_get_element_id</a>
	  <LI><A HREF="#2.4.14">2.4.14 cbf_get_gain</a>
	  <LI><A HREF="#2.4.15">2.4.15 cbf_set_gain</a>
	  <LI><A HREF="#2.4.16">2.4.16 cbf_get_overload</a>
	  <LI><A HREF="#2.4.17">2.4.17 cbf_set_overload</a>
	  <LI><A HREF="#2.4.18">2.4.18 cbf_get_integration_time</a>
	  <LI><A HREF="#2.4.19">2.4.19 cbf_set_integration_time</a>
	  <LI><A HREF="#2.4.20">2.4.20 cbf_get_time</a>
	  <LI><A HREF="#2.4.21">2.4.21 cbf_set_time</a>
	  <LI><A HREF="#2.4.22">2.4.22 cbf_get_date</a>
	  <LI><A HREF="#2.4.23">2.4.23 cbf_set_date</a>
	  <LI><A HREF="#2.4.24">2.4.24 cbf_set_current_time</a>
	  <LI><A HREF="#2.4.25">2.4.25 cbf_get_image_size</a>
	  <LI><A HREF="#2.4.26">2.4.26 cbf_get_image, cbf_get_real_image</a>
	  <LI><A HREF="#2.4.27">2.4.27 cbf_set_image, cbf_set_real_image</a>
	  <LI><A HREF="#2.4.28">2.4.28 cbf_get_axis_setting</a>
	  <LI><A HREF="#2.4.29">2.4.29 cbf_set_axis_setting</a>
	  <LI><A HREF="#2.4.30">2.4.30 cbf_construct_goniometer</a>
	  <LI><A HREF="#2.4.31">2.4.31 cbf_free_goniometer</a>
	  <LI><A HREF="#2.4.32">2.4.32 cbf_get_rotation_axis</a>
	  <LI><A HREF="#2.4.33">2.4.33 cbf_get_rotation_range</a>
	  <LI><A HREF="#2.4.34">2.4.34 cbf_rotate_vector</a>
	  <LI><A HREF="#2.4.35">2.4.35 cbf_get_reciprocal</a>
	  <LI><A HREF="#2.4.36">2.4.36 cbf_construct_detector</a>
	  <LI><A HREF="#2.4.37">2.4.37 cbf_free_detector</a>
	  <LI><A HREF="#2.4.38">2.4.38 cbf_get_beam_center, cbf_set_beam_center</a>
	  <LI><A HREF="#2.4.39">2.4.39 cbf_get_detector_distance</a>
	  <LI><A HREF="#2.4.40">2.4.40 cbf_get_detector_normal</a>
	  <LI><A HREF="#2.4.41">2.4.41 cbf_get_pixel_coordinates</a>
	  <LI><A HREF="#2.4.42">2.4.42 cbf_get_pixel_normal</a>
	  <LI><A HREF="#2.4.43">2.4.43 cbf_get_pixel_area</a>
	  <LI><A HREF="#2.4.44">2.4.44 cbf_get_pixel_size</a>
	  <LI><A HREF="#2.4.45">2.4.45 cbf_set_pixel_size</a>
	  <LI><A HREF="#2.4.46">2.4.46 cbf_get_inferred_pixel_size</a>
	  <LI><A HREF="#2.4.47">2.4.47 cbf_get_unit_cell</a>
	  <LI><A HREF="#2.4.48">2.4.48 cbf_set_unit_cell</a>
	  <LI><A HREF="#2.4.49">2.4.49 cbf_get_reciprocal_cell</a>
	  <LI><A HREF="#2.4.50">2.4.50 cbf_set_reciprocal_cell</a>
	  <LI><A HREF="#2.4.51">2.4.51 cbf_compute_cell_volume</a>
	  <LI><A HREF="#2.4.52">2.4.52 cbf_compute_reciprocal_cell</a>
      <LI><A HREF="#2.4.53">2.4.53 cbf_get_orientation_matrix, cbf_set_orientation_matrix</a>
      <LI><A HREF="#2.4.54">2.4.54 cbf_get_bin_sizes, cbf_set_bin_sizes</a>
  </UL>
</UL>
<LI><A HREF="#3.">3.   File format</A>
<UL>
  <LI><A HREF="#3.1">3.1   General description</A>
  <LI><A HREF="#3.2">3.2   Format of the binary sections</A>
  <UL>
    <LI><A HREF="#3.2.1">3.2.1   Format of imgCIF binary sections
    <LI><A HREF="#3.2.2">3.2.2   Format of CBF binary sections
  </UL>
  <LI><A HREF="#3.3">3.3   Compression schemes</A>
  <UL>
    <LI><A HREF="#3.3.1">3.3.1   Canonical-code compression</A>
    <LI><A HREF="#3.3.2">3.3.2   CCP4-style compression</A>
  </UL>
</UL>
<LI><A HREF="#4.">4.   Installation</A>
<LI><A HREF="#5. Example progr">5.   Example programs</A>
</UL>
<p>


<h3><A NAME="1.">1.  Introduction</A></h3>
<p>
CBFlib is a library of ANSI-C functions providing a simple mechanism for accessing
Crystallographic Binary Files (CBF files) and Image-supporting CIF (imgCIF) files.
The CBFlib API is loosely based on the
CIFPARSE API for mmCIF files.  Like CIFPARSE, CBFlib does not perform any semantic
integrity checks; rather it simply provides functions to create, read, modify and write CBF binary
data files and imgCIF ASCII data files.
<p>

<h3><A NAME="2.">2.  Function descriptions</A></h3>

<h4><a NAME="2.1">2.1  General description</a></h4>
<p>
Almost all of the CBFlib functions receive a value of type cbf_handle
(a CBF handle) as the first argument.
Several of the high-level CBFlib functions dealing with geometry
receive a value of type cbf_goniometer (a handle for a CBF goniometer object)
or cbf_detector (a handle for a CBF detector object).

<p>
All functions return an integer
equal to 0 for success or an error code for failure.<br />
<p>
<h4><a NAME="2.1.1">2.1.1  CBF handles</a></h4>
<p>
CBFlib permits a program to use multiple CBF objects simultaneously.  To identify
the CBF object on which a function will operate, CBFlib uses a value of type cbf_handle.
<p>
All functions in the library except cbf_make_handle expect a value of type cbf_handle
as the first argument.
<p>
The function <b>cbf_make_handle</b> creates and initializes a new CBF handle.
<p>
The function <b>cbf_free_handle</b> destroys a handle and frees all memory associated with
the corresponding CBF object.<br />
<p>



<h4><a NAME="2.1.2">2.1.2 CBF goniometer handles</a></h4>
<p>
To represent the goniometer used to orient a sample, CBFlib uses a value of
type cbf_goniometer.
<p>
A goniometer object is created and initialized from a CBF object using the
function <b>cbf_construct_goniometer</b>.
<p>
The function <b>cbf_free_goniometer</b> destroys a goniometer handle and frees
all memory associated with the corresponding object.
<p>



<h4><a NAME="2.1.3">2.1.3 CBF detector handles</a></h4>
<p>
To represent a detector surface mounted on a positioning system, CBFlib
uses a value of type cbf_detector.
<p>
A goniometer object is created and initialized from a CBF object using
the function <b>cbf_construct_detector</b>.
<p>
The function <b>cbf_free_detector</b> destroys a detector handle and frees
all memory associated with the corresponding object.

<p>

<h4><a NAME="2.1.4">2.1.4  Return values</a></h4>
All of the CBFlib functions return 0 on success and an error code on failure.
The error codes are:
<p>
<CENTER>
<table>
<TR><TD>&nbsp;&nbsp;CBF_FORMAT<TD>&nbsp;&nbsp;The file format is invalid
<TR><TD>&nbsp;&nbsp;CBF_ALLOC<TD>&nbsp;&nbsp;Memory allocation failed
<TR><TD>&nbsp;&nbsp;CBF_ARGUMENT<TD>&nbsp;&nbsp;Invalid function argument
<TR><TD>&nbsp;&nbsp;CBF_ASCII<TD>&nbsp;&nbsp;The value is ASCII (not binary)
<TR><TD>&nbsp;&nbsp;CBF_BINARY<TD>&nbsp;&nbsp;The value is binary (not ASCII)
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_BITCOUNT<TD>&nbsp;&nbsp;The expected number of bits does <br />not match the actual number written
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_ENDOFDATA<TD>&nbsp;&nbsp;The end of the data was reached <br />before the end of the array
<TR><TD>&nbsp;&nbsp;CBF_FILECLOSE<TD>&nbsp;&nbsp;File close error
<TR><TD>&nbsp;&nbsp;CBF_FILEOPEN<TD>&nbsp;&nbsp;File open error
<TR><TD>&nbsp;&nbsp;CBF_FILEREAD<TD>&nbsp;&nbsp;File read error
<TR><TD>&nbsp;&nbsp;CBF_FILESEEK<TD>&nbsp;&nbsp;File seek error
<TR><TD>&nbsp;&nbsp;CBF_FILETELL<TD>&nbsp;&nbsp;File tell error
<TR><TD>&nbsp;&nbsp;CBF_FILEWRITE<TD>&nbsp;&nbsp;File write error
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_IDENTICAL<TD>&nbsp;&nbsp;A data block with the new name <br />already exists
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_NOTFOUND<TD>&nbsp;&nbsp;The data block, category, column or<br /> row does not exist
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_OVERFLOW<TD>&nbsp;&nbsp;The number read cannot fit into the<br /> destination argument.  The destination
has<br />been set to the nearest value.
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_UNDEFINED<TD>&nbsp;&nbsp;The requested number is not defined (e.g. 0/0; new for version 0.7).
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_NOTIMPLEMENTED<TD>&nbsp;&nbsp;The requested functionality is not yet implemented (New for version 0.7).

</TABLE>
</CENTER>
<p>

If more than one error has occurred, the error code is the logical OR of the individual
error codes.<br />

<h4><A NAME="2.2">2.2  Reading and writing files containing binary sections</A></h4>

<h4><A NAME="2.2.1">2.2.1  Reading binary sections</A></h4>
<p>
The current version of CBFlib only decompresses a binary section from disk when requested
by the program.
<p>
When a file containing one or more binary sections is read, CBFlib saves the file
pointer and the position of the binary section within the file and then jumps past
the binary section.  When the program attempts to access the binary data, CBFlib
sets the file position back to the start of the binary section and then reads the data.
<p>
For this scheme to work:
<p>
1. The file must be a random-access file opened in binary
mode (fopen ( ,&quot; rb&quot;)).<br />
2. The program <i>must not</i>
 close the file.  CBFlib will close the file using fclose ( ) when it is no longer
needed.
<p>
At present, this also means that a program cant read a file and then write back to
the same file.   This restriction will be eliminated in a future version.
<p>
When reading an imgCIF vs a CBF, the difference is detected automatically.
<p>
<h4><A NAME="2.2.2">2.2.2  Writing binary sections</A></h4>
<p>
When a program passes CBFlib a binary value, the data is compressed to a temporary
file.  If the CBF object is subsequently written to a file, the data is simply copied
from the temporary file to the output file.
<p>
The output file can be of any type.  If the program indicates to CBFlib that the file
is a random-access and readable, CBFlib will conserve disk space by closing the temporary
file and using the output file as the location at which the binary value is stored.
<p>
For this option to work:
<p>
1. The file must be a random-access file opened in binary
update mode (fopen ( , &quot;w+b&quot;)).<br />
2. The program <i>must not</i>
 close the file.  CBFlib will close the file using fclose ( )
when it is no longer
needed.
<p>
If this option is not used:
<p>
1. CBFlib will continue using the temporary file.<br />
2. CBFlib <i>will not</i>
 close the file.  This is the responsibility of the main program.
<p>
<h4><A NAME="2.2.3">2.2.3  Summary of reading and writing files containing binary sections</A></h4>
<p>
1. Open disk files to read using the mode &quot;rb&quot;. <br />
2. If possible, open disk files to write using the mode &quot;w+b&quot;
and tell CBFlib that it can use the file as a buffer.<br />
3. Do <i>not</i>
close any files read by CBFlib or written by CBFlib with
buffering turned on.<br />
4. Do <i>not</i> attempt to read from a file, then
write to the same file.<br />

<HR><HR>
<p>
<h4><A NAME="2.3">2.3  Low-level function prototypes</A></h4>

<h4><A NAME="2.3.1">2.3.1  cbf_make_handle</A> </h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_make_handle (cbf_handle *<i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_make_handle creates and initializes a new internal CBF object.
All other CBFlib
functions operating on this object receive the CBF handle
as the first argument.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;Pointer to a CBF handle.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.2">2.3.2  cbf_free_handle</A><br />
<p><HR><P>
<h4><A NAME="2.3.2">2.3.2  cbf_free_handle</A> </h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_free_handle (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_free_handle destroys the CBF object specified by
the <i>handle</i> and frees all associated
memory.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle to free.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.1">2.3.1  cbf_make_handle</A><br />
<p><HR><P>
<h4><A NAME="2.3.3">2.3.3  cbf_read_file</A></H4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_read_file (cbf_handle <i>handle</i>, FILE *<i>file</i>, int <i>headers</i>);<br />
int cbf_read_widefile (cbf_handle <i>handle</i>, FILE *<i>file</i>, int <i>headers</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_read_file reads the CBF or CIF file <i>file</i>
 into the CBF object specified by <i>handle</i>, using the CIF 1.0 convention of 80 character lines.
cbf_read_widefile reads the CBF or CIF file <i>file</i>
 into the CBF object specified by <i>handle</i>, using the CIF 1.1 convention of 2048 character lines.
 A warning is issued to stderr for ascii lines over the limit.  No test is performed on binary
 sections.
<p>
Validation is performed in three ways levels: during the lexical scan, during the
parse, and, if a dictionary was converted, against the value types, value
enumerations, categories and parent-child relationships specified
in the dictionary.  
<p>
<i>headers</i> controls the interprestation of binary section headers
of imgCIF files.
<TABLE>
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;MSG_DIGEST:
<TD>&nbsp;&nbsp;Instructs CBFlib to check that the digest of the
binary section matches any
header value.  If the digests do
not match, the call will return CBF_FORMAT.  This evaluation and comparison
is delayed (a &quot;lazy&quot; evaluation) to ensure maximal processing efficiency.
If an immediately evaluation is required, see MSG_DIGESTNOW, below.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;MSG_DIGESTNOW:
<TD>&nbsp;&nbsp;Instructs CBFlib to check that the digest of the
binary section matches any
header value.  If the digests do
not match, the call will return CBF_FORMAT.  This evaluation and comparison
is performed during initial parsing of the section to ensure timely
error reporting at the expense of processing efficiency.
If a more efficient delayed (&quot;lazy&quot;)  evaluation is required, see MSG_DIGESTNOW, below.
<TR>
<TD VALIGN=TOP>&nbsp;&nbsp;MSG_NODIGEST:
<TD>&nbsp;&nbsp;Do not check the digest (default).
</TABLE>
<p>
CBFlib defers reading binary sections as long as possible.  In the current version
of CBFlib, this means that:
<p>
1. The file must be a random-access file opened in binary mode
(fopen ( , &quot;rb&quot;)).<br />
2. The program <i>must not</i>
 close the file.  CBFlib will close the file using fclose ( ) when it is no longer
needed.
<p>
These restrictions may change in a future release.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>file</i><TD>&nbsp;&nbsp;Pointer to a file descriptor.<br />
<TR><TD>&nbsp;&nbsp;<i>headers</i><TD>&nbsp;&nbsp;Controls interprestation of binary section headers.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>


<A HREF="#2.3.4">2.3.4  cbf_write_file</A><br />
<p><HR><P>
<h4><A NAME="2.3.4">2.3.4  cbf_write_file</A> </h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_write_file (cbf_handle <i>handle</i>, FILE *<i>file</i>, int <i>readable</i>, int <i>ciforcbf</i>, int <i>headers</i>, int <i>encoding</i>);<br />
int cbf_write_widefile (cbf_handle <i>handle</i>, FILE *<i>file</i>, int <i>readable</i>, int <i>ciforcbf</i>, int <i>headers</i>, int <i>encoding</i>);
<p>

<b>DESCRIPTION</b>
<p>
cbf_write_file writes the CBF object specified by <i>handle</i>
 into the file <i>file</i>, following CIF 1.0 conventions of 80 character lines.
cbf_write_widefile writes the CBF object specified by <i>handle</i>
 into the file <i>file</i>, following CIF 1.1 conventions of 2048 character lines.
  A warning is issued to stderr for ascii lines over the limit, and an attempt is
  made to fold lines to fit.  No test is performed on binary
 sections.
<p>
If a dictionary has been provided, aliases will be applied on output.
<p>
Unlike cbf_read_file, the <i>file</i> does not have to be random-access.
<p>
If the file is random-access and readable, <i>readable</i> can be set to
 non-0 to indicate to CBFlib that
the file can be used as a buffer to conserve disk space.
If the file is not random-access or not
readable, <i>readable</i> must be 0.
<p>
If <i>readable</i> is non-0, CBFlib will close the file when it is
no longer required, otherwise this is
the responsibility of the program.
<p>
<i>ciforcbf</i> selects the format in which the binary sections are written:
<TABLE>
<TR><TD>&nbsp;&nbsp;CIF<TD>&nbsp;&nbsp;Write an imgCIF file.
<TR><TD>&nbsp;&nbsp;CBF<TD>&nbsp;&nbsp;Write a CBF file (default).
</TABLE>
<i>headers</i> selects the type of header used in CBF binary sections and selects whether message
digests are generated.  The value of <i>headers</i> can be a logical OR of any of:
<TABLE>
<TR><TD>&nbsp;&nbsp;MIME_HEADERS<TD>&nbsp;&nbsp;Use MIME-type headers (default).
<TR><TD>&nbsp;&nbsp;MIME_NOHEADERS<TD>&nbsp;&nbsp;Use a simple ASCII headers.
<TR><TD>&nbsp;&nbsp;MSG_DIGEST<TD>&nbsp;&nbsp;Generate message digests for binary data validation.
<TR><TD>&nbsp;&nbsp;MSG_NODIGEST<TD>&nbsp;&nbsp;Do not generate message digests (default).
</TABLE>
<i>encoding</i> selects the type of encoding used for binary sections and the type of line-termination in
imgCIF files. The value can be a logical OR of any of:
<TABLE>
<TR><TD>&nbsp;&nbsp;ENC_BASE64<TD>&nbsp;&nbsp;Use BASE64 encoding (default).
<TR><TD>&nbsp;&nbsp;ENC_QP<TD>&nbsp;&nbsp;Use QUOTED-PRINTABLE encoding.
<TR><TD>&nbsp;&nbsp;ENC_BASE8<TD>&nbsp;&nbsp;Use BASE8 (octal) encoding.
<TR><TD>&nbsp;&nbsp;ENC_BASE10<TD>&nbsp;&nbsp;Use BASE10 (decimal) encoding.
<TR><TD>&nbsp;&nbsp;ENC_BASE16<TD>&nbsp;&nbsp;Use BASE16 (hexadecimal) encoding.
<TR><TD VALIGN=TOP>&nbsp;&nbsp;ENC_FORWARD<TD>&nbsp;&nbsp;For BASE8, BASE10 or BASE16 encoding, map bytes to words
forward (1234) (default on little-endian machines).
<TR><TD VALIGN=TOP>&nbsp;&nbsp;ENC_BACKWARD<TD>&nbsp;&nbsp;Map bytes to words backward (4321) (default on big-endian
machines).
<TR><TD VALIGN=TOP>&nbsp;&nbsp;ENC_CRTERM<TD>&nbsp;&nbsp;Terminate lines with CR.
<TR><TD VALIGN=TOP>&nbsp;&nbsp;ENC_LFTERM<TD>&nbsp;&nbsp;Terminate lines with LF (default).
</TABLE>
<p><b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>file</i><TD>&nbsp;&nbsp;Pointer to a file descriptor.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>readable</i><TD>&nbsp;&nbsp;If non-0: this file is random-access
and readable and can be used as a buffer.
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>ciforcbf</i><TD>&nbsp;&nbsp;Selects the format in which the
binary sections are written (CIF/CBF).
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>headers</i><TD>&nbsp;&nbsp;Selects the type of header in CBF
binary sections and message digest generation.
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>encoding</i><TD>&nbsp;&nbsp;Selects the type of encoding used
for binary sections and the type of line-termination
in imgCIF files.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.3">2.3.3  cbf_read_file</A><br />
<p><HR><P>


<h4><A NAME="2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_new_datablock (cbf_handle <i>handle</i>, const char *<i>datablockname</i>);<br />
int cbf_new_saveframe (cbf_handle <i>handle</i>, const char *<i>saveframename</i>);

<p><b>DESCRIPTION</b>
<p>
cbf_new_datablock creates a new data block with name <i>datablockname</i>
 and makes it the current data block.
cbf_new_saveframe creates a new save frame with name <i>saveframename</i>
within the current data block
 and makes the new save frame the current save frame.
<p>
If a data block or save frame with this name already exists, the existing data block
or save frame
becomes the current data block or save frame.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;The name of the new data block.
<TR><TD>&nbsp;&nbsp;<i>saveframename</i><TD>&nbsp;&nbsp;The name of the new save frame.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.12">2.3.12  cbf_set_datablockname, cbf_set_saveframename</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />

<p><HR><P>
<h4><A NAME="2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_force_new_datablock (cbf_handle <i>handle</i>,
const char *<i>datablockname</i>);<br />
int cbf_force_new_saveframe (cbf_handle <i>handle</i>,
const char *<i>saveframename</i>);

<p><b>DESCRIPTION</b>
<p>
cbf_force_new_datablock creates a new data block with name <i>datablockname</i>
 and makes it the current data block.   Duplicate data block names are allowed.
cbf_force_new_saveframe creates a new savew frame with name <i>saveframename</i>
 and makes it the current save frame.   Duplicate save frame names are allowed.
<p>
Even if a save frame with this name already exists, a new save frame
 is created and becomes the current save frame.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;The name of the new data block.
<TR><TD>&nbsp;&nbsp;<i>saveframename</i><TD>&nbsp;&nbsp;The name of the new save frame.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<a href="#2.3.12">2.3.12  cbf_set_datablockname, cbf_set_saveframename</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>


<h4><A NAME="2.3.7">2.3.7  cbf_new_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_new_category (cbf_handle <i>handle</i>,
const char *<i>categoryname</i>);
<p><b>DESCRIPTION</b>
<p>
cbf_new_category creates a new category in the
current data block with name <i>categoryname</i>
 and makes it the current category.
<p>
If a category with this name already exists, the
existing category becomes the current
category.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;The name of the new category.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<a href="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.8">2.3.8  cbf_force_new_category</A> </h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_force_new_category (cbf_handle <i>handle</i>, const char *<i>categoryname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_force_new_category creates a new category in the current data block with name <i>categoryname</i>
 and makes it the current category.   Duplicate category names are allowed.
<p>
Even if a category with this name already exists, a new category of
the same name is created and becomes the current category.  The
allows for the creation of unlooped tag/value lists drawn from
the same category.
<p><b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;The name of the new category.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<a href="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.9">2.3.9  cbf_new_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_new_column (cbf_handle <i>handle</i>, const char *<i>columnname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_new_column creates a new column in the current category with name <i>columnname</i>
 and makes it the current column.
<p>
If a column with this name already exists, the existing column becomes the current
category.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;The name of the new column.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<a href="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.19">2.3.19  cbf_remove_column</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>


<h4><A NAME="2.3.10">2.3.10  cbf_new_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_new_row (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_new_row adds a new row to the current category and makes it the current row.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<a href="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.12">2.3.12  cbf_delete_row</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.11">2.3.11  cbf_insert_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_insert_row (cbf_handle <i>handle</i>, unsigned int <i>rownumber</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_insert_row adds a new row to the current category.  The new row is inserted as
row <i>rownumber</i>
 and existing rows starting from <i>rownumber</i>
 are moved up by 1.  The new row becomes the current row.
<p>
If the category has fewer than <i>rownumber</i>
 rows, the function returns CBF_NOTFOUND.
<p>
The row numbers start from 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>rownumber</i><TD>&nbsp;&nbsp;The row number of the new row.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<a href="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.12">2.3.12  cbf_delete_row</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>


<h4><A NAME="2.3.12">2.3.12  cbf_delete_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_delete_row (cbf_handle <i>handle</i>, unsigned int <i>rownumber</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_delete_row deletes a row from the current category.  Rows starting from <i>rownumber</i>
+1 are moved down by 1.  If the current row
was higher than <i>rownumber</i>, or if the current row is the last row, it will also move down by 1.
<p>
The row numbers start from 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>rownumber</i><TD>&nbsp;&nbsp;The number of the row to delete.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<A HREF="#2.3.19">2.3.19  cbf_remove_column</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>


<h4><A NAME="2.3.13">2.3.13  cbf_set_datablockname, cbf_set_saveframename</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_set_datablockname (cbf_handle <i>handle</i>, const char *<i>datablockname</i>);<br />
int cbf_set_saveframename (cbf_handle <i>handle</i>. const char *<i>saveframename</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_datablockname changes the name of the current data block to <i>datablockname</i>.
cbf_set_saveframename changes the name of the current save frame to <i>saveframename</i>.
<p>
If a data block or save frame with this name already exists (comparison is case-insensitive), the
function returns CBF_IDENTICAL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;The new data block name.<br />
<TR><TD>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;The new save frame name.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<A HREF="#2.3.14">2.3.14  cbf_reset_datablocks</A><br />
<A HREF="#2.3.15">2.3.15  cbf_reset_datablock, cbf_reset_saveframe</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.42">2.3.42  cbf_datablock_name</A><br />
<p><HR><P>
<h4><A NAME="2.3.14">2.3.14  cbf_reset_datablocks</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_reset_datablocks (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_reset_datablocks deletes all categories from all data blocks.
<p>
The current data block does not change.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.15">2.3.15  cbf_reset_datablock, cbf_reset_saveframe</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<p><HR><P>
<h4><A NAME="2.3.15">2.3.15  cbf_reset_datablock, cbf_reset_datablock</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_reset_datablock (cbf_handle <i>handle</i>);<br />
int cbf_reset_saveframe (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_reset_datablock deletes all categories from the current data block.
cbf_reset_saveframe deletes all categories from the current save frame.

<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.14">2.3.14  cbf_reset_datablocks</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />

<p><HR><P>
<h4><A NAME="2.3.16">2.3.16  cbf_reset_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_reset_category (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_reset_category deletes all columns and rows from current category.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.16">2.3.16  cbf_reset_category</A><br />
<A HREF="#2.3.19">2.3.19  cbf_remove_column</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<p><HR><P>
<h4><A NAME="2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe </A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_remove_datablock (cbf_handle <i>handle</i>);<br />
int cbf_remove_saveframe (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_remove_datablock deletes the current data block.
cbf_remove_saveframe deletes the current save frame.
<p>
The current data block becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<a href="#2.3.5">2.3.5  cbf_new_datablock, cbf_new_saveframe</A><br />
<a href="#2.3.6">2.3.6  cbf_force_new_datablock, cbf_force_new_saveframe</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<A HREF="#2.3.19">2.3.19  cbf_remove_column</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.18">2.3.18  cbf_remove_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_remove_category (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_remove_category deletes the current category.
<p>
The current category becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.7">2.3.7  cbf_new_category</A><br />
<A HREF="#2.3.8">2.3.8  cbf_force_new_category</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.19">2.3.19  cbf_remove_column</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.19">2.3.19  cbf_remove_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_remove_column (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_remove_column deletes the current column.
<p>
The current column becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.9">2.3.9  cbf_new_column</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<A HREF="#2.3.20">2.3.20  cbf_remove_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.20">2.3.20  cbf_remove_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_remove_row (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_remove_row deletes the current row in the current category.
<p>
If the current row was the last row, it will move down by 1,
otherwise, it will remain the same.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.10">2.3.10  cbf_new_row</A><br />
<A HREF="#2.3.11">2.3.11  cbf_insert_row</A><br />
<A HREF="#2.3.17">2.3.17  cbf_remove_datablock, cbf_remove_saveframe</A><br />
<A HREF="#2.3.18">2.3.18  cbf_remove_category</A><br />
<A HREF="#2.3.19">2.3.19  cbf_remove_column</A><br />
<A HREF="#2.3.12">2.3.12  cbf_delete_row</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>


<h4><A NAME="2.3.21">2.3.21  cbf_rewind_datablock</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_rewind_datablock (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_rewind_datablock makes the first data block the current data block.
<p>
If there are no data blocks, the function returns CBF_NOTFOUND.
<p>
The current category becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.22">2.3.22  cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A><br />
<A HREF="#2.3.19">2.3.19  cbf_rewind_column</A><br />
<A HREF="#2.3.24">2.3.24  cbf_rewind_row</A><br />
<A HREF="#2.3.25">2.3.25  cbf_next_datablock</A><br />

<p><HR><P>
<h4><A NAME="2.3.22">2.3.22  cbf_rewind_category,  cbf_rewind_saveframe,  cbf_rewind_blockitem</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_rewind_category (cbf_handle <i>handle</i>);<br />
int cbf_rewind_saveframe (cbf_handle <i>handle</i>);<br />
int cbf_rewind_blockitem (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_rewind_category makes the first category in the current data block the current
category.
cbf_rewind_saveframe makes the first saveframe in the current data block the current
saveframe.
cbf_rewind_blockitem makes the first blockitem (category or saveframe) in the current data block the current
blockitem.
<p>
If there are no categories, saveframes or blockitems the function returns CBF_NOTFOUND.
<p>
The current column and row become undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.21">2.3.21  cbf_rewind_datablock</A><br />
<A HREF="#2.3.19">2.3.19  cbf_rewind_column</A><br />
<A HREF="#2.3.24">2.3.24  cbf_rewind_row</A><br />
<A HREF="#2.3.26">2.3.26  cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A><br />

<p><HR><P>
<h4><A NAME="2.3.23">2.3.23  cbf_rewind_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_rewind_column (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_rewind_column makes the first column in the current category
the current column.

<p>
If there are no columns, the function returns CBF_NOTFOUND.
<p>
The current row is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.21">2.3.21  cbf_rewind_datablock</A><br />
<A HREF="#2.3.22">2.3.22  cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A><br />
<A HREF="#2.3.24">2.3.24  cbf_rewind_row</A><br />
<A HREF="#2.3.27">2.3.27  cbf_next_column</A><br />

<p><HR><P>
<h4><A NAME="2.3.24">2.3.24  cbf_rewind_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_rewind_row (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_rewind_row makes the first row in the current category the current row.
<p>
If there are no rows, the function returns CBF_NOTFOUND.
<p>
The current column is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.21">2.3.21  cbf_rewind_datablock</A><br />
<A HREF="#2.3.22">2.3.22  cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A><br />
<A HREF="#2.3.19">2.3.19  cbf_rewind_column</A><br />
<A HREF="#2.3.28">2.3.28  cbf_next_row</A><br />

<p><HR><P>
<h4><A NAME="2.3.25">2.3.25  cbf_next_datablock</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_next_datablock (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_next_datablock makes the data block following the current
data block the current data block.
<p>
If there are no more data blocks, the function returns CBF_NOTFOUND.
<p>
The current category becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.21">2.3.21  cbf_rewind_datablock</A><br />
<A HREF="#2.3.26">2.3.26  cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A><br />
<A HREF="#2.3.27">2.3.27  cbf_next_column</A><br />
<A HREF="#2.3.28">2.3.28  cbf_next_row</A><br />
<p><HR><P>
<h4><A NAME="2.3.26">2.3.26  cbf_next_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_next_category (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_next_category makes the category following the current category
in the current data block the current category.
<p>
If there are no more categories, the function returns CBF_NOTFOUND.
<p>
The current column and row become undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.22">2.3.22  cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A><br />
<A HREF="#2.3.25">2.3.25  cbf_next_datablock</A><br />
<A HREF="#2.3.27">2.3.27  cbf_next_column</A><br />
<A HREF="#2.3.28">2.3.27  cbf_next_row</A><br />
<p><HR><P>
<h4><A NAME="2.3.27">2.3.27  cbf_next_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_next_column (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_next_column makes the column following the current column in the current category
the current column.
<p>
If there are no more columns, the function returns CBF_NOTFOUND.
<p>
The current row is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.19">2.3.19  cbf_rewind_column</A><br />
<A HREF="#2.3.25">2.3.25  cbf_next_datablock</A><br />
<A HREF="#2.3.26">2.3.26  cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A><br />
<A HREF="#2.3.28">2.3.28  cbf_next_row</A><br />
<p><HR><P>
<h4><A NAME="2.3.28">2.3.28  cbf_next_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_next_row (cbf_handle <i>handle</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_next_row makes the row following the current row in the current
category the current row.
<p>
If there are no more rows, the function returns CBF_NOTFOUND.
<p>
The current column is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.24">2.3.24  cbf_rewind_row</A><br />
<A HREF="#2.3.25">2.3.25  cbf_next_datablock</A><br />
<A HREF="#2.3.26">2.3.26  cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A><br />
<A HREF="#2.3.27">2.3.27  cbf_next_column</A><br />

<p><HR><P>
<h4><A NAME="2.3.29">2.3.29  cbf_find_datablock</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_datablock (cbf_handle <i>handle</i>, const char *<i>datablockname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_find_datablock makes the data block with name <i>datablockname</i>
 the current data block.
<p>
The comparison is case-insensitive.
<p>
If the data block does not exist, the function returns CBF_NOTFOUND.
<p>
The current category becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;The name of the data block to find.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.21">2.3.21  cbf_rewind_datablock</A><br />
<A HREF="#2.3.25">2.3.25  cbf_next_datablock</A><br />
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.42">2.3.42  cbf_datablock_name</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.30">2.3.30  cbf_find_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_category (cbf_handle <i>handle</i>,
const char *<i>categoryname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_find_category makes the category in the current data block with
name <i>categoryname</i> the current category.
<p>
The comparison is case-insensitive.
<p>
If the category does not exist, the function returns CBF_NOTFOUND.
<p>
The current column and row become undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;The name of the category to find.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.22">2.3.22  cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A><br />
<A HREF="#2.3.26">2.3.26  cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A><br />
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.43">2.3.43  cbf_category_name</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />
<p><HR><P>
<h4><A NAME="2.3.31">2.3.31  cbf_find_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_column (cbf_handle <i>handle</i>, const char *<i>columnname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_find_column makes the columns in the current category with
name <i>columnname</i> the current column.
<p>
The comparison is case-insensitive.
<p>
If the column does not exist, the function returns CBF_NOTFOUND.
<p>
The current row is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;The name of column to find.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.19">2.3.19  cbf_rewind_column</A><br />
<A HREF="#2.3.27">2.3.27  cbf_next_column</A><br />
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.44">2.3.44  cbf_column_name</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />

<p><HR><P>
<h4><A NAME="2.3.32">2.3.32  cbf_find_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_row (cbf_handle <i>handle</i>, const char *<i>value</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_find_row makes the first row in the current column with value
<i>value</i> the current row.
<p>
The comparison is case-sensitive.
<p>
If a matching row does not exist, the function returns CBF_NOTFOUND.
<p>
The current column is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>value</i><TD>&nbsp;&nbsp;The value of the row to find.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.24">2.3.24  cbf_rewind_row</A><br />
<A HREF="#2.3.28">2.3.28  cbf_next_row</A><br />
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />
<A HREF="#2.3.33">2.3.33  cbf_find_nextrow</A><br />
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />

<p>
<h4><A NAME="2.3.33">2.3.33  cbf_find_nextrow</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_nextrow (cbf_handle <i>handle</i>, const char *<i>value</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_find_nextrow makes the makes the next row in the current column
with value <i>value</i> the current row.  The search starts from the
row following the last row found with cbf_find_row or cbf_find_nextrow,
or from the current row if the current row was defined using any other
function.
<p>
The comparison is case-sensitive.
<p>
If no more matching rows exist, the function returns CBF_NOTFOUND.
<p>
The current column is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>value</i><TD>&nbsp;&nbsp;the value to search for.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.24">2.3.24  cbf_rewind_row</A><br />
<A HREF="#2.3.28">2.3.28  cbf_next_row</A><br />
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />

<p><HR><P>
<h4><A NAME="2.3.34">2.3.34  cbf_count_datablocks</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_count_datablocks (cbf_handle <i>handle</i>,
unsigned int *<i>datablocks</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_count_datablocks puts the number of data blocks in *<i>datablocks</i>
.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablocks</i><TD>&nbsp;&nbsp;Pointer to the destination data block count.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.35">2.3.35  cbf_count_categories, cbf_count_saveframes, cbf_count_blockitems</A><br />
<A HREF="#2.3.36">2.3.36  cbf_count_columns</A><br />
<A HREF="#2.3.37">2.3.37  cbf_count_rows</A><br />
<A HREF="#2.3.38">2.3.38  cbf_select_datablock</A><br />

<p><HR><P>
<h4><A NAME="2.3.35">2.3.35  cbf_count_categories</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_count_categories (cbf_handle <i>handle</i>,
unsigned int *<i>categories</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_count_categories puts the number of categories in the current data
block in *<i>categories</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>categories</i><TD>&nbsp;&nbsp;Pointer to the destination category count.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.34">2.3.34  cbf_count_datablocks</A><br />
<A HREF="#2.3.36">2.3.36  cbf_count_columns</A><br />
<A HREF="#2.3.37">2.3.37  cbf_count_rows</A><br />
<A HREF="#2.3.39">2.3.39  cbf_select_category, cbf_select_saveframe, cbf_select_blockitem</A><br />

<p><HR><P>
<h4><A NAME="2.3.36">2.3.36  cbf_count_columns</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_count_columns (cbf_handle <i>handle</i>, unsigned int *<i>columns</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_count_columns puts the number of columns in the current category
in *<i>columns</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columns</i><TD>&nbsp;&nbsp;Pointer to the destination column count.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.34">2.3.34  cbf_count_datablocks</A><br />
<A HREF="#2.3.35">2.3.35  cbf_count_categories, cbf_count_saveframes, cbf_count_blockitems</A><br />
<A HREF="#2.3.37">2.3.37  cbf_count_rows</A><br />
<A HREF="#2.3.40">2.3.40  cbf_select_column</A><br />
<p>

<HR><p>
<h4><A NAME="2.3.37">2.3.37  cbf_count_rows</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_count_rows (cbf_handle <i>handle</i>, unsigned int *<i>rows</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_count_rows puts the number of rows in the current category in *<i>rows</i>
.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>rows</i><TD>&nbsp;&nbsp;Pointer to the destination row count.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.34">2.3.34  cbf_count_datablocks</A><br />
<A HREF="#2.3.35">2.3.35  cbf_count_categories, cbf_count_saveframes, cbf_count_blockitems</A><br />
<A HREF="#2.3.36">2.3.36  cbf_count_columns</A><br />
<A HREF="#2.3.41">2.3.41  cbf_select_row</A><br />

<p><HR><P>
<h4><A NAME="2.3.38">2.3.38  cbf_select_datablock</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_select_datablock (cbf_handle <i>handle</i>,
unsigned int <i>datablock</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_select_datablock selects data block number <i>datablock</i>
 as the current data block.
<p>
The first data block is number 0.
<p>
If the data block does not exist, the function returns CBF_NOTFOUND.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablock</i><TD>&nbsp;&nbsp;Number of the data block to select.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.34">2.3.34  cbf_count_datablocks</A><br />
<A HREF="#2.3.39">2.3.39  cbf_select_category, cbf_select_saveframe, cbf_select_blockitem</A><br />
<A HREF="#2.3.40">2.3.40  cbf_select_column</A><br />
<A HREF="#2.3.41">2.3.41  cbf_select_row</A>
<p><hr><P>
<h4><A NAME="2.3.39">2.3.39  cbf_select_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_select_category (cbf_handle <i>handle</i>,
unsigned int <i>category</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_select_category selects category number <i>category</i>
 in the current data block as the current category.
<p>
The first category is number 0.
<p>
The current column and row become undefined.
<p>
If the category does not exist, the function returns CBF_NOTFOUND.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>category</i><TD>&nbsp;&nbsp;Number of the category to select.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.35">2.3.35  cbf_count_categories, cbf_count_saveframes, cbf_count_blockitems</A><br />
<A HREF="#2.3.38">2.3.38  cbf_select_datablock</A><br />
<A HREF="#2.3.40">2.3.40  cbf_select_column</A><br />
<A HREF="#2.3.41">2.3.41  cbf_select_row</A><br />
<p><hr><P>
<h4><A NAME="2.3.40">2.3.40  cbf_select_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_select_column (cbf_handle <i>handle</i>, unsigned int <i>column</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_select_column selects column number <i>column</i>
 in the current category as the current column.
<p>
The first column is number 0.
<p>
The current row is not affected
<p>
If the column does not exist, the function returns CBF_NOTFOUND.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>column</i><TD>&nbsp;&nbsp;Number of the column to select.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.36">2.3.36  cbf_count_columns</A><br />
<A HREF="#2.3.38">2.3.38  cbf_select_datablock</A><br />
<A HREF="#2.3.39">2.3.39  cbf_select_category, cbf_select_saveframe, cbf_select_blockitem</A><br />
<A HREF="#2.3.41">2.3.41  cbf_select_row</A><br />
<p><hr><P>
<h4><A NAME="2.3.41">2.3.41  cbf_select_row</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_select_row (cbf_handle <i>handle</i>, unsigned int <i>row</i>);
<p>
<b>DESCRIPTION</b>
<p>
 cbf_select_row selects row number <i>row</i>
 in the current category as the current row.
<p>
The first row is number 0.
<p>
The current column is not affected
<p>
If the row does not exist, the function returns CBF_NOTFOUND.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>row</i><TD>&nbsp;&nbsp;Number of the row to select.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.37">2.3.37  cbf_count_rows</A><br />
<A HREF="#2.3.38">2.3.38  cbf_select_datablock</A><br />
<A HREF="#2.3.39">2.3.39  cbf_select_category, cbf_select_saveframe, cbf_select_blockitem</A><br />
<A HREF="#2.3.40">2.3.40  cbf_select_column</A><br />
<p><hr><P>
<h4><A NAME="2.3.42">2.3.42  cbf_datablock_name</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_datablock_name (cbf_handle <i>handle</i>,
const char **<i>datablockname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_datablock_name sets *<i>datablockname</i>
 to point to the name of the current data block.
<p>
The data block name will be valid as long as the data block exists
and has not been renamed.
<p>
The name must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;Pointer to the
destination data block name pointer.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />

<p><hr><P>
<h4><A NAME="2.3.43">2.3.43  cbf_category_name</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_category_name (cbf_handle <i>handle</i>,
const char **<i>categoryname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_category_name sets *<i>categoryname </i>
to point to the name of the current category of the current data block.
<p>
The category name will be valid as long as the category exists.
<p>
The name must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;Pointer to the
destination category name pointer.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />

<p><hr><P>
<h4><A NAME="2.3.44">2.3.44  cbf_column_name</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_column_name (cbf_handle <i>handle</i>, const char **<i>columnname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_column_name sets *<i>columnname </i>
to point to the name of the current column of the current category.
<p>
The column name will be valid as long as the column exists.
<p>
The name must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;Pointer to the
destination column name pointer.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />

<p><hr><P>
<h4><A NAME="2.3.45">2.3.45  cbf_row_number</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_row_number (cbf_handle <i>handle</i>, unsigned int *<i>row</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_row_number sets *<i>row</i>
 to the number of the current row of the current category.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>row</i><TD>&nbsp;&nbsp;Pointer to the destination row number.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.41">2.3.41  cbf_select_row</A><br />

<p><hr><P>
<h4><A NAME="2.3.46">2.3.46  cbf_get_value, cbf_require_value</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_value (cbf_handle <i>handle</i>, const char **<i>value</i>);<br />
int cbf_require_value (cbf_handle <i>handle</i>, const char **<i>value</i>, const char *<i>defaultvalue</i> );
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_value sets *<i>value</i>
 to point to the ASCII value of the item at the current column and row.
cbf_set_value sets *<i>value</i>
 to point to the ASCII value of the item at the current column and row,
 creating the data item if necessary
and initializing it to a copy of <i>defaultvalue</i>.

<p>
If the value is not ASCII, the function returns CBF_BINARY.
<p>
The value will be valid as long as the item exists and has not been set to a new value.

<p>
The value must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>value</i><TD>&nbsp;&nbsp;Pointer to the destination value pointer.<br />
<TR><TD>&nbsp;&nbsp;<i>value</i><TD>&nbsp;&nbsp;Default value character string.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.50">2.3.50  cbf_get_integervalue, cbf_require_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A><br />
<A HREF="#2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />


<p><hr><P>
<h4><A NAME="2.3.47">2.3.47  cbf_set_value</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_set_value (cbf_handle <i>handle</i>, const char *<i>value</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_value sets the item at the current column and row to the ASCII
value <i>value</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>value</i><TD>&nbsp;&nbsp;ASCII value.<br />
<TR><TD>&nbsp;&nbsp;<i>defaultvalue</i><TD>&nbsp;&nbsp;default ASCII value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.53">2.3.53  cbf_set_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.48">2.3.48  cbf_get_typeofvalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_typeofvalue (cbf_handle <i>handle</i>, const char **<i>typeofvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_value sets *<i>typeofvalue</i>
to point an ASCII descriptor of the value of the item at the current column and row.
The strings that may be returned are &quot;null&quot; for a null value indicated
by a &quot;.&quot; or a &quot;?&quot;, &quot;bnry&quot; for a binary value,
&quot;word&quot; for an unquoted string, &quot;dblq&quot; for a double-quoted string,
&quot;sglq&quot; for a single-quoted string, and &quot;text&quot; for a
semicolon-quoted text field.  A field for which no value has been set sets
*<i>typeofvalue</i> to NULL rather than to the
string &quot;null&quot;.


<p>
The <i>typeofvalue</i> must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>typeofvalue</i><TD>&nbsp;&nbsp;Pointer to the destination type-of-value string pointer.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.50">2.3.50  cbf_get_integervalue,  cbf_require_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A><br />
<A HREF="#2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.49">2.3.49  cbf_set_typeofvalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_set_typeofvalue (cbf_handle <i>handle</i>, const char *<i>typeofvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_typeofvalue
sets the type of the item at the current column and row to the type specified by
the ASCII character string given by <i>typeofvalue</i>. The strings that may be used
are &quot;null&quot; for a null value indicated by a &quot;.&quot; or a &quot;?&quot;,
&quot;word&quot; for an unquoted string, &quot;dblq&quot; for a double-quoted string,
&quot;sglq&quot; for a single-quoted string, and &quot;text&quot; for a semicolon-quoted
text field.  Not all types may be used for all values.  No changes may be made to the
type of binary values.  You may not set the type of a string that contains a single quote
followed by a blank or a tab or which contains multiple lines to &quot;sglq&quot;. You may
not set the type of a string that contains a double quote followed by a
blank or a tab or which contains multiple lines to &quot;dblq&quot;.

<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>typeofvalue</i><TD>&nbsp;&nbsp;ASCII string for desired type of value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.53">2.3.53  cbf_set_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />
<p><hr><P>




<h4><A NAME="2.3.50">2.3.50  cbf_get_integervalue, cbf_require_integervalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_integervalue (cbf_handle <i>handle</i>, int *<i>number</i>);<br />
int cbf_require_integervalue (cbf_handle <i>handle</i>, int *<i>number</i>, int <i>defaultvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_integervalue sets *<i>number</i>
 to the value of the ASCII item at the current column and row interpreted as a decimal
integer.
cbf_require_integervalue sets *<i>number</i>
 to the value of the ASCII item at the current column and row interpreted as a decimal
integer, setting it to <i>defaultvalue</i> if necessary.
<p>
If the value is not ASCII, the function returns CBF_BINARY.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;pointer to the number.<br />
<TR><TD>&nbsp;&nbsp;<i>defaultvalue</i><TD>&nbsp;&nbsp;default number value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A><br />
<A HREF="#2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.51">2.3.51  cbf_set_integervalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_set_integervalue (cbf_handle <i>handle</i>, int <i>number</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_integervalue sets the item at the current column and row to the integer value
<i>number</i>
 written as a decimal ASCII string.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;Integer value.</BR>
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.50">2.3.50  cbf_get_integervalue,  cbf_require_integervalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.53">2.3.53  cbf_set_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_doublevalue (cbf_handle <i>handle</i>, double *<i>number</i>);<br />
int cbf_require_doublevalue (cbf_handle <i>handle</i>, double *<i>number</i>, double <i>defaultvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_doublevalue sets *<i>number</i>
 to the value of the ASCII item at the current column and row interpreted as a decimal
floating-point number.
cbf_require_doublevalue sets *<i>number</i>
 to the value of the ASCII item at the current column and row interpreted as a decimal
floating-point number, setting it to <i>defaultvalue</i> if necessary.
<p>
If the value is not ASCII, the function returns CBF_BINARY.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;Pointer to the destination number.<br />
<TR><TD>&nbsp;&nbsp;<i>defaultvalue</i><TD>&nbsp;&nbsp;default number value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.50">2.3.50  cbf_get_integervalue,  cbf_require_integervalue</A><br />
<A HREF="#2.3.53">2.3.53  cbf_set_doublevalue</A><br />
<A HREF="#2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A><br />
<A HREF="#2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.53">2.3.53  cbf_set_doublevalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_set_doublevalue (cbf_handle <i>handle</i>,
const char *<i>format</i>, double <i>number</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_doublevalue sets the item at the current column and
row to the floating-point value <i>number</i>
written as an ASCII string with the format specified by
<i>format</i> as appropriate for the printf function.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>format</i><TD>&nbsp;&nbsp;Format for the number.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;Floating-point value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />
<p><hr><P>


<h4><A NAME="2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_integerarrayparameters (cbf_handle <i>handle</i>,
unsigned int *<i>compression</i>,
int *<i>binary_id</i>,
size_t *<i>elsize</i>,
int *<i>elsigned</i>, int *<i>elunsigned</i>,
size_t *<i>elements</i>,
int *<i>minelemen</i>t, int *<i>maxelement</i>);<br />
int cbf_get_realarrayparameters (cbf_handle <i>handle</i>,
unsigned int *<i>compression</i>,
int *<i>binary_id</i>,
size_t *<i>elsize</i>,
size_t *<i>elements</i>);
<p>

<b>DESCRIPTION</b>
<p>
cbf_get_integerarrayparameters sets *<i>compression</i>,
 *<i>binary_id</i>, *<i>elsize</i>,
 *<i>elsigned</i>, *<i>elunsigned</i>,
 *<i>elements</i>, *<i>minelement</i>
 and *<i>maxelement</i>
 to values read from the binary value of the item at the
current column and row.
This provides all the arguments needed for a subsequent call to
cbf_set_integerarray,
if a copy of the arry is to be made into another CIF or CBF.
cbf_get_realarrayparameters sets *<i>compression</i>,
 *<i>binary_id</i>, *<i>elsize</i>,
 *<i>elements</i>
 to values read from the binary value of the item at the
current column and row.
This provides all the arguments needed for a subsequent call to
cbf_set_realarray,
if a copy of the arry is to be made into another CIF or CBF.


<p>
If the value is not binary, the function returns CBF_ASCII.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>compression</i><TD>&nbsp;&nbsp;Compression method used.<br />
<TR><TD>&nbsp;&nbsp;<i>elsize</i><TD>&nbsp;&nbsp;Size in bytes of each array element.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>binary_id</i><TD>&nbsp;&nbsp;Pointer to the destination integer binary identifier.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>elsigned</i><TD>&nbsp;&nbsp;Pointer to an integer.  Set to 1 if the elements can be read as signed integers.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>elunsigned</i><TD>&nbsp;&nbsp;Pointer to an integer.  Set to 1 if the elements can be read as unsigned
integers.<br />
<TR><TD>&nbsp;&nbsp;<i>elements</i><TD>&nbsp;&nbsp;Pointer to the destination number of elements.<br />
<TR><TD>&nbsp;&nbsp;<i>minelement</i><TD>&nbsp;&nbsp;Pointer to the destination smallest element.<br />
<TR><TD>&nbsp;&nbsp;<i>maxelement</i><TD>&nbsp;&nbsp;Pointer to the destination largest element.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.50">2.3.50  cbf_get_integervalue,  cbf_require_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray </A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_integerarray (cbf_handle <i>handle</i>,
int *<i>binary_id</i>,
void *<i>array</i>, size_t <i>elsize</i>, int <i>elsigned</i>,
size_t <i>elements</i>, size_t *<i>elements_read</i>);<br />
int cbf_get_integerarray (cbf_handle <i>handle</i>,
int *<i>binary_id</i>,
void *<i>array</i>, size_t <i>elsize</i>,
size_t <i>elements</i>, size_t *<i>elements_read</i>);

<p>
<b>DESCRIPTION</b>
<p>
cbf_get_integerarray reads the binary value of the item at the current
column and row into an integer array.  The array consists of
<i>elements</i> elements of <i>elsize</i> bytes each, starting at
<i>array</i>.  The elements are signed if <i>elsigned</i>
 is non-0 and unsigned otherwise.  *<i>binary_id</i>
 is set to the binary section identifier and *<i>elements_read </i>
to the number of elements actually read.
cbf_get_realarray reads the binary value of the item at the current
column and row into a real array.  The array consists of
<i>elements</i> elements of <i>elsize</i> bytes each, starting at
<i>array</i>.   *<i>binary_id</i>
 is set to the binary section identifier and *<i>elements_read </i>
to the number of elements actually read.
<p>
If any element in the integer binary data cant fit into the destination
element, the destination is set the nearest possible value.
<p>
If the value is not binary, the function returns CBF_ASCII.
<p>
If the requested number of elements cant be read, the function
will read as many as
it can and then return CBF_ENDOFDATA.
<p>
Currently, the destination array must consist of chars,
shorts or ints (signed or unsigned).  If <i>elsize </i>
is not equal to sizeof (char), sizeof (short) or sizeof (int), for cbf_get_integerarray, or
sizeof(double) or sizeof(float), for cbf_get_realarray  the
function returns
CBF_ARGUMENT.
<p>
An additional restriction in the current version of CBFlib is that values too large
to fit in an int are not correctly decompressed.  As an example, if the machine with
32-bit ints is reading an array containing a value outside the range
0 .. 2^<SUP>32</sup>-1 (unsigned) or -2^<SUP>31</sup> .. 2^<SUP>31</sup>-1
(signed), the array will not be correctly decompressed.  This
restriction will be removed in a future release.  For cbf_get_realarray, only
IEEE format is supported.  No conversion to other floating point formats
is done at this time.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>binary_id</i><TD>&nbsp;&nbsp;Pointer to the destination
integer binary identifier.<br />
<TR><TD>&nbsp;&nbsp;<i>array</i><TD>&nbsp;&nbsp;Pointer to the destination array.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>elsize</i><TD>&nbsp;&nbsp;Size in bytes of each
destination array element.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>elsigned</i><TD>&nbsp;&nbsp;Set to non-0 if the
destination array elements are signed.<br />
<TR><TD>&nbsp;&nbsp;<i>elements</i><TD>&nbsp;&nbsp;The number of elements to read.<br />
<TR><TD VALIGN=TOP>&nbsp;&nbsp;<i>elements_read</i><TD>&nbsp;&nbsp;Pointer to the
destination number of elements actually read.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.<br />

SEE ALSO
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.50">2.3.50  cbf_get_integervalue,  cbf_require_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />
<p><hr><P>
<h4><A NAME="2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_set_integerarray (cbf_handle <i>handle</i>,
unsigned int <i>compression</i>,
int <i>binary_id</i>,
void *<i>array</i>, size_t <i>elsize</i>, int <i>elsigned</i>,
size_t <i>elements</i>);<br />
int cbf_set_realarray (cbf_handle <i>handle</i>,
unsigned int <i>compression</i>,
int <i>binary_id</i>,
void *<i>array</i>, size_t <i>elsize</i>,
size_t <i>elements</i>);<br />
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_integerarray sets the binary value of the item at the current
column and row to an integer <i>array</i>.
 The array consists of <i>elements</i>
 elements of <i>elsize</i>
 bytes each, starting at <i>array</i>.  The elements
are signed if <i>elsigned</i>
 is non-0 and unsigned otherwise.  <i>binary_id</i>
 is the binary section identifier.
cbf_set_realarray sets the binary value of the item at the current
column and row to an integer <i>array</i>.
 The array consists of <i>elements</i>
 elements of <i>elsize</i>
 bytes each, starting at <i>array</i>.  <i>binary_id</i>
 is the binary section identifier.
<p>
The array will be compressed using the compression scheme specifed
by <i>compression</i>.  Currently, the available schemes are:
<p>
<TABLE>
<TR><TD>&nbsp;&nbsp;CBF_CANONICAL<TD>&nbsp;&nbsp;Canonical-code compression  (section 3.3.1)<br />
<TR><TD>&nbsp;&nbsp;CBF_PACKED<TD>&nbsp;&nbsp;CCP4-style packing   (section 3.3.2)
<TR><TD VALIGN=TOP>&nbsp;&nbsp;CBF_NONE<TD>&nbsp;&nbsp;No compression.  NOTE:  This scheme is by
far the slowest of the three and uses much more disk space.  It is
intended for routine use with small arrays only.  With large arrays
(like images) it should be used only for debugging.
</TABLE>
<p>
The values compressed are limited to 64 bits.  If any element in the array is larger
than 64 bits, the value compressed is the nearest 64-bit value.
<p>
Currently, the source array must consist of chars, shorts or ints (signed or unsigned),
for cbf_set_integerarray, or IEEE doubles or floats for cbf_set_realarray.
 If <i>elsize </i>
is not equal to sizeof (char), sizeof (short) or sizeof (int), the function returns
CBF_ARGUMENT.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>compression</i><TD>&nbsp;&nbsp;Compression method to use.<br />
<TR><TD>&nbsp;&nbsp;<i>binary_id</i><TD>&nbsp;&nbsp;Integer binary identifier.<br />
<TR><TD>&nbsp;&nbsp;<i>array</i><TD>&nbsp;&nbsp;Pointer to the source array.<br />
<TR><TD>&nbsp;&nbsp;<i>elsize</i><TD>&nbsp;&nbsp;Size in bytes of each source array element.<br />
<TR><TD>&nbsp;&nbsp;<i>elsigned</i><TD>&nbsp;&nbsp;Set to non-0 if the source array elements are signed.<br />
elements: The number of elements in the array.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.53">2.3.53  cbf_set_doublevalue</A><br />
<A HREF="#2.3.54">2.3.54  cbf_get_integerarrayparameters, cbf_get_realarrayparameters</A><br />
<A HREF="#2.3.55">2.3.55  cbf_get_integerarray, cbf_get_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.64">2.3.64  cbf_require_column_doublevalue</A><br />

<p><hr><P>
<h4><A NAME="2.3.57">2.3.57  cbf_failnez</A></h4>
<p>
<b>DEFINITION</b>
<p>
#include &quot;cbf.h&quot;<p>

#define cbf_failnez(f) {int err; err = (f); if (err) return err; }
<p>
<b>DESCRIPTION</b>
<p>
cbf_failnez is a macro used for error propagation throughout CBFlib.  cbf_failnez
executes the function <i>f</i>
 and saves the returned error value.  If the error value is non-0, cbf_failnez executes
a return with the error value as argument.  If CBFDEBUG is defined, then a report of
the error is also printed to the standard error stream, stderr, in the form
<p>
CBFlib error <i>f</i> in &quot;<i>symbol</i>&quot;
<p>
where <i>f</i> is the decimal value of the error and  <i>symbol</i> is the symbolic
form.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>f</i><TD>&nbsp;&nbsp;Integer error value.<br />
</TABLE>
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.58">2.3.58  cbf_onfailnez</A><br />
<p><hr><P>
<h4><A NAME="2.3.58">2.3.58  cbf_onfailnez</A></h4>
<p><b>DEFINITION</b>
<p>
#include &quot;cbf.h&quot;<p>

#define cbf_onfailnez(f,c) {int err; err = (f); if (err) {{c; }return err; }}
<p>
<b>DESCRIPTION</b>
<p>
cbf_onfailnez is a macro used for error propagation throughout CBFlib.
cbf_onfailnez executes the function <i>f</i>
and saves the returned error value.  If the error value is non-0,
cbf_failnez executes first the statement <i>c</i>
 and then a return with the error value as argument.   If CBFDEBUG is defined,
 then a report of
the error is also printed to the standard error stream, stderr, in the form
<p>
CBFlib error <i>f</i> in &quot;<i>symbol</i>&quot;
<p>
where <i>f</i> is the decimal value of the error and  <i>symbol</i> is the symbolic
form.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>f</i><TD>&nbsp;&nbsp;integer function to execute.<br />
<TR><TD>&nbsp;&nbsp;<i>c</i><TD>&nbsp;&nbsp;statement to execute on failure.<br />
</TABLE>
<p><b>SEE ALSO</b>
<LI><A HREF="#2.3.57">2.3.57   cbf_failnez</A>



<p><hr><P>
<h4><A NAME="2.3.59">2.3.59   cbf_require_datablock</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_require_datablock (cbf_handle  <i>handle</i>,
                             const char *<i>datablockname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_require_datablock makes the data block with name <i>datablockname</i>
 the current data block, if it exists, or creates it if it does not.
<p>
The comparison is case-insensitive.
<p>
The current category becomes undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>datablockname</i><TD>&nbsp;&nbsp;The name of the data block to find
or create.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.21">2.3.21  cbf_rewind_datablock</A><br />
<A HREF="#2.3.25">2.3.25  cbf_next_datablock</A><br />
<A HREF="#2.3.30">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.42">2.3.42  cbf_datablock_name</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />


<p><hr><P>
<h4><A NAME="2.3.60">2.3.60   cbf_require_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_require_category (cbf_handle  <i>handle</i>,
                             const char *<i>categoryname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_rewuire_category makes the category in the current data block with
name <i>categoryname</i> the current category, if it exists, or creates
the catagory if it does not exist.
<p>
The comparison is case-insensitive.
<p>
The current column and row become undefined.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;The name of the category to find.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.22">2.3.22  cbf_rewind_category, cbf_rewind_saveframe, cbf_rewind_blockitem</A><br />
<A HREF="#2.3.26">2.3.26  cbf_next_category, cbf_next_saveframe, cbf_next_blockitem</A><br />
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.31">2.3.31  cbf_find_column</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.43">2.3.43  cbf_category_name</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.61">2.3.61  cbf_require_column</A><br />

							
<p><hr><P>
<h4><A NAME="2.3.61">2.3.61   cbf_require_column</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_require_column (cbf_handle  <i>handle</i>,
                             const char *<i>columnname</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_require_column makes the columns in the current category with
name <i>columnname</i> the current column, if it exists,
or creates it if it does not.
<p>
The comparison is case-insensitive.
<p>
The current row is not affected.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;The name of column to find.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.19">2.3.19  cbf_rewind_column</A><br />
<A HREF="#2.3.27">2.3.27  cbf_next_column</A><br />
<A HREF="#2.3.29">2.3.29  cbf_find_datablock</A><br />
<A HREF="#2.3.30">2.3.30  cbf_find_category, cbf_find_saveframe, cbf_find_blockitem</A><br />
<A HREF="#2.3.32">2.3.32  cbf_find_row</A><br />
<A HREF="#2.3.44">2.3.44  cbf_column_name</A><br />
<A HREF="#2.3.59">2.3.59  cbf_require_datablock</A><br />
<A HREF="#2.3.60">2.3.60  cbf_require_category</A><br />



<p><hr><P>
<h4><A NAME="2.3.62">2.3.62  cbf_require_column_value</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_require_column_value (cbf_handle <i>handle</i>,
const char *<i>columnname</i>,
const char **<i>value</i>,
const char *<i>defaultvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_require_column_doublevalue
sets *<i>value</i>
 to the ASCII item at the current row for the column given
 with the name given by *<i>columnname</i>, or to the string
 given by <i>defaultvalue</i> if the
 item cannot be found.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;Name of the column containing the number.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;pointer to the location to receive the integer value.<br />
<TR><TD>&nbsp;&nbsp;<i>defaultvalue</i><TD>&nbsp;&nbsp;Value to use if the requested
column and value cannot be found.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.63  cbf_require_column_integervalue</A><br />
<A HREF="#2.3.63">2.3.64  cbf_require_column_doublevalue</A><br />




<p><hr><P>
<h4><A NAME="2.3.63">2.3.63  cbf_require_column_integervalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_require_column_integervalue (cbf_handle <i>handle</i>,
const char *<i>columnname</i>,
int *<i>number</i>,
const int <i>defaultvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_require_column_doublevalue
sets *<i>number</i>
 to the value of the ASCII item at the current row for the column given
 with the name given by *<i>columnname</i>, with the value interpreted as an
integer number, or to the number given by <i>defaultvalue</i> if the
item cannot be found.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;Name of the column containing the number.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;pointer to the location to receive the integer value.<br />
<TR><TD>&nbsp;&nbsp;<i>defaultvalue</i><TD>&nbsp;&nbsp;Value to use if the requested
column and value cannot be found.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.64  cbf_require_column_doublevalue</A><br />



<p><hr><P>
<h4><A NAME="2.3.64">2.3.64  cbf_require_column_doublevalue</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_require_column_doublevalue (cbf_handle <i>handle</i>,
const char *<i>columnname</i>,
double *<i>number</i>,
const double <i>defaultvalue</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_require_column_doublevalue
sets *<i>number</i>
 to the value of the ASCII item at the current row for the column given
 with the name given by *<i>columnname</i>, with the value interpreted as a decimal
floating-point number, or to the number given by <i>defaultvalue</i> if the
item cannot be found.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>columnname</i><TD>&nbsp;&nbsp;Name of the column containing the number.<br />
<TR><TD>&nbsp;&nbsp;<i>number</i><TD>&nbsp;&nbsp;pointer to the location to receive the floating-point value.<br />
<TR><TD>&nbsp;&nbsp;<i>defaultvalue</i><TD>&nbsp;&nbsp;Value to use if the requested
column and value cannot be found.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.3.46">2.3.46  cbf_get_value, cbf_require_value</A><br />
<A HREF="#2.3.47">2.3.47  cbf_set_value</A><br />
<A HREF="#2.3.48">2.3.48  cbf_get_typeofvalue</A><br />
<A HREF="#2.3.49">2.3.49  cbf_set_typeofvalue</A><br />
<A HREF="#2.3.51">2.3.51  cbf_set_integervalue</A><br />
<A HREF="#2.3.52">2.3.52  cbf_get_doublevalue, cbf_require_doublevalue</A><br />
<A HREF="#2.3.56">2.3.56  cbf_set_integerarray, cbf_set_realarray</A><br />
<A HREF="#2.3.62">2.3.62  cbf_require_column_value</A><br />
<A HREF="#2.3.63">2.3.63  cbf_require_column_integervalue</A><br />


<p><hr><P>
<h4><A NAME="2.3.65">2.3.65  cbf_get_local_integer_byte_order,  
cbf_get_local_real_byte_order, cbf_get_local_real_format </A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_local_integer_byte_order (char ** <i>byte_order</i>);<br />
int cbf_get_local_real_byte_order (char ** <i>byte_order</i>);<br />
int cbf_get_local_real_format (char ** <i>real_format</i> );
<p>
<b>DESCRIPTION</b>
<p>cbf_get_local_integer_byte_order returns the byte order of integers
on the machine on which the API is being run in the form of a character string 
returned as the value pointed to by <i>byte_order</i>. cbf_get_local_real_byte_order 
returns the byte order of reals on the machine on which the API is being run 
in the form of a character string  returned as the value pointed to by <i>byte_order</i>. 
cbf_get_local_real_format returns the format of floats on the machine on which 
the API is being run in the form of a character string returned as the value pointed to by
<i>real_format</i>.  The strings returned must not be modified in any way.
<P>
The values returned in <i>byte_order</i> may be the strings &quot;little_endian&quot;
or &quot;big-endian&quot;.  The values returned in <i>real_format</i> may be the strings
&quot;ieee 754-1985&quot; or &quot;other&quot;.  Additional values may be returned
by future versions of the API.
<P>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>byte_order</i><TD>&nbsp;&nbsp;pointer to the returned string<br />
<TR><TD>&nbsp;&nbsp;<i>real_format</i><TD>&nbsp;&nbsp;pointer to the returned string<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>

<h4><A NAME="2.3.66">2.3.66  cbf_get_dictionary, cbf_set_dictionary, cbf_require_dictionary</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_get_dictionary (cbf_handle <i>handle</i>, cbf_handle * <i>dictionary</i>);<br />
int cbf_set_dictionary (cbf_handle <i>handle</i>, cbf_handle <i>dictionary_in</i>);<br />
int cbf_require_dictionary (cbf_handle <i>handle</i>, cbf_handle * <i>dictionary</i>)
<P>
<b>DESCRIPTION</b>
<p>
cbf_get_dictionary sets *<i>dictionary</i> to the handle of a CBF which has been 
associated with the CBF <i>handle</i> by cbf_set_dictionary.  cbf_set_dictionary
associates the CBF handle <i>dictionary_in</i> with <i>handle</i> as its dictionary.
cbf_require_dictionary sets *<i>dictionary</i> to the handle of a CBF which has been 
associated with the CBF <i>handle</i> by cbf_set_dictionary or creates a new
empty CBF and associates it with <i>handle</i>, returning the new handle in 
*<i>dictionary</i>.
<P>
<b>ARGUMENTS</b><br />
<table>
 <TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
 <TR><TD>&nbsp;&nbsp;<i>dictionary</i><TD>&nbsp;&nbsp;Pointer to CBF handle of dictionary.<br />
 <TR><TD>&nbsp;&nbsp;<i>dictionary_in</i><TD>&nbsp;&nbsp;CBF handle of dcitionary.<br />
</table>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>

<h4><A NAME="2.3.67">2.3.67 cbf_convert_dictionary</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_convert_dictionary (cbf_handle <i>handle</i>, cbf_handle <i>dictionary</i> )
<P>
<b>DESCRIPTION</b>
<p>
cbf_convert_dictionary converts <i>dictionary</i> as a DDL1 or DDL2 dictionary to
a CBF dictionary of category and item properties for <i>handle</i>, creating
a new dictionary if none exists or layering the definitions in  <i>dictionary</i>
onto the existing dictionary of <i>handle</i> if one exists.
<P>
If a CBF is read into <i>handle</i> after calling cbf_convert_dictionary, then
the dictionary will be used for validation of the CBF as it is read.
<P>
<b>ARGUMENTS</b><br />
<table>
 <TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
 <TR><TD>&nbsp;&nbsp;<i>dictionary</i><TD>&nbsp;&nbsp;CBF handle of dictionary.<br />
</table>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>


<h4><A NAME="2.3.68">2.3.68 cbf_find_tag, cbf_find_local_tag</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_tag (cbf_handle <i>handle</i>, const char *<i>tag</i>)<br />
int cbf_find_local_tag (cbf_handle <i>handle</i>, const char *<i>tag</i>)

<P>
<b>DESCRIPTION</b>
<p>

cbf_find_tag searches all of the CBF <i>handle</i> for the CIF tag given
by the string <i>tag</i> and makes it the current tag.  The search does
not include the dictionary, but does include save frames as well as
categories.
<P>
The string <i>tag</i> is the complete tag in either DDL1 or DDL2 format,
starting with the leading underscore, not just a category or column.
<P>
<b>ARGUMENTS</b><br />
<table>
 <TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
 <TR><TD>&nbsp;&nbsp;<i>tag</i><TD>&nbsp;&nbsp;CIF tag.<br />
</table>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>



<h4><A NAME="2.3.69">2.3.69 cbf_find_category_root, cbf_set_category_root, cbf_require_category_root</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_category_root (cbf_handle <i>handle</i>, const char* <i>categoryname</i>,
                                            const char** <i>categoryroot</i>);<br />
int cbf_set_category_root (cbf_handle <i>handle</i>, const char* <i>categoryname_in</i>,
                                            const char*<i>categoryroot</i>);<br />
int cbf_require_category_root (cbf_handle handle, const char* <i>categoryname</i>,
                                            const char** <i>categoryroot</i>);

<P>
<b>DESCRIPTION</b>
<p>
cbf_find_category_root sets *<i>categoryroot</i> to the root category
of which <i>categoryname</i> is an alias.   cbf_set_category_root
sets <i>categoryname_in</i> as an alias of <i>categoryroot</i> in the
dictionary associated with <i>handle</i>, creating the dictionary
if necessary.  cbf_require_category_root sets *<i>categoryroot</i> 
to the root category of which <i>categoryname</i> is an alias, if
there is one, or to the value of <i>categoryname</i>, if 
<i>categoryname</i> is not an alias. 
<P>
A returned <i>categoryroot</i> string must not be modified in any way.
<P>
<b>ARGUMENTS</b><br />
<table>
 <TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
 <TR><TD>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;category name which may be an alias.<br />
 <TR><TD>&nbsp;&nbsp;<i>categoryroot</i><TD>&nbsp;&nbsp;pointer to a returned category root name.<br />
 <TR><TD>&nbsp;&nbsp;<i>categoryroot_in</i><TD>&nbsp;&nbsp;input category root name.<br />
</table>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>


<h4><A NAME="2.3.70">2.3.70 cbf_find_tag_root, cbf_set_tag_root, cbf_require_tag_root</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_tag_root (cbf_handle <i>handle</i>, const char* <i>tagname</i>,
                                            const char** <i>tagroot</i>);<br />
int cbf_set_tag_root (cbf_handle <i>handle</i>, const char* <i>tagname</i>,
                                            const char*<i>tagroot_in</i>);<br />
int cbf_require_tag_root (cbf_handle handle, const char* <i>tagname</i>,
                                            const char** <i>tagroot</i>);

<P>
<b>DESCRIPTION</b>
<p>
cbf_find_tag_root sets *<i>tagroot</i> to the root tag
of which <i>tagname</i> is an alias.   cbf_set_tag_root
sets <i>tagname</i> as an alias of <i>tagroot_in</i> in the
dictionary associated with <i>handle</i>, creating the dictionary
if necessary.  cbf_require_tag_root sets *<i>tagroot</i> 
to the root tag of which <i>tagname</i> is an alias, if
there is one, or to the value of <i>tagname</i>, if 
<i>tagname</i> is not an alias. 
<P>
A returned <i>tagroot</i> string must not be modified in any way.
<P>
<b>ARGUMENTS</b><br />
<table>
 <TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
 <TR><TD>&nbsp;&nbsp;<i>tagname</i><TD>&nbsp;&nbsp;tag name which may be an alias.<br />
 <TR><TD>&nbsp;&nbsp;<i>tagroot</i><TD>&nbsp;&nbsp;pointer to a returned tag root name.<br />
 <TR><TD>&nbsp;&nbsp;<i>tagroot_in</i><TD>&nbsp;&nbsp;input tag root name.<br />
</table>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>

<h4><A NAME="2.3.71">2.3.71 cbf_find_tag_category, cbf_set_tag_category</A></h4>
<p><b>PROTOTYPE</b>
<p>
#include &quot;cbf.h&quot;<p>

int cbf_find_tag_category (cbf_handle <i>handle</i>, const char* <i>tagname</i>,
                                            const char** <i>categoryname</i>);<br />
int cbf_set_tag_category (cbf_handle <i>handle</i>, const char* tagname,
                                            const char* <i>categoryname_in</i>);
<P>
<b>DESCRIPTION</b>
<p>
cbf_find_tag_category sets <i>categoryname</i> to the category associated
with <i>tagname</i> in the dictionary associated with <i>handle</i>.
cbf_set_tag_category upddates the dictionary associated with <i>handle</i>
to indicated that <i>tagname</i> is in category <i>categoryname_in</i>.
<P>
<b>ARGUMENTS</b><br />
<table>
 <TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
 <TR><TD>&nbsp;&nbsp;<i>tagname</i><TD>&nbsp;&nbsp;tag name.<br />
 <TR><TD>&nbsp;&nbsp;<i>categoryname</i><TD>&nbsp;&nbsp;pointer to a returned category name.<br />
 <TR><TD>&nbsp;&nbsp;<i>categoryname_in</i><TD>&nbsp;&nbsp;input category name.<br />
</table>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p>

<HR><HR>
<p>
<h4><A NAME="2.4">2.4 High-level function prototypes</A></H4>
<p>
<h4><A NAME="2.4.1">2.4.1 cbf_read_template</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_read_template (cbf_handle <i>handle</i>, FILE <i>*file</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_read_template reads the CBF or CIF file <I>file</I> into the CBF object
specified by <I>handle</I> and selects the first datablock as the current datablock.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;Pointer to a CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>file</i><TD>&nbsp;&nbsp;Pointer to a file descriptor.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.

<p><hr><P>
<h4><A NAME="2.4.2">2.4.2 cbf_get_diffrn_id, cbf_require_diffrn_id</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_diffrn_id (cbf_handle <i>handle</i>, const char **<i>diffrn_id</i>);<br />
int cbf_require_diffrn_id (cbf_handle <i>handle</i>, const char **<i>diffrn_id</i>, const char *<i>default_id</i>)
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_diffrn_id sets *<I>diffrn_id</I> to point to the ASCII value of the 
&quot;diffrn.id&quot; entry.
cbf_require_diffrn_id also sets *<I>diffrn_id</I> to point to the ASCII value of the 
&quot;diffrn.id&quot; entry, but, if the &quot;diffrn.id&quot; entry does not exist,
it sets the value in the CBF and in*<I>diffrn_id</I> to the character string given by 
<i>default_id</i>, creating the category and column is necessary.
<p>
The <I>diffrn_id</I> will be valid as long as the item exists and has not been set to a new value.
<p>
The <I>diffrn_id</I> must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>diffrn_id</i><TD>&nbsp;&nbsp;Pointer to the destination value pointer.<br />
<TR><TD>&nbsp;&nbsp;<i>default_id</i><TD>&nbsp;&nbsp;Character string default value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.3">2.4.3 cbf_set_diffrn_id</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_diffrn_id (cbf_handle <i>handle</i>, const char *<i>diffrn_id</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_diffrn_id sets the &quot;diffrn.id&quot; entry of the current datablock to the ASCII value <i>diffrn_id</i>.
<p>
This function also changes corresponding &quot;diffrn_id&quot; entries in the &quot;diffrn_source&quot;, &quot;diffrn_radiation&quot;, &quot;diffrn_detector&quot; and &quot;diffrn_measurement&quot; categories.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>diffrn_id</i><TD>&nbsp;&nbsp;ASCII value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.4">2.4.4 cbf_get_crystal_id</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_crystal_id (cbf_handle <i>handle</i>, const char **<i>crystal_id</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_crystal_id sets *<i>crystal_id</i> to point to the ASCII value of the &quot;diffrn.crystal_id&quot; entry.
<p>
If the value is not ASCII, the function returns CBF_BINARY.
<p>
The value will be valid as long as the item exists and has not been set to a new value.
<p>
The value must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>crystal_id</i><TD>&nbsp;&nbsp;Pointer to the destination value pointer.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.5">2.4.5 cbf_set_crystal_id</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_crystal_id (cbf_handle <i>handle</i>, const char *<i>crystal_id</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_crystal_id sets the &quot;diffrn.crystal_id&quot; entry to the ASCII value <i>crystal_id</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>crystal_id</i><TD>&nbsp;&nbsp;ASCII value.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.6">2.4.6 cbf_get_wavelength</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_wavelength (cbf_handle <i>handle</i>, double *<i>wavelength</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_wavelength sets *<i>wavelength</i> to the current wavelength in &Aring;.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>wavelength</i><TD>&nbsp;&nbsp;Pointer to the destination.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.7">2.4.7 cbf_set_wavelength</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_wavelength (cbf_handle <i>handle</i>, double <i>wavelength</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_wavelength sets the current wavelength in &Aring; to <i>wavelength</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>wavelength</i><TD>&nbsp;&nbsp;Wavelength in &Aring;.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.8">2.4.8 cbf_get_polarization</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_polarization (cbf_handle <i>handle</i>, double *<i>polarizn_source_ratio</i>,
double *<i>polarizn_source_norm</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_polarization sets *<i>polarizn_source_ratio</i> and *<i>polarizn_source_norm</i>
to the corresponding source polarization parameters.
<p>
Either destination pointer may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>polarizn_source_ratio</i><TD>&nbsp;&nbsp;Pointer to the destination polarizn_source_ratio.
<TR><TD>&nbsp;&nbsp;<i>polarizn_source_norm</i><TD>&nbsp;&nbsp;Pointer to the destination polarizn_source_norm.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.9">2.4.9 cbf_set_polarization
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_polarization (cbf_handle <i>handle</i>, double <i>polarizn_source_ratio</i>,
double <i>polarizn_source_norm</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_polarization sets the source polarization to the values specified by <i>polarizn_source_ratio</i> and <i>polarizn_source_norm</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>polarizn_source_ratio</i><TD>&nbsp;&nbsp;New value of polarizn_source_ratio.
<TR><TD>&nbsp;&nbsp;<i>polarizn_source_norm</i><TD>&nbsp;&nbsp;New value of polarizn_source_norm.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.10">2.4.10 cbf_get_divergence</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_divergence (cbf_handle <i>handle</i>, double *<i>div_x_source</i>, double *<i>div_y_source</i>,
	double *<i>div_x_y_source</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_divergence sets *<i>div_x_source</i>, *<i>div_y_source</i> and *<i>div_x_y_source</i> to the corresponding source divergence parameters.
<p>
Any of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>div_x_source</i><TD>&nbsp;&nbsp;Pointer to the destination div_x_source.
<TR><TD>&nbsp;&nbsp;<i>div_y_source</i><TD>&nbsp;&nbsp;Pointer to the destination div_y_source.
<TR><TD>&nbsp;&nbsp;<i>div_x_y_source</i><TD>&nbsp;&nbsp;Pointer to the destination div_x_y_source.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.11">2.4.11 cbf_ set_divergence</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_divergence (cbf_handle <i>handle</i>, double <i>div_x_source</i>, double <i>div_y_source</i>,
	double <i>div_x_y_source</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_divergence sets the source divergence parameters to the values specified by <i>div_x_source</i>, <i>div_y_source</i> and <i>div_x_y_source</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>div_x_source</i><TD>&nbsp;&nbsp;New value of div_x_source.
<TR><TD>&nbsp;&nbsp;<i>div_y_source</i><TD>&nbsp;&nbsp;New value of div_y_source.
<TR><TD>&nbsp;&nbsp;<i>div_x_y_source</i><TD>&nbsp;&nbsp;New value of div_x_y_source.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.12">2.4.12 cbf_count_elements</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_count_elements (cbf_handle <i>handle</i>, unsigned int *<i>elements</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_count_elements sets *<i>elements</i>  to the number of detector elements.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>elements</i><TD>&nbsp;&nbsp;Pointer to the destination count.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.13">2.4.13 cbf_get_element_id</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_element_id (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>, const char **<i>element_id</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_element_id sets *<i>element_id</i> to point to the ASCII value of the <i>element_number</i>th &quot;diffrn_data_frame.detector_element_id&quot; entry, counting from 0.
<p>
If the detector element does not exist, the function returns CBF_NOTFOUND.
<p>
The <i>element_id</i> will be valid as long as the item exists and has not been set to a new value.
<p>
The <i>element_id</i> must not be modified by the program in any way.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>element_id</i><TD>&nbsp;&nbsp;Pointer to the destination.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>


<h4><A NAME="2.4.14">2.4.14 cbf_get_gain</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_gain (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>, double *<i>gain</i>, double *<i>gain_esd</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_gain sets *<i>gain</i> and *<i>gain_esd</i> to the corresponding gain parameters for element number <i>element_number</i>.
<p>
Either of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>gain</i><TD>&nbsp;&nbsp;Pointer to the destination gain.
<TR><TD>&nbsp;&nbsp;<i>gain_esd</i><TD>&nbsp;&nbsp;Pointer to the destination gain_esd.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.15">2.4.15 cbf_ set_gain</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_gain (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>, double <i>gain</i>, double <i>gain_esd</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_gain sets the gain of element number <i>element_number</i> to the values specified by <i>gain</i> and <i>gain_esd</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>gain</i><TD>&nbsp;&nbsp;New gain value.
<TR><TD>&nbsp;&nbsp;<i>gain_esd</i><TD>&nbsp;&nbsp;New gain_esd value.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.16">2.4.16 cbf_get_overload</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_overload (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>, double *<i>overload</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_overload sets *<i>overload</i> to the overload value for element number <i>element_number</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>overload</i><TD>&nbsp;&nbsp;Pointer to the destination overload.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.17">2.4.17 cbf_ set_overload</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_overload (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>, double <i>overload</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_overload sets the overload value of element number <i>element_number</i> to <i>overload</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>overload</i><TD>&nbsp;&nbsp;New overload value.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.18">2.4.18 cbf_get_integration_time</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_integration_time (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, double *<i>time</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_integration_time sets *<i>time</i> to the integration time in seconds.   The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>time	Pointer to the destination time.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.19">2.4.19 cbf_set_integration_time</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_integration_time (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, double <i>time</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_integration_time sets the integration time in seconds to the value specified by <i>time</i>.  The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>time	Integration</i><TD>&nbsp;&nbsp;time in seconds.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.20">2.4.20 cbf_get_timestamp</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_timestamp (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, double *<i>time</i>, int *<i>timezone</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_timestamp sets *<i>time</i> to the collection timestamp in seconds since January 1 1970.  *<i>timezone</i> is set to timezone difference from UTC in minutes.  The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>

Either of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>time</i><TD>&nbsp;&nbsp;Pointer to the destination collection timestamp.
<TR><TD>&nbsp;&nbsp;<i>timezone</i><TD>&nbsp;&nbsp;Pointer to the destination timezone difference.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.21">2.4.21 cbf_set_timestamp</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_timestamp (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, double <i>time</i>, int <i>timezone</i>,
double <i>precision</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_timestamp sets the collection timestamp in seconds since January 1 1970 to the value specified by <i>time</i>.  The timezone difference from UTC in minutes is set to <i>timezone</i>.   If no timezone is desired, <i>timezone</i> should be CBF_NOTIM
EZONE.  The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
The precision of the new timestamp is specified by the value <i>precision</i> in seconds.  If <i>precision</i> is 0, the saved timestamp is assumed accurate to 1 second.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>time</i><TD>&nbsp;&nbsp;Timestamp in seconds since January 1 1970.
<TR><TD>&nbsp;&nbsp;<i>timezone</i><TD>&nbsp;&nbsp;Timezone difference from UTC in minutes or CBF_NOTIMEZONE.
<TR><TD>&nbsp;&nbsp;<i>precision</i><TD>&nbsp;&nbsp;Timestamp precision in seconds.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.22">2.4.22 cbf_get_datestamp</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_datestamp (cbf_handle <i>handle</i>, unsigned int  <i>reserved</i>, int *<i>year</i>, int *<i>month</i>, int *<i>day</i>,
int *<i>hour</i>, int *<i>minute</i>, double *<i>second</i>, int *<i>timezone</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_datestamp sets *<i>year</i>, *<i>month</i>, *<i>day</i>, *<i>hour</i>, *<i>minute</i> and *<i>second</i> to the corresponding values of the collection timestamp.  *<i>timezone</i> is set to timezone difference from UTC in minutes.  The parameter <
i>reserved</i> is presently unused and should be set to 0.
<p>
Any of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>year</i><TD>&nbsp;&nbsp;Pointer to the destination timestamp year.
<TR><TD>&nbsp;&nbsp;<i>month</i><TD>&nbsp;&nbsp;Pointer to the destination timestamp month (1-12).
<TR><TD>&nbsp;&nbsp;<i>day</i><TD>&nbsp;&nbsp;Pointer to the destination timestamp day (1-31).
<TR><TD>&nbsp;&nbsp;<i>hour</i><TD>&nbsp;&nbsp;Pointer to the destination timestamp hour (0-23).
<TR><TD>&nbsp;&nbsp;<i>minute</i><TD>&nbsp;&nbsp;Pointer to the destination timestamp minute (0-59).
<TR><TD>&nbsp;&nbsp;<i>second</i><TD>&nbsp;&nbsp;Pointer to the destination timestamp second (0-60.0).
<TR><TD>&nbsp;&nbsp;<i>timezone</i><TD>&nbsp;&nbsp;Pointer to the destination timezone difference from UTC in minutes.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.23">2.4.23 cbf_set_datestamp</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_datestamp (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, int <i>year</i>, int <i>month</i>, int <i>day</i>, int <i>hour</i>,
int <i>minute</i>, double <i>second</i>, int <i>timezone</i>, double <i>precision</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_datestamp sets the collection timestamp in seconds since January 1 1970 to the value specified by <i>time</i>.  The timezone difference from UTC in minutes is set to <i>timezone</i>.   If no timezone is desired, <i>timezone</i> should be CBF_NOTIM
EZONE.  The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
The precision of the new timestamp is specified by the value <i>precision</i> in seconds.  If <i>precision</i> is 0, the saved timestamp is assumed accurate to 1 second.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>time</i><TD>Timestamp in seconds since January 1 1970.
<TR><TD>&nbsp;&nbsp;<i>timezone</i><TD>Timezone difference from UTC in minutes or CBF_NOTIMEZONE.
<TR><TD>&nbsp;&nbsp;<i>precision</i><TD>Timestamp precision in seconds.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.24">2.4.24 cbf_set_current_timestamp</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_current_timestamp (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, int <i>timezone</i>)
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_current_timestamp sets the collection timestamp to the current time.  The timezone difference from UTC in minutes is set to <i>timezone</i>.   If no timezone is desired, <i>timezone</i> should be CBF_NOTIMEZONE.  If no timezone is used, the timest
amp will be UTC.  The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
The new timestamp will have a precision of 1 second.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused. &nbsp;&nbsp;Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>timezone</i><TD>&nbsp;&nbsp;Timezone difference from UTC in minutes or CBF_NOTIMEZONE.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.25">2.4.25 cbf_get_image_size</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_image_size (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, unsigned int <i>element_number</i>,
size_t *<i>ndim1</i>, size_t *<i>ndim2</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_image_size sets *<i>ndim1</i> and  *<i>ndim2</i> to the slow and fast dimensions of the image array for element number <i>element_number</i>.   If the array is 1-dimensional, *<i>ndim1</i> will be set to the array size and *<i>ndim2</i> will be se
t to 1.
<p>
Either of the destination pointers may be NULL.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>ndim1</i><TD>&nbsp;&nbsp;Pointer to the destination slow dimension.
<TR><TD>&nbsp;&nbsp;<i>ndim2</i><TD>&nbsp;&nbsp;Pointer to the destination fast dimension.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.26">2.4.26 cbf_get_image, cbf_get_real_image</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_image (cbf_handle <i>handle</i>, unsigned int  <i>reserved</i>, 
unsigned int <i>element_number</i>, void *<i>array</i>,
size_t <i>elsize</i>, int <i>elsign</i>, size_t <i>ndim1</i>, size_t <i>ndim2</i>);<br />
int cbf_get_real_image (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>,
unsigned int <i>element_number</i>, void *<i>array</i>,
size_t <i>elsize</i>, size_t <i>ndim1</i>, size_t <i>ndim2</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_image reads the image array for element number <i>element_number</i> into an <i>array</i>.
The array consists of <i>ndim1</i>&#215;<i>ndim2</i> elements of <i>elsize</i> bytes each, starting at <i>array</i>.
The elements are signed if <i>elsign</i> is non-0 and unsigned otherwise.  cbf_get_real image
reads the image array of IEEE doubles or floats for element number <i>element_number</i> 
into an <i>array</i>.  A real array is always signed.
<p>
If the array is 1-dimensional, <i>ndim1</i> should be the array size and <i>ndim2</i> 
should be set to 1.
<p>
If any element in the binary data cant fit into the destination element, the 
destination is set the nearest possible value.
<p>
If the value is not binary, the function returns CBF_ASCII.
<p>
If the requested number of elements cant be read, the function will read as many as it 
can and then return CBF_ENDOFDATA.
<p>
Currently, the destination <i>array</i> must consist of chars, shorts or ints (signed or unsigned)
for cbf_get_image, or IEEE doubles or floats for cbf_get_real_image. 
If <i>elsize</i> is not equal to sizeof (char), sizeof (short), sizeof (int), sizeof(double)
or sizeof(float), the function  returns CBF_ARGUMENT.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>array</i><TD>&nbsp;&nbsp;Pointer to the destination array.
<TR><TD>&nbsp;&nbsp;<i>elsize</i><TD>&nbsp;&nbsp;Size in bytes of each destination array element.
<TR><TD>&nbsp;&nbsp;<i>elsigned</i><TD>&nbsp;&nbsp;Set to non-0 if the destination array elements are signed.
<TR><TD>&nbsp;&nbsp;<i>ndim1</i><TD>&nbsp;&nbsp;Slow array dimension.
<TR><TD>&nbsp;&nbsp;<i>ndim2</i><TD>&nbsp;&nbsp;Fast array dimension.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.27">2.4.27 cbf_set_image, cbf_set_real_image</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_image (cbf_handle <i>handle</i>, unsigned int  <i>reserved</i>, 
unsigned int <i>element_number</i>,
unsigned int compression, void *<i>array</i>, size_t <i>elsize</i>, 
int <i>elsign</i>, size_t <i>ndim1</i>, size_t <i>ndim2</i>);<br />
int cbf_set_real_image (cbf_handle <i>handle</i>, unsigned int  <i>reserved</i>, 
unsigned int <i>element_number</i>,
unsigned int compression, void *<i>array</i>,size_t <i>elsize</i>,
size_t <i>ndim1</i>, size_t <i>ndim2</i>);

<p>
<b>DESCRIPTION</b>
<p>
cbf_set_image writes the image array for element number <i>element_number</i>.  The <i>array</i> 
consists of <i>ndim1</i>&#215;<i>ndim2</i> elements of <i>elsize</i> bytes each, starting 
at <i>array</i>.  The elements are signed if <i>elsign</i> is non-0
and unsigned otherwise.  cbf_set_real_image  writes the image array for element number 
<i>element_number</i>.  The <i>array</i> 
consists of <i>ndim1</i>&#215;<i>ndim2</i> IEEE double or float elements of <i>elsize</i> 
bytes each, starting at <i>array</i>. 
<p>
If the array is 1-dimensional, <i>ndim1</i> should be the array size and <i>ndim2</i> should be set to 1.
<p>
The array will be compressed using the compression scheme specifed by compression.  Currently, 
the available schemes are:
<p>
<table>
<tr><td>CBF_CANONICAL<TD>Canonical-code compression (section 3.3.1)
<tr><td>CBF_PACKED<TD>CCP4-style packing (section 3.3.2)
<tr><td>CBF_NONE<TD>No compression.
</table>
<p>
The values compressed are limited to 64 bits. If any element in the array is larger than 64 bits, the 
value compressed is the nearest 64-bit value.
<p>
Currently, the source <i>array</i> must consist of chars, shorts or ints (signed or unsigned)for 
cbf_set_image, or IEEE doubles or floats for cbf_set_real_image. 
If <i>elsize</i> is not equal to sizeof (short), sizeof (int), sizeof(double)
or sizeof(float), the function returns CBF_ARGUMENT.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>compression</i><TD>&nbsp;&nbsp;Compression type.
<TR><TD>&nbsp;&nbsp;<i>array</i><TD>&nbsp;&nbsp;Pointer to the image array.
<TR><TD>&nbsp;&nbsp;<i>elsize</i><TD>&nbsp;&nbsp;Size in bytes of each image array element.
<TR><TD>&nbsp;&nbsp;<i>elsigned</i><TD>&nbsp;&nbsp;Set to non-0 if the image array elements are signed.
<TR><TD>&nbsp;&nbsp;<i>ndim1</i><TD>&nbsp;&nbsp;Slow array dimension.
<TR><TD>&nbsp;&nbsp;<i>ndim2</i><TD>&nbsp;&nbsp;Fast array dimension.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.28">2.4.28 cbf_get_axis_setting
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_axis_setting (cbf_handle <i>handle</i>, unsigned int <i>reserved</i>, const char *<i>axis_id</i>, double *<i>start</i>,
double *<i>increment</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_axis_setting sets *<i>start</i> and *<i>increment</i> to the corresponding values of the axis <i>axis_id</i>.
<p>
Either of the destination pointers may be NULL.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>axis_id</i><TD>&nbsp;&nbsp;Axis id.
<TR><TD>&nbsp;&nbsp;<i>start</i><TD>&nbsp;&nbsp;Pointer to the destination start value.
<TR><TD>&nbsp;&nbsp;<i>increment</i><TD>&nbsp;&nbsp;Pointer to the destination increment value.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.29">2.4.29 cbf_set_axis_setting
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_axis_setting (cbf_handle <i>handle</i>, unsigned int  <i>reserved</i>, const char *<i>axis_id</i>, double <i>start</i>,
double <i>increment</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_axis_setting sets the starting and increment values of the axis <i>axis_id</i> to <i>start</i> and <i>increment</i>.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>axis_id</i><TD>&nbsp;&nbsp;Axis id.
<TR><TD>&nbsp;&nbsp;<i>start</i><TD>&nbsp;&nbsp;Start value.
<TR><TD>&nbsp;&nbsp;<i>increment</i><TD>&nbsp;&nbsp;Increment value.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.30">2.4.30 cbf_construct_goniometer
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_construct_goniometer (cbf_handle <i>handle</i>, cbf_goniometer *<i>goniometer</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_construct_goniometer constructs a goniometer object using the description in the CBF object handle and initialises the goniometer handle *<i>goniometer</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>goniometer</i><TD>&nbsp;&nbsp;Pointer to the destination goniometer handle.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.31">2.4.31 cbf_free_goniometer</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_free_goniometer (cbf_goniometer <i>goniometer</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_free_goniometer destroys the goniometer object specified by <i>goniometer</i> and frees all associated memory.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>goniometer</i><TD>&nbsp;&nbsp;Goniometer handle to free.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.32">2.4.32 cbf_get_rotation_axis
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_rotation_axis (cbf_goniometer <i>goniometer</i>, unsigned int <i>reserved</i>, double *<i>vector1</i>,
double *<i>vector2</i>, double <i>vector3</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_rotation_axis sets *<i>vector1</i>, *<i>vector2</i>, and *<i>vector3</i> to the 3 components of the goniometer rotation axis used for the exposure.
<p>
Any of the destination pointers may be NULL.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>goniometer</i><TD>&nbsp;&nbsp;Goniometer handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>vector1</i><TD>&nbsp;&nbsp;Pointer to the destination x component of the rotation axis.
<TR><TD>&nbsp;&nbsp;<i>vector2</i><TD>&nbsp;&nbsp;Pointer to the destination y component of the rotation axis.
<TR><TD>&nbsp;&nbsp;<i>vector3</i><TD>&nbsp;&nbsp;Pointer to the destination z component of the rotation axis.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.33">2.4.33 cbf_get_rotation_range
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_rotation_range (cbf_goniometer <i>goniometer</i>, unsigned int  <i>reserved</i>, double *<i>start</i>,
double *<i>increment</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_rotation_range sets *<i>start</i> and *<i>increment</i> to the corresponding values of the goniometer rotation axis used for the exposure.
<p>
Either of the destination pointers may be NULL.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>goniometer</i><TD>&nbsp;&nbsp;Goniometer handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>start</i><TD>&nbsp;&nbsp;Pointer to the destination start value.
<TR><TD>&nbsp;&nbsp;<i>increment</i><TD>&nbsp;&nbsp;Pointer to the destination increment value.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.34">2.4.34 cbf_rotate_vector
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_rotate_vector (cbf_goniometer <i>goniometer</i>, unsigned int  <i>reserved</i>, double <i>ratio</i>, double <i>initial1</i>,
double <i>initial2</i>, double <i>initial3</i>, double *<i>final1</i>, double *<i>final2</i>, double *<i>final3</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_rotate_vector sets *<i>final1</i>, *<i>final2</i>, and *<i>final3</i> to the 3 components of the of the vector (<i>initial1</i>, <i>initial2</i>, <i>initial3</i>) after reorientation by applying the goniometer rotations.  The value <i>ratio</i> specif
ies the goniometer setting and varies from 0.0 at the beginning of the exposure to 1.0 at the end, irrespective of the actual rotation range.
<p>
Any of the destination pointers may be NULL.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>goniometer</i><TD>&nbsp;&nbsp;Goniometer handle.
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.
<TR><TD>&nbsp;&nbsp;<i>ratio</i><TD>&nbsp;&nbsp;Goniometer setting.  0 = beginning of exposure, 1 = end.
<TR><TD>&nbsp;&nbsp;<i>initial1</i><TD>&nbsp;&nbsp;x component of the initial vector.
<TR><TD>&nbsp;&nbsp;<i>initial2</i><TD>&nbsp;&nbsp;y component of the initial vector.
<TR><TD>&nbsp;&nbsp;<i>initial3</i><TD>&nbsp;&nbsp;z component of the initial vector.
<TR><TD>&nbsp;&nbsp;<i>vector1</i><TD>&nbsp;&nbsp;Pointer to the destination x component of the final vector.
<TR><TD>&nbsp;&nbsp;<i>vector2</i><TD>&nbsp;&nbsp;Pointer to the destination y component of the final vector.
<TR><TD>&nbsp;&nbsp;<i>vector3</i><TD>&nbsp;&nbsp;Pointer to the destination z component of the final vector.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.35">2.4.35 cbf_get_reciprocal
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_reciprocal (cbf_goniometer <i>goniometer</i>, unsigned int  <i>reserved</i>, double <i>ratio</i>,
double <i>wavelength</i>, double <i>real1</i>, double <i>real2</i>, double <i>real3</i>, double *<i>reciprocal1</i>,
double *<i>reciprocal2</i>, double *<i>reciprocal3</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_reciprocal sets *<i>reciprocal1</i>, * <i>reciprocal2</i>, and * <i>reciprocal3</i> to the 3 components of the of the reciprocal-space vector corresponding to the real-space vector (<i>real1</i>, <i>real2</i>, <i>real3</i>).  The reciprocal-space
vector is oriented to correspond to the goniometer setting with all axes at 0.  The value <i>wavelength</i> is the wavlength in &Aring; and the value <i>ratio</i> specifies the current goniometer setting and varies from 0.0 at the beginning of the exposur
e to 1.0 at the end, irrespective of the actual rotation range.
<p>
Any of the destination pointers may be NULL.
<p>
The parameter <i>reserved</i> is presently unused and should be set to 0.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>goniometer</i><TD>&nbsp;&nbsp;Goniometer handle.<br />
<TR><TD>&nbsp;&nbsp;<i>reserved</i><TD>&nbsp;&nbsp;Unused.  Any value other than 0 is invalid.<br />
<TR><TD>&nbsp;&nbsp;<i>ratio</i><TD>&nbsp;&nbsp;Goniometer setting.  0 = beginning of exposure, 1 = end.<br />
<TR><TD>&nbsp;&nbsp;<i>wavelength</i><TD>&nbsp;&nbsp;Wavelength in &Aring;.
<TR><TD>&nbsp;&nbsp;<i>real1</i><TD>&nbsp;&nbsp;x component of the real-space vector.
<TR><TD>&nbsp;&nbsp;<i>real2</i><TD>&nbsp;&nbsp;y component of the real-space vector.
<TR><TD>&nbsp;&nbsp;<i>real3</i><TD>&nbsp;&nbsp;z component of the real-space vector.
<TR><TD>&nbsp;&nbsp;<i>reciprocal1</i><TD>&nbsp;&nbsp;Pointer to the destination x component of the reciprocal-space vector.
<TR><TD>&nbsp;&nbsp;<i>reciprocal2</i><TD>&nbsp;&nbsp;Pointer to the destination y component of the reciprocal-space vector.
<TR><TD>&nbsp;&nbsp;<i>reciprocal3</i><TD>&nbsp;&nbsp;Pointer to the destination z component of the reciprocal-space vector.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.36">2.4.36 cbf_construct_detector
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_construct_detector (cbf_handle <i>handle</i>, cbf_detector *<i>detector</i>, unsigned int <i>element_number</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_construct_detector constructs a detector object for detector element number <i>element_number</i> using the description in the CBF object handle and initialises the detector handle *<i>detector</i>.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Pointer to the destination detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.37">2.4.37 cbf_free_detector</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_free_detector (cbf_detector <i>detector</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_free_detector destroys the detector object specified by <i>detector</i> and frees all associated memory.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle to free.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>

<h4><A NAME="2.4.38">2.4.38 cbf_get_beam_center, cbf_set_beam_center
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_beam_center (cbf_detector <i>detector</i>, double *<i>index1</i>, double *<i>index2</i>, double *<i>center1</i>,
double *<i>center2</i>);
<p>
int cbf_set_beam_center (cbf_detector <i>detector</i>, double *<i>index1</i>, double *<i>index2</i>, double *<i>center1</i>,
double *<i>center2</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_beam_center sets *<i>center1</i> and *<i>center2</i> to the displacements in mm
along the detector axes from pixel (0, 0) to the point at which the beam intersects the
detector and *<i>index1</i> and *<i>index2</i> to the corresponding indices.
cbf_set_beam_center sets the offsets in the axis category for the detector element
axis with precedence 1 to place the beam center at the position given in mm by *<i>center1</i>
and *<i>center2</i> as the displacements in mm along the detector axes from pixel (0, 0)
to the point at which the beam intersects the detector at the indices given  *<i>index1</i> and
*<i>index2</i>.
<p>
Any of the destination pointers may be NULL for getting the beam center.  For setting the beam
axis, either the indices of the center must not be NULL.
<p>
The indices are non-negative for beam centers within the detector surface, but the center for an axis with
a negative increment will be negative for a beam center within the detector surface.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>index1</i><TD>&nbsp;&nbsp;Pointer to the destination slow index.<br />
<TR><TD>&nbsp;&nbsp;<i>index2</i><TD>&nbsp;&nbsp;Pointer to the destination fast index.<br />
<TR><TD>&nbsp;&nbsp;<i>center1</i><TD>&nbsp;&nbsp;Pointer to the destination displacement along the slow axis.<br />
<TR><TD>&nbsp;&nbsp;<i>center2</i><TD>&nbsp;&nbsp;Pointer to the destination displacement along the fast axis.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.39">2.4.39 cbf_get_detector_distance</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_detector_distance (cbf_detector <i>detector</i>, double *<i>distance</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_detector_distance sets *<i>distance</i> to the nearest distance from the sample position to the detector plane.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>distance</i><TD>&nbsp;&nbsp;Pointer to the destination distance.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.40">2.4.40 cbf_get_detector_normal</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_detector_normal (cbf_detector <i>detector</i>, double *<i>normal1</i>, double *<i>normal2</i>,
double *<i>normal3</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_detector_normal sets *<i>normal1</i>, *<i>normal2</i>, and *<i>normal3</i> to the 3 components of the of the normal vector to the detector plane.  The vector is normalized.
<p>
Any of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>normal1</i><TD>&nbsp;&nbsp;Pointer to the destination x component of the normal vector.<br />
<TR><TD>&nbsp;&nbsp;<i>normal2</i><TD>&nbsp;&nbsp;Pointer to the destination y component of the normal vector.<br />
<TR><TD>&nbsp;&nbsp;<i>normal3</i><TD>&nbsp;&nbsp;Pointer to the destination z component of the normal vector.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.41">2.4.41 cbf_get_pixel_coordinates
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_pixel_coordinates (cbf_detector <I>detector</I>, double <i>index1</i>, double <i>index2</i>, double *<i>coordinate1</i>,
	double *<i>coordinate2</i>, double *<i>coordinate3</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_pixel_coordinates sets *<i>coordinate1</i>, *<i>coordinate2</i>, and *<i>coordinate3</i> to the vector position of pixel (<i>index1</i>, <i>index2</i>) on the detector surface.  If <i>index1</i> and <i>index2</i> are integers then the coordinates
correspond to the center of a pixel.
<p>
Any of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>index1</i><TD>&nbsp;&nbsp;Slow index.<br />
<TR><TD>&nbsp;&nbsp;<i>index2</i><TD>&nbsp;&nbsp;Fast index.<br />
<TR><TD>&nbsp;&nbsp;<i>coordinate1</i><TD>&nbsp;&nbsp;Pointer to the destination x component.<br />
<TR><TD>&nbsp;&nbsp;<i>oordinate2</i><TD>&nbsp;&nbsp;Pointer to the destination y component.<br />
<TR><TD>&nbsp;&nbsp;<i>coordinate3</i><TD>&nbsp;&nbsp;Pointer to the destination z component.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.42">2.4.42 cbf_get_pixel_normal
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_pixel_normal (cbf_detector <I>detector</I>, double <i>index1</i>, double <i>index2</i>,  double *<i>normal1</i>,
double *<i>normal2</i>, double *<i>normal3</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_detector_normal sets *<i>normal1</i>, *<i>normal2</i>, and *<i>normal3</i> to the 3 components of the of the normal vector to the pixel at (<i>index1</i>, <i>index2</i>).  The vector is normalized.
<p>
Any of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>index1</i><TD>&nbsp;&nbsp;Slow index.<br />
<TR><TD>&nbsp;&nbsp;<i>index2</i><TD>&nbsp;&nbsp;Fast index.<br />
<TR><TD>&nbsp;&nbsp;<i>normal1</i><TD>&nbsp;&nbsp;Pointer to the destination x component of the normal vector.<br />
<TR><TD>&nbsp;&nbsp;<i>normal2</i><TD>&nbsp;&nbsp;Pointer to the destination y component of the normal vector.<br />
<TR><TD>&nbsp;&nbsp;<i>normal3</i><TD>&nbsp;&nbsp;Pointer to the destination z component of the normal vector.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>
<h4><A NAME="2.4.43">2.4.43 cbf_get_pixel_area
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_pixel_area (cbf_detector <i>detector</i>, double <i>index1</i>, double <i>index2</i>, double *<I>area</I>,
double *<i>projected_area</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_pixel_area sets *<I>area</I> to the area of the pixel at (<i>index1</i>, <i>index2</i>) on the detector surface and *<i>projected_area</i> to the apparent area of the pixel as viewed from the sample position.
<p>
Either of the destination pointers may be NULL.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>index1</i><TD>&nbsp;&nbsp;Slow index.<br />
<TR><TD>&nbsp;&nbsp;<i>index2</i><TD>&nbsp;&nbsp;Fast index.<br />
<TR><TD>&nbsp;&nbsp;<i>area</i><TD>&nbsp;&nbsp;Pointer to the destination area in mm2.<br />
<TR><TD>&nbsp;&nbsp;<i>projected_area</i><TD>&nbsp;&nbsp;Pointer to the destination apparent area in mm2.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>

<h4><A NAME="2.4.44">2.4.44 cbf_get_pixel_size</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_pixel_size (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>,
unsigned int <i>axis_number</i>, double *<i>psize</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_pixel_size sets *<i>psize</i> to point to the double value in millimeters of the
axis <i>axis_number</i> of the detector element <i>element_number</i>.  The <i>axis_number</i>
is numbered from 1, starting with the fastest axis.
<p>
If the pixel size is not given explcitly in the &quot;array_element_size&quot; category,
the function returns CBF_NOTFOUND.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>axis_number</i><TD>&nbsp;&nbsp;The number of the axis, fastest first, starting from 1.
<TR><TD>&nbsp;&nbsp;<i>psize</i><TD>&nbsp;&nbsp;Pointer to the destination pixel size.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>


<h4><A NAME="2.4.45">2.4.45 cbf_set_pixel_size</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_pixel_size (cbf_handle <i>handle</i>, unsigned int <i>element_number</i>,
unsigned int <i>axis_number</i>, double <i>psize</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_pixel_size sets the item in the &quote;size&quote; column of the  &quot;array_structure_list&quot;
category at the row which matches axis <i>axis_number</i> of the detector element <i>element_number</i>
converting the double pixel size <i>psize</i> from meters to millimeters in storing it in the &quot;size&quot;
column for the
axis <i>axis_number</i> of the detector element <i>element_number</i>.  The <i>axis_number</i>
is numbered from 1, starting with the fastest axis.
<p>
If the &quot;array_structure_list&quot; category does not already exist, it is created.
<p>
If the appropriate row in the &quot;array_structure_list&quot; catgeory does not already exist, it is created.
<p>
If the pixel size is not given explcitly in the &quot;array_element_size category&quot;, the function returns CBF_NOTFOUND.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>axis_number</i><TD>&nbsp;&nbsp;The number of the axis, fastest first, starting from 1.
<TR><TD>&nbsp;&nbsp;<i>psize</i><TD>&nbsp;&nbsp;The pixel size in millimeters.
</TABLE>
<p>
<b>RETURN VALUE</b>

<p>Returns an error code on failure or 0 for success.
<p><hr><P>

<h4><A NAME="2.4.46">2.4.46 cbf_get_inferred_pixel_size
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_inferred_pixel_size (cbf_detector <i>detector</i>,
unsigned int <i>axis_number</i>,
double *<i>psize</i>);
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_inferred_pixel_size sets *<i>psize</i> to point to the double value in millimeters of the
pixel size for the axis <i>axis_number</i> value for pixel at (<i>index1</i>, <i>index2</i>)
on the detector surface.  The slow index is treated as axis 1 and the fast index is treated
as axis 2.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>detector</i><TD>&nbsp;&nbsp;Detector handle.<br />
<TR><TD>&nbsp;&nbsp;<i>axis_number</i><TD>&nbsp;&nbsp;The number of the axis.
<TR><TD>&nbsp;&nbsp;<i>area</i><TD>&nbsp;&nbsp;Pointer to the destination pizel size in mm.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>

<h4><A NAME="2.4.47">2.4.47 cbf_get_unit_cell
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_unit_cell (cbf_handle <i>handle</i>,
    double <i>cell</i>[6], double <i>cell_esd</i>[6] );
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_unit_cell sets <i>cell</i>[0:2] to the double values of the cell edge
lengths a, b and c in &Aring;ngstroms, <i>cell</i>[3:5] to the double values
of the cell angles &alpha;, &beta; and &gamma; in degrees,  <i>cell_esd</i>[0:2] to the double values of
the estimated strandard deviations of the cell edge lengths a, b and c in
&Aring;ngstroms, <i>cell_esd</i>[3:5] to the double values of the estimated
standard deviations of the the cell angles &alpha;, &beta; and &gamma; in degrees.
<p>The values returned are retrieved from the first row of the &quot;cell&quot;
category.  The value of "_cell.entry_id" is ignored.
<p><i>cell</i> or  <i>cell_esd</i> may be NULL.
<p>
If <i>cell</i> is NULL, the cell parameters are not retrieved.
<p>
If <i>cell_esd</i> is NULL, the cell parameter esds are not retrieved.
<p>
If the &quot;cell&quot; category is present, but some of the values
are missing, zeros are returned for the missing values.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>cell</i><TD>&nbsp;&nbsp;Pointer to the destination array
of 6 doubles for the cell parameters.
<TR><TD>&nbsp;&nbsp;<i>cell_esd</i><TD>&nbsp;&nbsp;Pointer to the destination
array of 6 doubles for the cell parameter esds.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.  No errors is returned for
missing values if the &quot;cell&quot; category exists.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.4.48">2.4.48 cbf_set_unit_cell<br />
<A HREF="#2.4.49">2.4.49 cbf_get_reciprocal_cell<br />
<A HREF="#2.4.50">2.4.50 cbf_set_reciprocal_cell<br />
<A HREF="#2.4.51">2.4.51 cbf_compute_cell_volume<br />
<A HREF="#2.4.52">2.4.52 cbf_compute_reciprocal_cell<br />
<p><hr><P>
<h4><A NAME="2.4.48">2.4.48 cbf_set_unit_cell
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_unit_cell (cbf_handle <i>handle</i>,
    double <i>cell</i>[6], double <i>cell_esd</i>[6] );
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_unit_cell sets the cell parameters to the double values given in <i>cell</i>[0:2]
 for the cell edge
lengths a, b and c in &Aring;ngstroms, the double values given in <i>cell</i>[3:5]
for the cell angles &alpha;, &beta; and &gamma; in degrees, the double values given in <i>cell_esd</i>[0:2] for
the estimated strandard deviations of the cell edge lengths a, b and c in
&Aring;ngstroms, and the double values given in <i>cell_esd</i>[3:5] for the estimated
standard deviations of the the cell angles &alpha;, &beta; and &gamma; in degrees.
<p>The values are placed in the first row of the &quot;cell&quot;
category.  If no value has been given for "_cell.entry_id", it is set to
the value of the &quot;diffrn.id&quot; entry of the current data block.
<p><i>cell</i> or  <i>cell_esd</i> may be NULL.
<p>
If <i>cell</i> is NULL, the cell parameters are not set.
<p>
If <i>cell_esd</i> is NULL, the cell parameter esds are not set.
<p>
If the &quot;cell&quot; category is not present, it is created.
If any of the necessary columns are not present, they are created.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>cell</i><TD>&nbsp;&nbsp;Pointer to the array
of 6 doubles for the cell parameters.
<TR><TD>&nbsp;&nbsp;<i>cell_esd</i><TD>&nbsp;&nbsp;Pointer to the
array of 6 doubles for the cell parameter esds.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.4.47">2.4.47 cbf_get_unit_cell<br />
<A HREF="#2.4.49">2.4.49 cbf_get_reciprocal_cell<br />
<A HREF="#2.4.50">2.4.50 cbf_set_reciprocal_cell<br />
<A HREF="#2.4.51">2.4.51 cbf_compute_cell_volume<br />
<A HREF="#2.4.52">2.4.52 cbf_compute_reciprocal_cell<br />
<p><hr><P>
<b>SEE ALSO</b>
<h4><A NAME="2.4.49">2.4.49 cbf_get_reciprocal_cell
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_reciprocal_cell (cbf_handle <i>handle</i>,
    double <i>cell</i>[6], double <i>cell_esd</i>[6] );
<p>
<b>DESCRIPTION</b>
<p>
cbf_get_reciprocal_cell sets <i>cell</i>[0:2] to the double values of the
reciprocal cell edge
lengths a<sup>*</sup>, b<sup>*</sup> and c<sup>*</sup> in &Aring;ngstroms<sup>-1</sup>, <i>cell</i>[3:5] to the double values
of the reciprocal cell angles &alpha;<sup>*</sup>, &beta;<sup>*</sup> and &gamma;<sup>*</sup> in degrees,  <i>cell_esd</i>[0:2] to the double values of
the estimated strandard deviations of the reciprocal cell edge lengths a<sup>*</sup>,
 b<sup>*</sup> and c<sup>*</sup> in
&Aring;ngstroms<sup>-1</sup>, <i>cell_esd</i>[3:5] to the double values of the estimated
standard deviations of the the reciprocal cell angles &alpha;<sup>*</sup>, &beta;<sup>*</sup> and &gamma;<sup>*</sup> in degrees.
<p>The values returned are retrieved from the first row of the &quot;cell&quot;
category.  The value of "_cell.entry_id" is ignored.
<p><i>cell</i> or  <i>cell_esd</i> may be NULL.
<p>
If <i>cell</i> is NULL, the reciprocal cell parameters are not retrieved.
<p>
If <i>cell_esd</i> is NULL, the reciprocal cell parameter esds are not retrieved.
<p>
If the &quot;cell&quot; category is present, but some of the values
are missing, zeros are returned for the missing values.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>cell</i><TD>&nbsp;&nbsp;Pointer to the destination array
of 6 doubles for the reciprocal cell parameters.
<TR><TD>&nbsp;&nbsp;<i>cell_esd</i><TD>&nbsp;&nbsp;Pointer to the destination
array of 6 doubles for the reciprocal cell parameter esds.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.  No errors is returned for
missing values if the &quot;cell&quot; category exists.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.4.47">2.4.47 cbf_get_unit_cell<br />
<A HREF="#2.4.48">2.4.48 cbf_set_unit_cell<br />
<A HREF="#2.4.50">2.4.50 cbf_set_reciprocal_cell<br />
<A HREF="#2.4.51">2.4.51 cbf_compute_cell_volume<br />
<A HREF="#2.4.52">2.4.52 cbf_compute_reciprocal_cell<br />
<p><hr><P>
<h4><A NAME="2.4.50">2.4.50 cbf_set_reciprocal_cell
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_set_reciprocal_cell (cbf_handle <i>handle</i>,
    double <i>cell</i>[6], double <i>cell_esd</i>[6] );
<p>
<b>DESCRIPTION</b>
<p>
cbf_set_reciprocal_cell sets the reciprocal cell parameters to the
double values given in <i>cell</i>[0:2] for the reciprocal cell edge
lengths a<sup>*</sup>, b<sup>*</sup> and c<sup>*</sup>
in &Aring;ngstroms<sup>-1</sup>, the double values given in <i>cell</i>[3:5]
for the reciprocal cell angles
&alpha;<sup>*</sup>, &beta;<sup>*</sup> and &gamma;<sup>*</sup>
in degrees, the double values given in <i>cell_esd</i>[0:2] for
the estimated strandard deviations of the reciprocal cell edge lengths
 a<sup>*</sup>, b<sup>*</sup> and c<sup>*</sup> in
&Aring;ngstroms, and the double values given in <i>cell_esd</i>[3:5] for the estimated
standard deviations of the reciprocal cell angles
 &alpha;<sup>*</sup>, &beta;<sup>*</sup> and &gamma;<sup>*</sup>
in degrees.
<p>The values are placed in the first row of the &quot;cell&quot;
category.  If no value has been given for "_cell.entry_id", it is set to
the value of the &quot;diffrn.id&quot; entry of the current data block.
<p><i>cell</i> or  <i>cell_esd</i> may be NULL.
<p>
If <i>cell</i> is NULL, the reciprocal cell parameters are not set.
<p>
If <i>cell_esd</i> is NULL, the reciprocal cell parameter esds are not set.
<p>
If the &quot;cell&quot; category is not present, it is created.
If any of the necessary columns are not present, they are created.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.<br />
<TR><TD>&nbsp;&nbsp;<i>cell</i><TD>&nbsp;&nbsp;Pointer to the array
of 6 doubles for the reciprocal cell parameters.
<TR><TD>&nbsp;&nbsp;<i>cell_esd</i><TD>&nbsp;&nbsp;Pointer to the
array of 6 doubles for the reciprocal cell parameter esds.<br />
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.4.47">2.4.47 cbf_get_unit_cell<br />
<A HREF="#2.4.48">2.4.48 cbf_set_unit_cell<br />
<A HREF="#2.4.50">2.4.50 cbf_get_reciprocal_cell<br />
<A HREF="#2.4.51">2.4.51 cbf_compute_cell_volume<br />
<A HREF="#2.4.52">2.4.52 cbf_compute_reciprocal_cell<br />
<p><hr><P>

<h4><A NAME="2.4.51">2.4.51 cbf_compute_cell_volume
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_compute_cell_volume ( double <i>cell</i>[6], double *<i>volume</i> );

<p>
<b>DESCRIPTION</b>
<p>
cbf_compute_cell_volume sets *<i>volume</i> to point to the volume of the unit cell
computed from the double values in <i>cell</i>[0:2]
for the cell edge lengths a, b and c in &Aring;ngstroms and
 the double values given in <i>cell</i>[3:5]
for the cell angles &alpha;, &beta; and &gamma; in degrees.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>cell</i><TD>&nbsp;&nbsp;Pointer to the array
of 6 doubles giving the cell parameters.
<TR><TD>&nbsp;&nbsp;<i>volume</i><TD>&nbsp;&nbsp;Pointer to the
doubles for cell volume.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.4.47">2.4.46 cbf_get_unit_cell<br />
<A HREF="#2.4.48">2.4.47 cbf_set_unit_cell<br />
<A HREF="#2.4.49">2.4.50 cbf_get_reciprocal_cell<br />
<A HREF="#2.4.50">2.4.50 cbf_set_reciprocal_cell<br />
<A HREF="#2.4.52">2.4.52 cbf_compute_reciprocal_cell<br />
<p><hr><P>


<h4><A NAME="2.4.52">2.4.52 cbf_compute_reciprocal_cell
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_compute_reciprocal_cell ( double <i>cell</i>[6], double <i>rcell</i>[6] );


<p>
<b>DESCRIPTION</b>
<p>
cbf_compute_reciprocal_cell sets <i>rcell</i> to  point to the array of reciprocal cell
parameters computed from the double values <i>cell</i>[0:2] giving the cell edge
lengths a, b and c in &Aring;ngstroms, and the double values <i>cell</i>[3:5]
giving the cell angles &alpha;, &beta; and &gamma; in degrees.  The double values
<i>rcell</i>[0:2] will be set to the reciprocal cell
lengths a<sup>*</sup>, b<sup>*</sup> and c<sup>*</sup> in &Aring;ngstroms<sup>-1</sup>
and the double values <i>rcell</i>[3:5] will be set to the reciprocal cell
angles &alpha;<sup>*</sup>, &beta;<sup>*</sup> and &gamma;<sup>*</sup> in degrees.
<p>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>cell</i><TD>&nbsp;&nbsp;Pointer to the array
of 6 doubles giving the cell parameters.
<TR><TD>&nbsp;&nbsp;<i>rcell</i><TD>&nbsp;&nbsp;Pointer to the destination array
of 6 doubles giving the reciprocal cell parameters.
<TR><TD>&nbsp;&nbsp;<i>volume</i><TD>&nbsp;&nbsp;Pointer to the
doubles for cell volume.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p>
<b>SEE ALSO</b>
<p>
<A HREF="#2.4.47">2.4.46 cbf_get_unit_cell<br />
<A HREF="#2.4.48">2.4.47 cbf_set_unit_cell<br />
<A HREF="#2.4.49">2.4.50 cbf_get_reciprocal_cell<br />
<A HREF="#2.4.50">2.4.50 cbf_set_reciprocal_cell<br />
<A HREF="#2.4.51">2.4.51 cbf_compute_cell_volume<br />
<p><hr><P>



<h4><A NAME="2.4.53">2.4.53 cbf_get_orientation_matrix, cbf_set_orientation_matrix
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_orientation_matrix (cbf_handle <i>handle</i>, double <i>ub_matrix</i>[9]); <br />
int cbf_set_orientation_matrix (cbf_handle <i>handle</i>, double <i>ub_matrix</i>[9]);
<p>
cbf_get_orientation_matrix sets <i>ub_matrix</i> to point to the array of
orientation matrix entries in the &quot;diffrn&quot; category in the order
of columns:<P>
<center>
&quot;UB[1][1]&quot; &quot;UB[1][2]&quot; &quot;UB[1][3]&quot;<br />
&quot;UB[2][1]&quot; &quot;UB[2][2]&quot; &quot;UB[2][3]&quot;<br />
&quot;UB[3][1]&quot; &quot;UB[3][2]&quot; &quot;UB[3][3]&quot;
</center>  
<P>
cbf_set_orientation_matrix sets the values in the &quot;diffrn&quot; category
to the values pointed to by <i>ub_matrix</i>.
<P>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>ubmatric</i><TD>&nbsp;&nbsp;Source or destination array
of 9 doubles giving the orientation matrix parameters.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>




<h4><A NAME="2.4.54">2.4.54 cbf_get_bin_sizes, cbf_set_bin_sizes
</A></h4>
<p><b>PROTOTYPE</b>
<p>#include "cbf_simple.h"
<p>
int cbf_get_bin_sizes(cbf_handle <i>handle</i>, unsigned int <i>element_number</i>, double * <i>slowbinsize</i>,
 double * <i>fastbinsize</i>); <br />
int cbf_set_bin_sizes(cbf_handle <i>handle</i>, unsigned int element_number, double <i>slowbinsize_in</i>,double <i>fastbinsize_in</i>);
<p>
cbf_get_bin_sizes sets <i>slowbinsize</i> to point to the value of the
number of pixels composing one array element in the dimension that changes at
the second-fastest rate and <i>fastbinsize</i> to point to the value of the
number of pixels composing one array element in the dimension that changes at
the fastest rate for the dectector element with the ordinal <i>element_number</i>.
cbf_set_bin_sizes sets the the pixel bin sizes in the  
&quot;array_intensities&quot; category to the values of 
<i>slowbinsize_in</i> for the
number of pixels composing one array element in the dimension that changes at
the second-fastest rate and <i>fastbinsize_in</i> for the
number of pixels composing one array element in the dimension that changes at
the fastest rate for the dectector element with the ordinal <i>element_number</i>.
<P>
In order to allow for software binning involving fractions of pixels,
the bin sizes are doubles rather than ints.
<P>
<b>ARGUMENTS</b><br />
<TABLE>
<TR><TD>&nbsp;&nbsp;<i>handle</i><TD>&nbsp;&nbsp;CBF handle.
<TR><TD>&nbsp;&nbsp;<i>element_number</i><TD>&nbsp;&nbsp;The number of the detector element counting from 0 by order of appearance in the &quot;diffrn_data_frame&quot; category.
<TR><TD>&nbsp;&nbsp;<i>slowbinsize</i><TD>&nbsp;&nbsp;Pointer to the returned number of pixels composing one array element in the dimension that changes at
the second-fastest rate.
<TR><TD>&nbsp;&nbsp;<i>fastbinsize</i><TD>&nbsp;&nbsp;Pointer to the returned number of pixels composing one array element in the dimension that changes at
the fastest rate.
<TR><TD>&nbsp;&nbsp;<i>slowbinsize_in</i><TD>&nbsp;&nbsp;The number of pixels composing one array element in the dimension that changes at
the second-fastest rate.
<TR><TD>&nbsp;&nbsp;<i>fastbinsize_in</i><TD>&nbsp;&nbsp;The number of pixels composing one array element in the dimension that changes at
the fastest rate.
</TABLE>
<p>
<b>RETURN VALUE</b>
<p>
Returns an error code on failure or 0 for success.
<p><hr><P>



<h3><A NAME="3.">3.  File format</A></h3>


<h4><A NAME="3.1">3.1  General description</A></h4>
<p>
With the exception of the binary sections, a CBF file is an
mmCIF-format ASCII file, so a CBF file with no binary sections is a CIF
file.  An imgCIF file has any binary sections encoded as CIF-format
ASCII strings and is a CIF file whether or not it contains binary
sections. In most cases, CBFlib can also be used to access normal
CIF files as well as CBF and imgCIF files.
<p>
<h4><A NAME="3.2">3.2  Format of the binary sections</A></h4>
<p>
Before getting to the binary data itself, there are some preliminaries
to allow a smooth transition from the conventions of CIF to those of
raw or encoded streams of "octets" (8-bit bytes). The binary data is
given as the essential part of a specially formatted semicolon-delimited
CIF multi-line text string. This text string is the value associated
with the tag "_array_data.data".
<p>
The specific format of the binary sections differs between an
imgCIF and a CBF file.
<h4><A NAME="3.2.1">3.2.1  Format of imgCIF binary sections</A></h4>
<p>

Each binary section is encoded as a ;-delimited string.
 Within the text string, the conventions
developed for transmitting email messages
including binary attachments are followed.  There is
secondary ASCII header information, formatted as
Multipurpose Internet Mail Extensions
(MIME) headers (see RFCs 2045-49 by Freed, et al.).
The boundary marker for the beginning of
all this is the special string
<p>
<PRE>
--CIF-BINARY-FORMAT-SECTION--
</PRE>
<p>
at the beginning of a line.  The initial &quot;--&quot; says that
this is a MIME boundary.  We cannot put
"###" in front of it and conform to MIME conventions.
Immediately after the boundary marker
are MIME headers, describing some useful information we
will need to process the binary
section.  MIME headers can appear in different orders,
and can be very confusing (look at the raw
contents of a email message with attachments),
 but there is only one header which is has to be
understood to process an imgCIF: &quot;Content-Transfer-Encoding&quot;.
If the value given on this
header is &quot;BINARY&quot;, this is a CBF and the
data will be presented as raw binary, containing a
count (in the header described in <A HREF="#3.2.2">
3.2.2  Format of CBF binary sections</A>)
so that we'll know when to
start looking for more information.
<p>
If the value given for &quot;Content-Transfer-Encoding&quot;
is one of the real encodings: &quot;BASE64&quot;,
&quot;QUOTED-PRINTABLE&quot;, &quot;X-BASE8&quot;,
&quot;X-BASE10&quot; or &quot;X-BASE16&quot;, the file is an imgCIF,
and we'll need some other headers to
process the encoded binary data properly.  It is a
good practice to give headers in all cases.  The meanings of
 various encodings is given in the
CBF extensions dictionary, <A HREF="cif_img_1.1.3.html">cif_img_1.1.3.dic</A>.
<p>
The &QUOT;Content-Type&QUOT; header tells us what
sort of data we have (currently always
&QUOT;application/octet-stream&QUOT; for a miscellaneous
stream of binary data) and, optionally, the
conversions that were applied to the original data.
In this case we have compressed the data with
the &quot;CBF-PACKED&quot; algorithm.
<p>
The &quot;X-Binary-ID&quot; header should contain the
same value as was given for &quot;_array_data.binary_id&quot;.
<p>
The &quot;X-Binary-Size&quot; header gives the expected size of the
binary data.
This is the size <b>after</b> any
compressions, but before any ascii encodings.
This is useful in making a simple check for a
missing portion of this file. The 8 bytes for the
Compression type (see below)
are not counted in this field,
so the value of &quot;X-Binary-Size&quot; is 8 less than
the quantity in bytes 12-19 of the raw binary data (<A HREF="#3.2.2">
3.2.2  Format of CBF binary sections</A>).
<p>
The optional &quot;Content-MD5&quot; header provides a much
more sophisticated check on the integrity
of the binary data.  Note that this check value is applied to
the data occurring after the 8 bytes for the Compression type.
<p>
A blank line separator immediately precedes the start of the
encoded binary data.  Blank spaces
may be added prior to the preceding &quot;line separator&quot;
if desired (e.g. to force word or block
alignment).
<p>
Because CBFLIB may jump foreward in the file from the MIME header,
the length of encoded
data cannot be greater than the value defined
by &quot;X-Binary-Size&quot; (except when &quot;X-Binary-Size&quot;
is zero, which means that the size is unknown).
At exactly the byte following the full binary section
as defined by the length value is the end of
binary section identifier. This consists of the
line-termination sequence followed by:
<p>
<PRE>
--CIF-BINARY-FORMAT-SECTION----
;
</PRE>
<p>
with each of these lines followed by a line-termination sequence.
This brings us back into a
normal CIF environment.  This identifier is, in a sense,
redundant because the binary data length
value tells the a program how many bytes to jump over to
the end of the binary data.  This
redundancy has been deliberately added for error checking,
and for possible file recovery in the
case of a corrupted file and this identifier must be
present at the end of every block of binary data.
<p>

<h4><A NAME="3.2.2">3.2.2  Format of CBF binary sections</A></h4>
<p>




<p>
In a CBF file, each binary section is encoded as a ;-delimited string,
starting  with an
arbitrary number of pure-ASCII characters.
<p>
<b>Note:</b> For historical reasons, CIFlib has the option of writing simple
header and footer sections: &quot;START OF BINARY SECTION&quot; at
the start of a binary section and
&quot;END OF BINARY SECTION&quot; at the end of a binary section,
or writing MIME-type header
and footer sections (<A HREF="3.2.1">3.2.1
Format of imgCIF binary sections</A>).
If the simple header is used, the actual ASCII text is ignored when the
binary section is read.  <b>Use of the simple binary header is deprecated.</b>
<p>
The MIME header is
recommended.
<p>
Between the ASCII header and the actual CBF binary data is a series of
bytes (&quot;octets&quot;) to try to stop the listing of the header,
bytes which define the binary identifier which should match the
&quot;binary_id&quot; defined in the header, and bytes which define the
length of the binary section.<p><br />
<Table>
<TR><TH>             Octet   <TH>Hex   <TH>Decimal  <TH>Purpose
<TR><TD>&nbsp;&nbsp;              1     <TD>&nbsp;&nbsp;0C       <TD>&nbsp;&nbsp;12    <TD>&nbsp;&nbsp;(ctrl-L) End of Page
<TR><TD>&nbsp;&nbsp;              2     <TD>&nbsp;&nbsp;1A       <TD>&nbsp;&nbsp;26    <TD>&nbsp;&nbsp;(ctrl-Z) Stop listings in MS-DOS
<TR><TD>&nbsp;&nbsp;              3     <TD>&nbsp;&nbsp;04       <TD>&nbsp;&nbsp;04    <TD>&nbsp;&nbsp;(Ctrl-D) Stop listings in UNIX
<TR><TD>&nbsp;&nbsp;              4     <TD>&nbsp;&nbsp;D5      <TD>&nbsp;&nbsp;213   <TD>&nbsp;&nbsp;Binary section begins
<TR><TD>&nbsp;&nbsp;             5..5+n-1<TD>&nbsp;&nbsp;&nbsp;<TD>&nbsp;&nbsp;&nbsp; <TD>&nbsp;&nbsp;Binary data (n octets)
</TABLE><br />
<p>
NOTE:  When a MIME header is used, only bytes 5 through 5+n-1 are considered in
computing the size and the message digest, and only these bytes are
encoded for the equivalent imgCIF file using the indicated
Content-Transfer-Encoding.
<p>
If no MIME header has been requested (a deprecated use), then bytes 5 through 28 are
used for three
8-byte words to hold the binary_id, the size and the compression type:
<p>
<TABLE>
<TR><TD VALIGN=TOP>&nbsp;&nbsp;              5..12  <TD>&nbsp;&nbsp;&nbsp;<TD>&nbsp;&nbsp;&nbsp; <TD>&nbsp;&nbsp;Binary Section Identifier<br />
                                    (See _array_data.binary_id)<br />
                                    64-bit, little endian
<TR><TD VALIGN=TOP>&nbsp;&nbsp;             13..20 <TD>&nbsp;&nbsp;&nbsp;<TD>&nbsp;&nbsp;&nbsp; <TD>&nbsp;&nbsp;The size (n) of the<br />
                                    binary section in octets<br />
                                    (i.e. the offset  from octet<br />
                                    29 to the first byte following<br />
                                    the data)
<TR><TD VALIGN=TOP>&nbsp;&nbsp;             21..28<TD>&nbsp;&nbsp;&nbsp;<TD>&nbsp;&nbsp;&nbsp; <TD>&nbsp;&nbsp;Compression type:<br />
                                      <TABLE ALIGN=CENTER>
                                      <TR><TD>&nbsp;&nbsp;CBF_NONE       <TD>&nbsp;&nbsp;0x0040 (64)
                                      <TR><TD>&nbsp;&nbsp;CBF_CANONICAL  <TD>&nbsp;&nbsp;0x0050 (80)
                                      <TR><TD>&nbsp;&nbsp;CBF_PACKED     <TD>&nbsp;&nbsp;0x0060 (96)
                                      <TR><TD>&nbsp;&nbsp;CBF_BYTE_OFFSET <TD>&nbsp;&nbsp;0x0070 (112)
                                      <TR><TD>&nbsp;&nbsp;CBF_PREDICTOR   <TD>&nbsp;&nbsp;0x0080 (128)
                                      <TR><TD>&nbsp;&nbsp;...            <TD>&nbsp;&nbsp;&nbsp;
                                      </TABLE>
</TABLE>
<p>
The binary data then follows in bytes 29 through 29+n-1.

<p>

The binary characters serve specific purposes:
<p>

<ul type=circle>

<li> The Control-L (from-feed) will terminate printing of the current page
     on most operating systems.
<p>

<li> The Control-Z will stop the listing of the file on MS-DOS
     type operating systems.
<p>

<li> The Control-D will stop the listing of the file on Unix
     type operating systems.
<p>

<li> The unsigned byte value 213 (decimal) is binary 11010101.
     (Octal 325, and hexadecimal D5).
     This has the eighth bit set so can be used for error checking
     on 7-bit transmission. It is also asymmetric, but with the first
     bit also set in the case that the bit order could be reversed
     (which is not a known concern).
<p>

<li> (The carriage return, line-feed pair before the START_OF_BIN
     and other lines can also be used to check that the file has not
     been corrupted e.g. by being sent by ftp in ASCII mode.)
<p>

<p><br />
      At present three compression schemes are implemented
     are defined:  CBF_NONE (for no compression), CBF_CANONICAL (for
     and entropy-coding scheme based on the canonical-code algorithm
     described by Moffat, <i>et al</i>. (<i>International
     Journal of High Speed Electronics and Systems</i>, Vol 8, No 1 (1997)
     179-231)) and CBF_PACKED for a CCP4-style packing scheme.  Other
     compression schemes will be added to
     this list in the future.
</ul>
<p>
For historical reasons, CBFlib can read or write a binary
string without a MIME header.   The structure of a binary string with simple
headers is:
<p>
<Table>
<tr><th ALIGN=LEFT VALIGN=TOP>Byte<th ALIGN=LEFT>ASCII<br />symbol<th ALIGN=LEFT>Decimal&nbsp;<br />value<th ALIGN=LEFT VALIGN=TOP>Description
<tr><TD>&nbsp;&nbsp;1<TD>&nbsp;&nbsp;;<TD>&nbsp;&nbsp;59<TD>&nbsp;&nbsp;Initial ; delimiter<br />
<tr><TD>&nbsp;&nbsp;2<TD>&nbsp;&nbsp;carriage-return<TD>&nbsp;&nbsp;13<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;3<TD>&nbsp;&nbsp;line-feed<TD>&nbsp;&nbsp;10<TD>&nbsp;&nbsp;The CBF new-line code is carriage-return, line-feed<br />
<tr><TD>&nbsp;&nbsp;4<TD>&nbsp;&nbsp;S<TD>&nbsp;&nbsp;83<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;5<TD>&nbsp;&nbsp;T<TD>&nbsp;&nbsp;84<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;6<TD>&nbsp;&nbsp;A<TD>&nbsp;&nbsp;65<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;7<TD>&nbsp;&nbsp;R<TD>&nbsp;&nbsp;83<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;8<TD>&nbsp;&nbsp;T<TD>&nbsp;&nbsp;84<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;9<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;10<TD>&nbsp;&nbsp;O<TD>&nbsp;&nbsp;79<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;11<TD>&nbsp;&nbsp;F<TD>&nbsp;&nbsp;70<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;12<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;13<TD>&nbsp;&nbsp;B<TD>&nbsp;&nbsp;66<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;14<TD>&nbsp;&nbsp;I<TD>&nbsp;&nbsp;73<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;15<TD>&nbsp;&nbsp;N<TD>&nbsp;&nbsp;78<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;16<TD>&nbsp;&nbsp;A<TD>&nbsp;&nbsp;65<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;17<TD>&nbsp;&nbsp;R<TD>&nbsp;&nbsp;83<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;18<TD>&nbsp;&nbsp;Y<TD>&nbsp;&nbsp;89<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;19<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;20<TD>&nbsp;&nbsp;S<TD>&nbsp;&nbsp;83<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;21<TD>&nbsp;&nbsp;E<TD>&nbsp;&nbsp;69<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;22<TD>&nbsp;&nbsp;C<TD>&nbsp;&nbsp;67<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;23<TD>&nbsp;&nbsp;T<TD>&nbsp;&nbsp;84<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;24<TD>&nbsp;&nbsp;I<TD>&nbsp;&nbsp;73<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;25<TD>&nbsp;&nbsp;O<TD>&nbsp;&nbsp;79<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;26<TD>&nbsp;&nbsp;N<TD>&nbsp;&nbsp;78<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;27<TD>&nbsp;&nbsp;carriage-return<TD>&nbsp;&nbsp;13<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;28<TD>&nbsp;&nbsp;line-feed<TD>&nbsp;&nbsp;10<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;29<TD>&nbsp;&nbsp;form-feed<TD>&nbsp;&nbsp;12<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;30<TD>&nbsp;&nbsp;substitute<TD>&nbsp;&nbsp;26<TD>&nbsp;&nbsp;Stop the listing of the file in MS-DOS<br />
<tr><TD>&nbsp;&nbsp;31<TD>&nbsp;&nbsp;end-of-transmission<TD>&nbsp;&nbsp;4<TD>&nbsp;&nbsp;Stop the listing of the file in unix<br />
<tr><TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;213<TD>&nbsp;&nbsp;First non-ASCII value<br />
<tr><TD>&nbsp;&nbsp;33 .. 40<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;Binary section identifier (64-bit little-endien)<br />
<tr><TD>&nbsp;&nbsp;41 .. 48<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;Offset from byte 57 to the first ASCII character following the binary data<br />
<tr><TD>&nbsp;&nbsp;49 .. 56<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;Compression type<br />
<tr><td COLSPAN=2>57 .. 57 + <i>n</i>-1<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;Binary data (<i>n</i>bytes)<br />
<tr><TD>&nbsp;&nbsp;57 + <i>n</i>
<TD>&nbsp;&nbsp;carriage-return<TD>&nbsp;&nbsp;13<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;58 + <i>n</i>
<TD>&nbsp;&nbsp;line-feed<TD>&nbsp;&nbsp;10<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;59 + <i>n</i>
<TD>&nbsp;&nbsp;E<TD>&nbsp;&nbsp;69<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;60 + <i>n</i>
<TD>&nbsp;&nbsp;N<TD>&nbsp;&nbsp;78<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;61 + <i>n</i>
<TD>&nbsp;&nbsp;D<TD>&nbsp;&nbsp;68<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;62 + <i>n</i>
<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;63 + <i>n</i>
<TD>&nbsp;&nbsp;O<TD>&nbsp;&nbsp;79<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;64 + <i>n</i>
<TD>&nbsp;&nbsp;F<TD>&nbsp;&nbsp;70<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;65 + <i>n</i>
<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;66 + <i>n</i>
<TD>&nbsp;&nbsp;B<TD>&nbsp;&nbsp;66<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;67 + <i>n</i>
<TD>&nbsp;&nbsp;I<TD>&nbsp;&nbsp;73<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;68 + <i>n</i>
<TD>&nbsp;&nbsp;N<TD>&nbsp;&nbsp;78<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;69 + <i>n</i>
<TD>&nbsp;&nbsp;A<TD>&nbsp;&nbsp;65<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;70 + <i>n</i>
<TD>&nbsp;&nbsp;R<TD>&nbsp;&nbsp;83<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;71 + <i>n</i>
<TD>&nbsp;&nbsp;Y<TD>&nbsp;&nbsp;89<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;72 + <i>n</i>
<TD>&nbsp;&nbsp;<TD>&nbsp;&nbsp;32<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;73 + <i>n</i>
<TD>&nbsp;&nbsp;S<TD>&nbsp;&nbsp;83<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;74 + <i>n</i>
<TD>&nbsp;&nbsp;E<TD>&nbsp;&nbsp;69<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;75 + <i>n</i>
<TD>&nbsp;&nbsp;C<TD>&nbsp;&nbsp;67<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;76 + <i>n</i>
<TD>&nbsp;&nbsp;T<TD>&nbsp;&nbsp;84<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;77 + <i>n</i>
<TD>&nbsp;&nbsp;I<TD>&nbsp;&nbsp;73<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;78 + <i>n</i>
<TD>&nbsp;&nbsp;O<TD>&nbsp;&nbsp;79<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;79 + <i>n</i>
<TD>&nbsp;&nbsp;N<TD>&nbsp;&nbsp;78<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;80 + <i>n</i>
<TD>&nbsp;&nbsp;carriage-return<TD>&nbsp;&nbsp;13<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;81 + <i>n</i>
<TD>&nbsp;&nbsp;line-feed<TD>&nbsp;&nbsp;10<TD>&nbsp;&nbsp;<br />
<tr><TD>&nbsp;&nbsp;82 + <i>n</i>
<TD>&nbsp;&nbsp;;<TD>&nbsp;&nbsp;59<TD>&nbsp;&nbsp;Final ; delimiter<br />
</table><br />


<h4><A NAME="3.3">3.3  Compression schemes</A></h4>
<p>
Two schemes for lossless compression of integer arrays (such as images) have been
implemented in this version of CBFlib:
<p>
1. An entropy-encoding scheme using canonical coding<br />
2. A CCP4-style packing scheme.
<p>
Both encode the difference (or error) between the current element in the array and
the prior element.  Parameters required for more sophisticated predictors have been
included in the compression functions and will be used in a future version of the
library.
<p>

<h4><A NAME="3.3.1">3.3.1  Canonical-code compression</A></h4>
<p>
The canonical-code compression scheme encodes errors in two ways: directly or indirectly.
 Errors are coded directly using a symbol corresponding to the error value.  Errors
are coded indirectly using a symbol for the number of bits in the (signed) error,
followed by the error iteslf.
<p>
At the start of the compression, CBFlib constructs a table containing a set of symbols,
one for each of the 2^<SUP>n</sup>
 direct codes from -2^<SUP>(n-1)</sup>
 .. 2^<SUP>(n-1)</sup>-1,
one for a stop code, and one for each of the <i>maxbits</i>
-<i>n</i>
 indirect codes, where <i>n</i>
 is chosen at compress time and <i>maxbits</i>
 is the maximum number of bits in an error.  CBFlib then assigns to each symbol a
bit-code, using a shorter bit code for the more common symbols and a longer bit code
for the less common symbols.  The bit-code lengths are calculated using a Huffman-type
algorithm, and the actual bit-codes are constructed using the canonical-code algorithm
described by Moffat, <i>et al</i>. (<i>International
Journal of High Speed Electronics and Systems</i>, Vol 8, No 1 (1997) 179-231).
<p>
The structure of the compressed data is:
<p>
<TABLE ALIGN=CENTER>
<TR><TH ALIGN=LEFT>Byte<TH>Value
<TR><TD>&nbsp;&nbsp;1 .. 8<TD>&nbsp;&nbsp;Number of elements (64-bit little-endian number)<br />
<TR><TD>&nbsp;&nbsp;9 .. 16<TD>&nbsp;&nbsp;Minimum element<br />
<TR><TD>&nbsp;&nbsp;17 .. 24<TD>&nbsp;&nbsp;Maximum element<br />
<TR><TD>&nbsp;&nbsp;25 .. 32<TD>&nbsp;&nbsp;(reserved for future use)<br />
<TR><TD>&nbsp;&nbsp;33<TD>&nbsp;&nbsp;Number of bits directly coded, <I>n</I>
<TR><TD>&nbsp;&nbsp;34<TD>&nbsp;&nbsp;Maximum number of bits encoded, <I>maxbits</I>
<TR><TD>&nbsp;&nbsp;35 .. 35+2^<SUP>n</SUP>-1<TD>&nbsp;&nbsp;Number of bits in each direct code<br />
<TR><TD>&nbsp;&nbsp;35+2^<SUP>n</SUP><TD>&nbsp;&nbsp;Number of bits in the stop code<br />
<TR><TD>&nbsp;&nbsp;35+2^<SUP>n</SUP>+1 .. 35+2^<SUP>n</SUP>+<I>maxbits</I>-<I>n</I>
<TD>&nbsp;&nbsp;Number of bits in each indirect code<br />
<TR><TD>&nbsp;&nbsp;35+2^<SUP>n</SUP>+<I>maxbits</I>-<I>n</I>+1 ..
<TD>&nbsp;&nbsp;Coded data<br />
</TABLE>

<H4><A NAME="3.3.2">3.3.2  CCP4-style compression</A></H4>
<p>
The CCP4-style compression writes the errors in blocks .  Each block begins with a
6-bit code.  The number of errors in the block is 2^<SUP>n</SUP>,
where <i>n</i>
 is the value in bits 0 .. 2.
Bits 3 .. 5 encode the number of bits in each error:<br />
<TABLE ALIGN=CENTER>
<TR><TH ALIGN=CENTER>Value in<br /> bits 3 .. 5</TH>
<TH ALIGN=CENTER>Number of bits<br /> in each error<p></TH>
</TR>
<TR><TD ALIGN=CENTER>0</TD><TD ALIGN=CENTER>0</TD>
<TR><TD ALIGN=CENTER>1</TD><TD ALIGN=CENTER>4</TD>
<TR><TD ALIGN=CENTER>2</TD><TD ALIGN=CENTER>5</TD>
<TR><TD ALIGN=CENTER>3</TD><TD ALIGN=CENTER>6</TD>
<TR><TD ALIGN=CENTER>4</TD><TD ALIGN=CENTER>7</TD>
<TR><TD ALIGN=CENTER>5</TD><TD ALIGN=CENTER>8</TD>
<TR><TD ALIGN=CENTER>6</TD><TD ALIGN=CENTER>16</TD>
<TR><TD ALIGN=CENTER>7</TD><TD ALIGN=CENTER>65</TD>
</TABLE>

<p>
The structure of the compressed data is:<br />
<TABLE ALIGN=CENTER>
<TR><TH>Byte</TH><TH>Value</TH>
<TR><TD>&nbsp;&nbsp;1 .. 8</TD><TD>&nbsp;&nbsp;Number of elements (64-bit little-endian number)</TD></TR>
<TR><TD>&nbsp;&nbsp;9 .. 16</TD><TD>&nbsp;&nbsp;Minumum element (currently unused)</TD></TR>
<p>
<TR><TD>&nbsp;&nbsp;17 .. 24</TD><TD>&nbsp;&nbsp;Maximum element (currently unused)</TD></TR>
<p>
<TR><TD>&nbsp;&nbsp;25 .. 32</TD><TD>&nbsp;&nbsp;(reserved for future use)</TD></TR>
<p>
<TR><TD>&nbsp;&nbsp;33 ..</TD><TD>&nbsp;&nbsp;Coded data</TD></TR>
</TABLE>

<H4><A NAME="4.">4.  Installation</A></H4>
<p>
CBFlib should be built on a disk with at least 200 megabytes of free space.
<A HREF="../CBFlib.tar.gz">CBFlib.tar.gz</A> is a "gzipped" tar of
the code as it now stands.  Place the gzipped tar in the directory
that is intended to contain a new directory, named 
CBFlib_0.7.5 (the &quot;top-level&quot; directory)
and  uncompress it with gunzip and unpack it with tar:
<p>
<PRE>
     gunzip CBFlib.tar.gz
     tar xvf CBFLIB.tar
</PRE>
<p>
To run the test programs, you will also need to put 
Paul Ellis's sample MAR345 image,
<A HREF="../example.mar2300">example.mar2300</A>, and
Chris Nielsen's sample ADSC Quantum 315 image, 
<a href="../mb_LP_1_001.img">mb_LP_1_001.img</a> as sample data.
in the directory containing the  top-level directory.  (The image can also be found at
After unpacking the archive, the top-level directory should contain
a makefile:
<p>
<TABLE ALIGN=CENTER>
<TR><TD>&nbsp;&nbsp;Makefile<TD>&nbsp;&nbsp;Makefile for unix
</TABLE>
<p>
and the subdirectories:
<p>
<TABLE ALIGN=CENTER>
<TR><TD>&nbsp;&nbsp;src/<TD>&nbsp;&nbsp;CBFLIB source files
<TR><TD>&nbsp;&nbsp;include/<TD>&nbsp;&nbsp;CBFLIB header files
<TR><TD>&nbsp;&nbsp;examples/<TD>&nbsp;&nbsp;Example program source files
<TR><TD>&nbsp;&nbsp;doc/<TD>&nbsp;&nbsp;Documentation
<TR><TD>&nbsp;&nbsp;lib/<TD>&nbsp;&nbsp;Compiled CBFLIB library
<TR><TD>&nbsp;&nbsp;bin/<TD>&nbsp;&nbsp;Executable example programs
<TR><TD>&nbsp;&nbsp;html_images/<TD>&nbsp;&nbsp;JPEG images used in rendering the HTML files
</TABLE>
<p>
For instructions on compiling and testing the library, go to
the top-level directory and type:
<p>
<PRE>
     make
</PRE>
<p>
The CBFLIB source and header files are in the "src" and "include" subdirectories.  The files are:
<TABLE ALIGN=CENTER>
<TR><TH ALIGN=LEFT>src/<TH ALIGN=LEFT>include/
                      <TH ALIGN=LEFT>Description
<TR><TD>&nbsp;&nbsp;cbf.c<TD>&nbsp;&nbsp;cbf.h
                      <TD>&nbsp;&nbsp;CBFLIB API functions
<TR><TD>&nbsp;&nbsp;cbf_alloc.c<TD>&nbsp;&nbsp;cbf_alloc.h
                      <TD>&nbsp;&nbsp;Memory allocation functions
<TR><TD>&nbsp;&nbsp;cbf_ascii.c<TD>&nbsp;&nbsp;cbf_ascii.h
                      <TD>&nbsp;&nbsp;Function for writing ASCII values
<TR><TD>&nbsp;&nbsp;cbf_binary.c<TD>&nbsp;&nbsp;cbf_binary.h
                      <TD>&nbsp;&nbsp;Functions for binary values
<TR><TD>&nbsp;&nbsp;cbf_byte_offset.c<TD>&nbsp;&nbsp;cbf_byte_offset.h
                      <TD>&nbsp;&nbsp;Byte-offset compression (not implemented)
<TR><TD>&nbsp;&nbsp;cbf_canonical.c<TD>&nbsp;&nbsp;cbf_canonical.h
                      <TD>&nbsp;&nbsp;Canonical-code compression
<TR><TD>&nbsp;&nbsp;cbf_codes.c<TD>&nbsp;&nbsp;cbf_codes.h
                      <TD>&nbsp;&nbsp;Encoding and message digest functions
<TR><TD>&nbsp;&nbsp;cbf_compress.c<TD>&nbsp;&nbsp;cbf_compress.h
                      <TD>&nbsp;&nbsp;General compression routines
<TR><TD>&nbsp;&nbsp;cbf_context.c<TD>&nbsp;&nbsp;cbf_context.h
                      <TD>&nbsp;&nbsp;Control of temporary files
<TR><TD>&nbsp;&nbsp;cbf_file.c<TD>&nbsp;&nbsp;cbf_file.h
                      <TD>&nbsp;&nbsp;File in/out functions
<TR><TD>&nbsp;&nbsp;cbf_lex.c<TD>&nbsp;&nbsp;cbf_lex.h
                      <TD>&nbsp;&nbsp;Lexical analyser
<TR><TD>&nbsp;&nbsp;cbf_packed.c<TD>&nbsp;&nbsp;cbf_packed.h
                      <TD>&nbsp;&nbsp;CCP4-style packing compression
<TR><TD>&nbsp;&nbsp;cbf_predictor.c<TD>&nbsp;&nbsp;cbf_predictor.h
                      <TD>&nbsp;&nbsp;Predictor-Huffman compression (not implemented)
<TR><TD>&nbsp;&nbsp;cbf_read_binary.c<TD>&nbsp;&nbsp;cbf_read_binary.h
                      <TD>&nbsp;&nbsp;Read binary headers
<TR><TD>&nbsp;&nbsp;cbf_read_mime.c<TD>&nbsp;&nbsp;cbf_read_mime.h
                      <TD>&nbsp;&nbsp;Read MIME-encoded binary sections
<TR><TD>&nbsp;&nbsp;cbf_simple.c<TD>&nbsp;&nbsp;cbf_simple.h
                      <TD>&nbsp;&nbsp;Hidher-level CBFlib functions
<TR><TD>&nbsp;&nbsp;cbf_string.c<TD>&nbsp;&nbsp;cbf_string.h
                      <TD>&nbsp;&nbsp;Case-insensitive string comparisons
<TR><TD>&nbsp;&nbsp;cbf_stx.c<TD>&nbsp;&nbsp;cbf_stx.h
                      <TD>&nbsp;&nbsp;Parser (generated from cbf.stx.y)
<TR><TD>&nbsp;&nbsp;cbf_tree.c<TD>&nbsp;&nbsp;cbf_tree.h
                      <TD>&nbsp;&nbsp;CBF tree-structure functions
<TR><TD>&nbsp;&nbsp;cbf_uncompressed.c<TD>&nbsp;&nbsp;cbf_uncompressed.h
                      <TD>&nbsp;&nbsp;Uncompressed binary sections
<TR><TD>&nbsp;&nbsp;cbf_write.c<TD>&nbsp;&nbsp;cbf_write.h
                      <TD>&nbsp;&nbsp;Functions for writing
<TR><TD>&nbsp;&nbsp;cbf_write_binary.c<TD>&nbsp;&nbsp;cbf_write_binary.h
                      <TD>&nbsp;&nbsp;Write binary sections
<TR><TD>&nbsp;&nbsp;cbf.stx.y<TD>&nbsp;&nbsp;&nbsp;
                      <TD>&nbsp;&nbsp;bison grammar to define cbf_stx.c (see WARNING)
<TR><TD>&nbsp;&nbsp;md5c.c<TD>&nbsp;&nbsp;md5.h
                      <TD>&nbsp;&nbsp;RSA message digest software from mpack
<TR><TD>&nbsp;&nbsp;&nbsp;<TD>&nbsp;&nbsp;global.h
                      <TD>&nbsp;&nbsp;&nbsp;
</TABLE>
<p>
In the "examples" subdirectory, there are 2 additional files
used by the example programs (section 5) for reading MAR300,
MAR345 or ADSC CCD images:
<p>
<TABLE ALIGN=CENTER>
<TR><TD>&nbsp;&nbsp;img.c<TD>&nbsp;&nbsp;img.h<TD>&nbsp;&nbsp;Simple image library
</TABLE>
<p>
and the example programs themselves:
<p>
<TABLE ALIGN=CENTER>
<TR><TD>&nbsp;&nbsp;makecbf.c<TD>&nbsp;&nbsp;Make a CBF file from an image
<TR><TD>&nbsp;&nbsp;img2cif.c<TD>&nbsp;&nbsp;Make an imgCIF or CBF from an image
<TR><TD>&nbsp;&nbsp;cif2cbf.c<TD>&nbsp;&nbsp;Copy a CIF/CBF to a CIF/CBF
<TR><TD valign="top">&nbsp;&nbsp;convert_image.c<TD>&nbsp;&nbsp;Convert an image file to a cbf using a template file
<TR><TD valign="top">&nbsp;&nbsp;cif2c.c<TD>&nbsp;&nbsp;Convert a template cbf file into a function to produce the same template in an
internal cbf data structure
<TR><TD valign="top">&nbsp;&nbsp;testcell.C<TD>&nbsp;&nbsp;Exercise the cell functions
</TABLE>
<p>
as well as three template files:  template_adscquantum4_2304x2304.cbf,
template_mar345_2300x2300.cbf, and template_adscquantum315_3072x3072.cbf.
<p>
The documentation files are in the "doc" subdirectory:
<p>
<TABLE ALIGN=CENTER>
<TR><TD>&nbsp;&nbsp;CBFlib.html<TD>&nbsp;&nbsp;This document (HTML)
<TR><TD>&nbsp;&nbsp;CBFlib.txt<TD>&nbsp;&nbsp;This document (ASCII)
<TR><TD>&nbsp;&nbsp;CBFlib_NOTICES.html<TD>&nbsp;&nbsp;Important NOTICES -- PLEASE READ
<TR><TD>&nbsp;&nbsp;CBFlib_NOTICES.txt<TD>&nbsp;&nbsp;Important NOTICES -- PLEASE READ
<TR><TD>&nbsp;&nbsp;gpl.txt<TD>&nbsp;&nbsp;GPL -- PLEASE READ
<TR><TD>&nbsp;&nbsp;lgpl.txt<TD>&nbsp;&nbsp;LGPL -- PLEASE READ
<TR><TD>&nbsp;&nbsp;cbf_definition_rev.txt<TD>&nbsp;&nbsp;Draft CBF/ImgCIF definition (ASCII)
<TR><TD>&nbsp;&nbsp;cbf_definition_rev.html<TD>&nbsp;&nbsp;Draft CBF/ImgCIF definition (HTML)
<TR><TD>&nbsp;&nbsp;cif_img.html<TD>&nbsp;&nbsp;CBF/ImgCIF extensions dictionary (HTML)
<TR><TD>&nbsp;&nbsp;cif_img.dic<TD>&nbsp;&nbsp;CBF/ImgCIF extensions dictionary (ASCII)
<TR><TD>&nbsp;&nbsp;ChangeLog,html<TD>&nbsp;&nbsp;Summary of change history (HTML)
<TR><TD>&nbsp;&nbsp;ChangeLog<TD>&nbsp;&nbsp;Summary of change history (ASCII)
</TABLE>

<H4><A NAME="5.">5.  Example programs</A></H4>
<p>
The example programs makecbf.c and img2cif.c read an image file
from a MAR300, MAR345 or ADSC CCD detector and then uses CBFlib to
convert it to CBF format (makecbf) or either imgCIF or CBF format (img2cif).
 makecbf writes the CBF-format image to disk, reads it in again, and
then compares it to the original.  img2cif just writes
the desired file.  makecbf works only from stated files on disk, so that
random I/O can be used.  img2cif includes code to process files
from stdin and to stdout.
<p>
makecbf.c is a good example of how many of the CBFlib functions can be
used.
To compile makecbf and the other example programs use the Makefile in the top-level
directory:
<p>
<PRE>
     make all
</PRE>
This will place the programs in the bin directory.
<p>
To run makecbf with the example image, type:
<p>
<PRE>
     ./bin/makecbf example.mar2300 test.cbf
</PRE>
<p>

The program img2cif has the following command line interface:
<p>

<PRE>
 img2cif     [-i  input_image]                               \
             [-o  output_cif]                                \
             [-c  {p[acked]|c[annonical]|[n[one]}]           \
             [-m  {h[eaders]|n[oheaders]}]                   \
             [-d  {d[igest]|n[odigest]}]                     \
             [-e  {b[ase64]|q[uoted-printable]|              \
                   d[ecimal]|h[exadecimal]|o[ctal]|n[one]}]  \
             [-b  {f[orward]|b[ackwards]}]                   \
             [input_image] [output_cif]

 the options are:

 -i  input_image (default: stdin)
     the input_image file in MAR300, MAR345 or ADSC CCD detector
     format is given.  If no input_image file is specified or is
     given as "-", an image is copied from stdin to a temporary file.

 -o  output_cif (default: stdout)
     the output cif (if base64 or quoted-printable encoding is used)
     or cbf (if no encoding is used).  if no output_cif is specified
     or is given as "-", the output is written to stdout

 -c  compression_scheme (packed, canonical or none, default packed)

 -m  [no]headers (default headers for cifs, noheaders for cbfs)
     selects MIME (N. Freed, N. Borenstein, RFC 2045, November 1996)
     headers within binary data value text fields.

 -d  [no]digest  (default md5 digest [R. Rivest, RFC 1321, April
     1992 using"RSA Data Security, Inc. MD5 Message-Digest
     Algorithm"] when MIME headers are selected)

 -e  encoding (base64, quoted-printable, decimal, hexadecimal,
     octal or none, default: base64) specifies one of the standard
     MIME encodings (base64 or quoted-printable) or a non-standard
     decimal, hexamdecimal or octal encoding for an ascii cif
     or "none" for a binary cbf

 -b  direction (forward or backwards, default: backwards)
     specifies the direction of mapping of bytes into words
     for decimal, hexadecimal or octal output, marked by '>' for
     forward or '<' for backwards as the second character of each
     line of output, and in '#' comment lines.

</PRE>
<p>
The test program cif2cbf uses the same command line options as img2cif, but
accepts either a CIF or a CBF as input instead of an image file:
<P>
<pre>
  cif2cbf    [-i input_cif]                                \
             [-o output_cbf]                               \
             [-c {p[acked]|c[annonical]|[n[one]}]          \
             [-m {h[eaders]|n[oheaders]}]                  \
             [-d {d[igest]|n[odigest]}]                    \
             [-e {b[ase64]|q[uoted-printable]|             \
                  d[ecimal]|h[exadecimal]|o[ctal]|n[one]}] \
             [-b {f[orward]|b[ackwards]}]                  \
             [input_cif] [output_cbf]

  the options are:

  -i input_cif (default: stdin)
    the input  file in CIF or CBF  format.  If input_cif is not
    specified or is given as "-", it is copied from stdin to a
    temporary file.

  -o output_cbf (default: stdout)
    the output cif (if base64 or quoted-printable encoding is used)
    or cbf (if no encoding is used).  if no output_cif is specified
    or is given as "-", the output is written to stdout

  -c compression_scheme (packed, canonical or none,
    default packed)

  -m [no]headers (default headers for cifs, noheaders for cbfs)
    selects MIME (N. Freed, N. Borenstein, RFC 2045, November 1996)
    headers within binary data value text fields.

  -d [no]digest  (default md5 digest [R. Rivest, RFC 1321, April
    1992 using"RSA Data Security, Inc. MD5 Message-Digest
    Algorithm"] when MIME headers are selected)

  -e encoding (base64, quoted-printable or none, default base64)
    specifies one of the standard MIME encodings for an ascii cif
    or "none" for a binary cbf

</pre>
<p>

The program convert_image requires two arguments: <i>imagefile</i> and <i>cbffile</i>.
Those are the primary input and out.  The detector type is extracted from the
image file, converted to lower case and used to construct the name of a template
cbf file to use for the copy.  The template file name is of the form
template_<i>name</i>_<i>columns</i>x<i>rows</i>.  The full set of options is:
<p>
<pre>

  convert_image                                          \
            [-i input_img]                               \
            [-o output_cbf]                              \
            [-p template_cbf]                            \
            [-d detector name]                           \
            [ -m [x|y|x=y]                               \
            [-z distance]                                \
            [input_img] [output_cbf]

  the options are:

  -i input_img (default: stdin)
    the input file as an image in smv, mar300, or mar345  format.
    If input_img is not specified or is given as "-", it is copied
    from stdin to a temporary file.

  -p template_cbf
    the template for the final cbf to be produced.  If template_cbf
    is not specified the name is constructed from the first token
    of the detector name and the image size as
       template_&lt;type&gt;_&lt;columns&gt;x&lt;rows&gt;.cbf

  -o output_cbf (default: stdout )
    the output cbf combining the image and the template.  If the
    output_cbf is not specified or is given as "-", it is written
    to stdout.

  -d detectorname
    a detector name to be used if none is provided in the image
    header.

  -m [x|y|x=y] (default x=y, square arrays only)
    mirror the array in the x-axis (y -&gt; -y)
                     in the y-axis (x -&gt; -x)
                  or in x=y ( x -&gt; y, y-&gt; x)

  -r n
    rotate the array n times 90 degrees counter clockwise
    x -&gt; y, y -&gt; -x for each rotation, n = 1, 2 or 3

  -z distance
    detector distance along Z-axis
</pre>
<P>
<HR>
<HR>
Updated 16 July 2006.
Contact:
<script language="javascript" type="text/javascript">
<!--
      var name = "yaya@";
      var domain = "bernstein-plus-sons";
      var domext = ".com";
      document.write ("<a href=\"mailto:" + name + domain + domext + "\">" + name + domain + domext+"</a>");
// -->
</script>
<noscript>
yaya&#64;bernstein-plus-sons&#46;com
</noscript>
</font>
</BODY>
</HTML>
