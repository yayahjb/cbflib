/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_DIRECTOR_NO_VTABLE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *newstr = 0;
  str = PyUnicode_AsUTF8String(str);
  if (str) {
    char *cstr;
    Py_ssize_t len;
    PyBytes_AsStringAndSize(str, &cstr, &len);
    newstr = (char *) malloc(len+1);
    memcpy(newstr, cstr, len+1);
    Py_XDECREF(str);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
// interface files check for it.
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    Py_XINCREF(type);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

SWIGRUNTIME int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

SWIGRUNTIME void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(NULL)) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    PyErr_Fetch(&type, &value, &traceback);
#if PY_VERSION_HEX >= 0x03000000
    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
#else
    newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
#endif
    Py_XDECREF(value);
    PyErr_Restore(type, newvalue, traceback);
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    define SWIG_PYTHON_USE_GIL
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

#if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
# error "This version of SWIG only supports Python >= 2.7"
#endif

#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
# error "This version of SWIG only supports Python 3 >= 3.2"
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, (char *)"O", obj);

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
      data->delargs = !(flags & (METH_O));
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
SWIGRUNTIME PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = NULL, *value = NULL, *traceback = NULL;
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return NULL;
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        SwigPyObject_acquire(v,args);
      } else {
        SwigPyObject_disown(v,args);
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  METH_NOARGS,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, METH_NOARGS,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     METH_VARARGS, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  METH_O,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    METH_NOARGS,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   METH_NOARGS,  "returns object representation"},
  {0, 0, 0, 0}  
};

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#else
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (Swig_This_global == NULL)
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
      if (!SWIG_IsOK(res) && obj == Py_None) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = SWIG_OK;
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return SWIG_ERROR;
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    } else {
      return SWIG_ERROR;
    }
    return SWIG_OK;
  }
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        Py_DECREF(empty_kwargs);
        if (inst) {
          PyObject_SetAttr(inst, SWIG_This(), swig_this);
          Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
        }
      }
      Py_DECREF(empty_args);
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, "__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  Swig_This_global = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
      if (!encoded_name)
        return -1;
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



#ifdef __cplusplus
extern "C" {
#endif

/* Method creation and docstring support functions */

SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_CBF_NODETYPE swig_types[0]
#define SWIGTYPE_p_a_4__double swig_types[1]
#define SWIGTYPE_p_a_4__doubleArray swig_types[2]
#define SWIGTYPE_p_cbf_axis_struct swig_types[3]
#define SWIGTYPE_p_cbf_detector_struct swig_types[4]
#define SWIGTYPE_p_cbf_handle_struct swig_types[5]
#define SWIGTYPE_p_cbf_node swig_types[6]
#define SWIGTYPE_p_cbf_positioner_struct swig_types[7]
#define SWIGTYPE_p_char swig_types[8]
#define SWIGTYPE_p_double swig_types[9]
#define SWIGTYPE_p_doubleArray swig_types[10]
#define SWIGTYPE_p_int swig_types[11]
#define SWIGTYPE_p_intArray swig_types[12]
#define SWIGTYPE_p_long swig_types[13]
#define SWIGTYPE_p_longArray swig_types[14]
#define SWIGTYPE_p_p_char swig_types[15]
#define SWIGTYPE_p_short swig_types[16]
#define SWIGTYPE_p_shortArray swig_types[17]
#define SWIGTYPE_p_size_t swig_types[18]
#define SWIGTYPE_p_void swig_types[19]
static swig_type_info *swig_types[21];
static swig_module_info swig_module = {swig_types, 20, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _pycbf.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__pycbf

#else
#  define SWIG_init    init_pycbf

#endif
#define SWIG_name    "_pycbf"

#define SWIGVERSION 0x040000 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


typedef double doubleArray;


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (size_t)(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  }
#endif
  return res;
}

SWIGINTERN doubleArray *new_doubleArray(size_t nelements){
    return (double *)calloc(nelements, sizeof(double));
  }
SWIGINTERN void delete_doubleArray(doubleArray *self){
    free((char*)self);
  }
SWIGINTERN double doubleArray___getitem__(doubleArray *self,size_t index){
    return self[index];
  }

  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN void doubleArray___setitem__(doubleArray *self,size_t index,double value){
    self[index] = value;
  }
SWIGINTERN double *doubleArray_cast(doubleArray *self){
    return self;
  }
SWIGINTERN doubleArray *doubleArray_frompointer(double *t){
    return (doubleArray *)(t);
  }

typedef int intArray;

SWIGINTERN intArray *new_intArray(size_t nelements){
    return (int *)calloc(nelements, sizeof(int));
  }
SWIGINTERN void delete_intArray(intArray *self){
    free((char*)self);
  }
SWIGINTERN int intArray___getitem__(intArray *self,size_t index){
    return self[index];
  }

SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}

SWIGINTERN void intArray___setitem__(intArray *self,size_t index,int value){
    self[index] = value;
  }
SWIGINTERN int *intArray_cast(intArray *self){
    return self;
  }
SWIGINTERN intArray *intArray_frompointer(int *t){
    return (intArray *)(t);
  }

typedef short shortArray;

SWIGINTERN shortArray *new_shortArray(size_t nelements){
    return (short *)calloc(nelements, sizeof(short));
  }
SWIGINTERN void delete_shortArray(shortArray *self){
    free((char*)self);
  }
SWIGINTERN short shortArray___getitem__(shortArray *self,size_t index){
    return self[index];
  }

  #define SWIG_From_long   PyInt_FromLong 


SWIGINTERNINLINE PyObject *
SWIG_From_short  (short value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_short (PyObject * obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (short)(v);
    }
  }  
  return res;
}

SWIGINTERN void shortArray___setitem__(shortArray *self,size_t index,short value){
    self[index] = value;
  }
SWIGINTERN short *shortArray_cast(shortArray *self){
    return self;
  }
SWIGINTERN shortArray *shortArray_frompointer(short *t){
    return (shortArray *)(t);
  }

typedef long longArray;

SWIGINTERN longArray *new_longArray(size_t nelements){
    return (long *)calloc(nelements, sizeof(long));
  }
SWIGINTERN void delete_longArray(longArray *self){
    free((char*)self);
  }
SWIGINTERN long longArray___getitem__(longArray *self,size_t index){
    return self[index];
  }
SWIGINTERN void longArray___setitem__(longArray *self,size_t index,long value){
    self[index] = value;
  }
SWIGINTERN long *longArray_cast(longArray *self){
    return self;
  }
SWIGINTERN longArray *longArray_frompointer(long *t){
    return (longArray *)(t);
  }

static int convert_darray(PyObject *input, double *ptr, int size) {
  int i;
  if (!PySequence_Check(input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return 0;
  }
  if (PyObject_Length(input) != size) {
      PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
      return 0;
  }
  for (i =0; i < size; i++) {
      PyObject *o = PySequence_GetItem(input,i);
     /*if (!PyFloat_Check(o)) {
        
         Py_XDECREF(o);
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return 0;
      }*/
      ptr[i] = PyFloat_AsDouble(o);
      Py_DECREF(o);
  }
  return 1;
}


    static long convert_larray(PyObject *input, long *ptr, int size) {
        int i;
        if (!PySequence_Check(input)) {
            PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
            return 0;
        }
        if (PyObject_Length(input) != size) {
            PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
            return 0;
        }
        for (i =0; i < size; i++) {
            PyObject *o = PySequence_GetItem(input,i);
            /*if (!PyLong_Check(o)) {
                Py_XDECREF(o);
                PyErr_SetString(PyExc_ValueError,"Expecting a sequence of long integers");
                return 0;
            }*/
            ptr[i] = PyLong_AsLong(o);
            Py_DECREF(o);
        }
        return 1;
    }


    static int convert_iarray(PyObject *input, int *ptr, int size) {
        int i;
        if (!PySequence_Check(input)) {
            PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
            return 0;
        }
        if (PyObject_Length(input) != size) {
            PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
            return 0;
        }
        for (i =0; i < size; i++) {
            PyObject *o = PySequence_GetItem(input,i);
            /*if (!PyInt_Check(o)) {
                Py_XDECREF(o);
                PyErr_SetString(PyExc_ValueError,"Expecting a sequence of long integers");
                return 0;
            }*/
            ptr[i] = (int)PyInt_AsLong(o);
            Py_DECREF(o);
        }
        return 1;
    }

  // Here is the c code needed to compile the wrappers, but not 
    // to be wrapped 

#include "../include/cbf.h"          
#include "../include/cbf_simple.h"

// Helper functions to generate error message
 

static int error_status = 0;
static char error_message[1024] ; // hope that is long enough

/* prototype */
void get_error_message(void);

void get_error_message(){
  sprintf(error_message,"%s","CBFlib Error(s):");
  if (error_status & CBF_FORMAT        )
    sprintf(error_message,"%s %s",error_message,"CBF_FORMAT       "); 
  if (error_status & CBF_ALLOC         )
    sprintf(error_message,"%s %s",error_message,"CBF_ALLOC        ");
  if (error_status & CBF_ARGUMENT      )
    sprintf(error_message,"%s %s",error_message,"CBF_ARGUMENT     ");
  if (error_status & CBF_ASCII         )
    sprintf(error_message,"%s %s",error_message,"CBF_ASCII        ");
  if (error_status & CBF_BINARY        )
    sprintf(error_message,"%s %s",error_message,"CBF_BINARY       ");
  if (error_status & CBF_BITCOUNT      )
    sprintf(error_message,"%s %s",error_message,"CBF_BITCOUNT     ");
  if (error_status & CBF_ENDOFDATA     )
    sprintf(error_message,"%s %s",error_message,"CBF_ENDOFDATA    ");
  if (error_status & CBF_FILECLOSE     )
    sprintf(error_message,"%s %s",error_message,"CBF_FILECLOSE    ");
  if (error_status & CBF_FILEOPEN      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILEOPEN     ");
  if (error_status & CBF_FILEREAD      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILEREAD     ");
  if (error_status & CBF_FILESEEK      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILESEEK     ");
  if (error_status & CBF_FILETELL      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILETELL     ");
  if (error_status & CBF_FILEWRITE     )
    sprintf(error_message,"%s %s",error_message,"CBF_FILEWRITE    ");
  if (error_status & CBF_IDENTICAL     )
    sprintf(error_message,"%s %s",error_message,"CBF_IDENTICAL    ");
  if (error_status & CBF_NOTFOUND      )
    sprintf(error_message,"%s %s",error_message,"CBF_NOTFOUND     ");
  if (error_status & CBF_OVERFLOW      )
    sprintf(error_message,"%s %s",error_message,"CBF_OVERFLOW     ");
  if (error_status & CBF_UNDEFINED     )
    sprintf(error_message,"%s %s",error_message,"CBF_UNDEFINED    ");
  if (error_status & CBF_NOTIMPLEMENTED)
    sprintf(error_message,"%s %s",error_message,"CBF_NOTIMPLEMENTED");
  if (error_status & CBF_NOCOMPRESSION)
    sprintf(error_message,"%s %s",error_message,"CBF_NOCOMPRESSION");
}




void airy_disk(double x, double y, double cenx, double ceny,
double volume, double fwhm, double *value) {
{(error_status = cbf_airy_disk(x,y,cenx,ceny,volume,fwhm,value));};
}


void airy_disk_volume(double xlo, double ylo, double xhi, double yhi,
double cenx, double ceny, double volumein, double fwhm, double * volumeout) {
{(error_status = cbf_airy_disk_volume(xlo,ylo,xhi,yhi,cenx,ceny,volumein,fwhm,volumeout));};
}


  void compute_cell_volume(double cell[6], double *volume) {
  {(error_status = cbf_compute_cell_volume(cell,volume));};
  }
  

  void compute_reciprocal_cell(double cell[6], double *astar, double *bstar, double *cstar,
  double *alphastar, double *betastar, double *gammastar) {
    double rcell[6];
    {(error_status = cbf_compute_reciprocal_cell(cell,rcell));};
    *astar =      rcell[0];
    *bstar =      rcell[1];
    *cstar =      rcell[2];
    *alphastar =  rcell[3];
    *betastar =   rcell[4];
    *gammastar =  rcell[5];
  }
  

  void get_local_integer_byte_order(char **bo, int *bolen) {
        char * byteorder;
        char * bot;
        error_status = cbf_get_local_integer_byte_order(&byteorder);
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
  }
  

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));
#else
      return PyUnicode_DecodeUTF8(carray, (Py_ssize_t)(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


  void get_local_real_byte_order(char **bo, int *bolen) {
        char * byteorder;
        char * bot;
        error_status = cbf_get_local_real_byte_order(&byteorder);
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
  }
  

  void get_local_real_format(char **rf, int *rflen) {
        char * real_format;
        char * rft;
        error_status = cbf_get_local_real_format(&real_format);
        *rflen = strlen(real_format);
        if (!(rft = (char *)malloc(*rflen))) {{(error_status = CBF_ALLOC);}}
        strncpy(rft,real_format,*rflen);
        *rf = rft;
  }
  

SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong((long)(value));
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong((long)(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  ((unsigned long long)(value));
  }
#endif
}

SWIGINTERN cbf_positioner_struct *new_cbf_positioner_struct(void){  // Constructor
       // DO NOT CONSTRUCT WITHOUT A CBFHANDLE
       {(error_status = CBF_ARGUMENT);};
       return NULL; /* Should never be executed */
       }
SWIGINTERN void delete_cbf_positioner_struct(cbf_positioner_struct *self){ // Destructor
       {(error_status = cbf_free_positioner(self));};
       }
SWIGINTERN void cbf_positioner_struct_get_goniometer_poise(cbf_positioner_struct *self,double ratio,double *vector1,double *vector2,double *vector3,double *offset1,double *offset2,double *offset3,double *angle){
          {(error_status = cbf_get_goniometer_poise(self, ratio,
                vector1, vector2, vector3,
                offset1, offset2, offset3,angle));}

;
        }
SWIGINTERN void cbf_positioner_struct_get_reciprocal(cbf_positioner_struct *self,double ratio,double wavelength,double real1,double real2,double real3,double *reciprocal1,double *reciprocal2,double *reciprocal3){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_reciprocal(self,reserved, ratio, wavelength,
                         real1, real2, real3,reciprocal1,
                         reciprocal2,reciprocal3));}

;
    }
SWIGINTERN void cbf_positioner_struct_get_rotation_axis(cbf_positioner_struct *self,double *vector1,double *vector2,double *vector3){
     unsigned int reserved;
     reserved = 0;
     {(error_status = cbf_get_rotation_axis (self, reserved,
                                        vector1, vector2, vector3));}
;
    }
SWIGINTERN void cbf_positioner_struct_get_rotation_range(cbf_positioner_struct *self,double *start,double *increment){
       unsigned int reserved;
       reserved = 0;
       {(error_status = cbf_get_rotation_range (self,reserved, start,increment));};
    }
SWIGINTERN void cbf_positioner_struct_rotate_vector(cbf_positioner_struct *self,double ratio,double initial1,double initial2,double initial3,double *final1,double *final2,double *final3){
       unsigned int reserved;
       reserved = 0;
       {(error_status = cbf_rotate_vector (self, reserved, ratio, initial1,
         initial2, initial3, final1, final2, final3));}
;
    }
SWIGINTERN cbf_detector_struct *new_cbf_detector_struct(void){  // Constructor
       // DO NOT CONSTRUCT WITHOUT A CBFHANDLE
       {(error_status = CBF_ARGUMENT);};
       return NULL; /* Should never be executed */
       }
SWIGINTERN void delete_cbf_detector_struct(cbf_detector_struct *self){ // Destructor
       {(error_status = cbf_free_detector(self));};
       }
SWIGINTERN void cbf_detector_struct_get_beam_center(cbf_detector_struct *self,double *index1,double *index2,double *center1,double *center2){
        {(error_status = cbf_get_beam_center(self, index1, index2,
                                       center1, center2));}
;
        }
SWIGINTERN void cbf_detector_struct_get_beam_center_fs(cbf_detector_struct *self,double *indexfast,double *indexslow,double *centerfast,double *centerslow){
        {(error_status = cbf_get_beam_center_fs(self, indexfast, indexslow,
                                       centerfast, centerslow));}
;
        }
SWIGINTERN void cbf_detector_struct_get_beam_center_sf(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_get_beam_center_sf(self, indexslow, indexfast,
                                       centerslow, centerfast));}
;
        }
SWIGINTERN void cbf_detector_struct_get_detector_axes(cbf_detector_struct *self,double *slowaxis1,double *slowaxis2,double *slowaxis3,double *fastaxis1,double *fastaxis2,double *fastaxis3){
       {(error_status = cbf_get_detector_axes(self,
                                    slowaxis1,slowaxis2,slowaxis3,
                                    fastaxis1,fastaxis2,fastaxis3));}

;
   }
SWIGINTERN void cbf_detector_struct_get_detector_axes_fs(cbf_detector_struct *self,double *fastaxis1,double *fastaxis2,double *fastaxis3,double *slowaxis1,double *slowaxis2,double *slowaxis3){
       {(error_status = cbf_get_detector_axes(self,
                                    slowaxis1,slowaxis2,slowaxis3,
                                    fastaxis1,fastaxis2,fastaxis3));}

;
   }
SWIGINTERN void cbf_detector_struct_get_detector_axes_sf(cbf_detector_struct *self,double *slowaxis1,double *slowaxis2,double *slowaxis3,double *fastaxis1,double *fastaxis2,double *fastaxis3){
       {(error_status = cbf_get_detector_axes(self,
                                    slowaxis1,slowaxis2,slowaxis3,
                                    fastaxis1,fastaxis2,fastaxis3));}

;
   }
SWIGINTERN void cbf_detector_struct_get_detector_axis_fast(cbf_detector_struct *self,double *fastaxis1,double *fastaxis2,double *fastaxis3){
       {(error_status = cbf_get_detector_axis_fast(self,
                                    fastaxis1,fastaxis2,fastaxis3));}
;
   }
SWIGINTERN void cbf_detector_struct_get_detector_axis_slow(cbf_detector_struct *self,double *slowaxis1,double *slowaxis2,double *slowaxis3){
       {(error_status = cbf_get_detector_axis_slow(self,
                                    slowaxis1,slowaxis2,slowaxis3));}
;
   }
SWIGINTERN void cbf_detector_struct_get_detector_distance(cbf_detector_struct *self,double *distance){
  {(error_status = cbf_get_detector_distance(self,distance));};
  }
SWIGINTERN void cbf_detector_struct_get_detector_normal(cbf_detector_struct *self,double *normal1,double *normal2,double *normal3){
     {(error_status = cbf_get_detector_normal(self,
                    normal1, normal2, normal3));}
;
   }
SWIGINTERN char const *cbf_detector_struct_get_detector_surface_axes(cbf_detector_struct *self,int index){
    const char * axis_id1;
    const char * axis_id2;
    {(error_status = cbf_get_detector_surface_axes(self,
    &axis_id1, &axis_id2));}
;
    if (index == 0) return axis_id1;
    if (index == 1) return axis_id2;
    return ".";
    }

SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}

SWIGINTERN void cbf_detector_struct_get_inferred_pixel_size(cbf_detector_struct *self,unsigned int axis_number,double *psize){
   {(error_status = cbf_get_inferred_pixel_size(self, axis_number, psize));};
   }
SWIGINTERN void cbf_detector_struct_get_inferred_pixel_size_fs(cbf_detector_struct *self,unsigned int axis_number,double *psize){
   {(error_status = cbf_get_inferred_pixel_size_fs(self, axis_number, psize));};
   }
SWIGINTERN void cbf_detector_struct_get_inferred_pixel_size_sf(cbf_detector_struct *self,unsigned int axis_number,double *psize){
   {(error_status = cbf_get_inferred_pixel_size_sf(self, axis_number, psize));};
   }
SWIGINTERN void cbf_detector_struct_get_pixel_area(cbf_detector_struct *self,double index1,double index2,double *area,double *projected_area){
       {(error_status = cbf_get_pixel_area (self,
                                       index1, index2, area,projected_area));}
;
      }
SWIGINTERN void cbf_detector_struct_get_pixel_area_fs(cbf_detector_struct *self,double indexfast,double indexslow,double *area,double *projected_area){
       {(error_status = cbf_get_pixel_area_fs (self,
                                       indexfast, indexslow, area,projected_area));}
;
      }
SWIGINTERN void cbf_detector_struct_get_pixel_area_sf(cbf_detector_struct *self,double indexslow,double indexfast,double *area,double *projected_area){
       {(error_status = cbf_get_pixel_area_sf (self,
                                       indexslow, indexfast, area,projected_area));}
;
      }
SWIGINTERN void cbf_detector_struct_get_pixel_coordinates(cbf_detector_struct *self,double index1,double index2,double *coordinate1,double *coordinate2,double *coordinate3){
      {(error_status = cbf_get_pixel_coordinates(self, index1, index2,
             coordinate1, coordinate2, coordinate3));}
;
   }
SWIGINTERN void cbf_detector_struct_get_pixel_coordinates_fs(cbf_detector_struct *self,double indexfast,double indexslow,double *coordinate1,double *coordinate2,double *coordinate3){
      {(error_status = cbf_get_pixel_coordinates_fs(self, indexfast, indexslow, coordinate1, coordinate2, coordinate3));};
   }
SWIGINTERN void cbf_detector_struct_get_pixel_coordinates_sf(cbf_detector_struct *self,double indexslow,double indexfast,double *coordinate1,double *coordinate2,double *coordinate3){
      {(error_status = cbf_get_pixel_coordinates_sf(self, indexslow, indexfast, coordinate1, coordinate2, coordinate3));};
   }
SWIGINTERN void cbf_detector_struct_get_pixel_normal(cbf_detector_struct *self,double index1,double index2,double *normal1,double *normal2,double *normal3){
       {(error_status = cbf_get_pixel_normal(self,
                                    index1,index2,normal1,normal2,normal3));}
;
   }
SWIGINTERN void cbf_detector_struct_get_pixel_normal_fs(cbf_detector_struct *self,double indexfast,double indexslow,double *normal1,double *normal2,double *normal3){
       {(error_status = cbf_get_pixel_normal_fs(self,
                                    indexfast,indexslow,normal1,normal2,normal3));}
;
   }
SWIGINTERN void cbf_detector_struct_set_beam_center(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_beam_center(self, indexslow, indexfast,
                                       centerslow, centerfast));}
;
        }
SWIGINTERN void cbf_detector_struct_set_beam_center_fs(cbf_detector_struct *self,double *indexfast,double *indexslow,double *centerfast,double *centerslow){
        {(error_status = cbf_set_beam_center_fs(self, indexfast, indexslow,
                                       centerfast, centerslow));}
;
        }
SWIGINTERN void cbf_detector_struct_set_beam_center_sf(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_beam_center_sf(self, indexslow, indexfast,
                                       centerslow, centerfast));}
;
        }
SWIGINTERN void cbf_detector_struct_set_reference_beam_center(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_reference_beam_center(self, indexslow, indexfast,
                                       centerslow, centerfast));}
;
        }
SWIGINTERN void cbf_detector_struct_set_reference_beam_center_fs(cbf_detector_struct *self,double *indexfast,double *indexslow,double *centerfast,double *centerslow){
        {(error_status = cbf_set_reference_beam_center_fs(self, indexfast, indexslow,
                                       centerfast, centerslow));}
;
        }
SWIGINTERN void cbf_detector_struct_set_reference_beam_center_sf(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_reference_beam_center_sf(self, indexslow, indexfast,
                                       centerslow, centerfast));}
;
        }
SWIGINTERN cbf_handle_struct *new_cbf_handle_struct(void){  // Constructor
       cbf_handle handle;
       {(error_status = cbf_make_handle(&handle));};
       return handle;
       }
SWIGINTERN void delete_cbf_handle_struct(cbf_handle_struct *self){ // Destructor
       {(error_status = cbf_free_handle(self));};
       }
SWIGINTERN char const *cbf_handle_struct_category_name(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_category_name(self, &result));};
    return result;}
SWIGINTERN char const *cbf_handle_struct_column_name(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_column_name(self, &result));};
    return result;}
SWIGINTERN cbf_detector cbf_handle_struct_construct_detector(cbf_handle_struct *self,unsigned int element_number){
    cbf_detector detector;
    {(error_status = cbf_construct_detector(self,&detector,element_number));};
    return detector;
    }
SWIGINTERN cbf_goniometer cbf_handle_struct_construct_goniometer(cbf_handle_struct *self){
    cbf_goniometer goniometer;
    {(error_status = cbf_construct_goniometer(self,&goniometer));};
    return goniometer;
    }

SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
    int ret = SWIG_OK;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if (!obj)
      return SWIG_TypeError;
    if (alloc)
      *alloc = SWIG_NEWOBJ;
#endif
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
        if (!*cptr)
          ret = SWIG_TypeError;
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return ret;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (!obj)
        return SWIG_TypeError;
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}




SWIGINTERN cbf_positioner cbf_handle_struct_construct_positioner(cbf_handle_struct *self,char const *axis_id){
    cbf_positioner positioner;
    {(error_status = cbf_construct_positioner(self,&positioner,axis_id));};
    return positioner;
    }
SWIGINTERN cbf_detector cbf_handle_struct_construct_reference_detector(cbf_handle_struct *self,unsigned int element_number){
    cbf_detector detector;
    {(error_status = cbf_construct_reference_detector(self,&detector,element_number));};
    return detector;
    }
SWIGINTERN cbf_positioner cbf_handle_struct_construct_reference_positioner(cbf_handle_struct *self,char const *axis_id){
    cbf_positioner positioner;
    {(error_status = cbf_construct_reference_positioner(self,&positioner,axis_id));};
    return positioner;
    }
SWIGINTERN void cbf_handle_struct_count_axis_ancestors(cbf_handle_struct *self,char const *axis_id,int *ancestors){
    unsigned int anc;
    {(error_status = cbf_count_axis_ancestors(self,axis_id,&anc));};
    *ancestors = anc;
    }
SWIGINTERN unsigned int cbf_handle_struct_count_categories(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_categories(self,&result));};
      return result;}

SWIGINTERNINLINE PyObject*
  SWIG_From_unsigned_SS_int  (unsigned int value)
{
  return PyInt_FromSize_t((size_t) value);
}

SWIGINTERN unsigned int cbf_handle_struct_count_columns(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_columns(self,&result));};
      return result;}
SWIGINTERN unsigned int cbf_handle_struct_count_datablocks(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_datablocks(self,&result));};
      return result;}
SWIGINTERN unsigned int cbf_handle_struct_count_elements(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_elements(self,&result));};
      return result;}
SWIGINTERN unsigned int cbf_handle_struct_count_rows(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_rows(self,&result));};
      return result;}
SWIGINTERN char const *cbf_handle_struct_datablock_name(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_datablock_name(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_delete_row(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_delete_row(self,arg));};}
SWIGINTERN void cbf_handle_struct_find_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_category(self,arg));};}
SWIGINTERN char const *cbf_handle_struct_find_category_root(cbf_handle_struct *self,char const *categoryname){
   const char * result;
   {(error_status = cbf_find_category_root(self,categoryname,&result));};
   return result;
}
SWIGINTERN void cbf_handle_struct_find_column(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_find_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_find_nextrow(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_nextrow(self,arg));};}
SWIGINTERN void cbf_handle_struct_find_row(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_row(self,arg));};}
SWIGINTERN char const *cbf_handle_struct_find_tag_category(cbf_handle_struct *self,char const *tagname){
     const char * result;
     {(error_status = cbf_find_tag_category(self,tagname, &result));};
     return result;
     }
SWIGINTERN char const *cbf_handle_struct_find_tag_root(cbf_handle_struct *self,char const *tagname){
   const char* result;
   {(error_status = cbf_find_tag_root(self,tagname,&result));};
   return result;
}
SWIGINTERN void cbf_handle_struct_force_new_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_force_new_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_force_new_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_force_new_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_force_new_saveframe(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_force_new_saveframe(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_3d_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_3d_image(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_3d_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_3d_image_fs(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimfast, (size_t)ndimmid, (size_t)ndimslow));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_3d_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_3d_image_sf(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_3d_image_size(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimmid,int *ndimfast){
        unsigned int reserved;
        size_t inslow, inmid, infast;
        reserved = 0;
        {(error_status = cbf_get_3d_image_size(self,reserved,element_number,&inslow,&inmid,&infast));};
        *ndimslow = (int)inslow; /* FIXME - is that how to convert? */
        *ndimmid = (int)inmid;
        *ndimfast = (int)infast;
        }
SWIGINTERN void cbf_handle_struct_get_3d_image_size_fs(cbf_handle_struct *self,unsigned int element_number,int *ndimfast,int *ndimmid,int *ndimslow){
        unsigned int reserved;
        size_t inslow, inmid, infast;
        reserved = 0;
        {(error_status = cbf_get_3d_image_size_fs(self,reserved,element_number,&infast,&inmid,&inslow));};
        *ndimslow = (int)inslow; /* FIXME - is that how to convert? */
        *ndimmid = (int)inmid;
        *ndimfast = (int)infast;
        }
SWIGINTERN void cbf_handle_struct_get_3d_image_size_sf(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimmid,int *ndimfast){
        unsigned int reserved;
        size_t inslow, inmid, infast;
        reserved = 0;
        {(error_status = cbf_get_3d_image_size_sf(self,reserved,element_number,&inslow,&inmid,&infast));};
        *ndimslow = (int)inslow; /* FIXME - is that how to convert? */
        *ndimmid = (int)inmid;
        *ndimfast = (int)infast;
        }
SWIGINTERN char const *cbf_handle_struct_get_axis_ancestor(cbf_handle_struct *self,char const *axis_id,int ancestor_index){
    const char* anc;
    {(error_status = cbf_get_axis_ancestor(self,axis_id,
    (unsigned int)ancestor_index,&anc));}
;
    return anc;
    }
SWIGINTERN char const *cbf_handle_struct_get_axis_depends_on(cbf_handle_struct *self,char const *axis_id){
    const char* dep_on;
    {(error_status = cbf_get_axis_depends_on(self,axis_id,
    &dep_on));}
;
    return dep_on;
    }
SWIGINTERN char const *cbf_handle_struct_get_axis_equipment(cbf_handle_struct *self,char const *axis_id){
    const char* equip;
    {(error_status = cbf_get_axis_equipment(self,axis_id,
    &equip));}
;
    return equip;
    }
SWIGINTERN char const *cbf_handle_struct_get_axis_equipment_component(cbf_handle_struct *self,char const *axis_id){
    const char* equip_comp;
    {(error_status = cbf_get_axis_equipment_component(self,axis_id,
    &equip_comp));}
;
    return equip_comp;
    }
SWIGINTERN void cbf_handle_struct_get_axis_offset(cbf_handle_struct *self,char const *axis_id,double *offset1,double *offset2,double *offset3){
    {(error_status = cbf_get_axis_offset(self,axis_id,
    offset1, offset2,offset3));}
;
    }
SWIGINTERN void cbf_handle_struct_get_axis_poise(cbf_handle_struct *self,double ratio,double *vector1,double *vector2,double *vector3,double *offset1,double *offset2,double *offset3,double *angle,char const *axis_id,char const *frame_id){
        {(error_status = cbf_get_axis_poise(self, ratio,
          vector1, vector2, vector3,
          offset1, offset2, offset3, angle,
          axis_id, frame_id));}


;
      }
SWIGINTERN void cbf_handle_struct_get_axis_reference_poise(cbf_handle_struct *self,double *vector1,double *vector2,double *vector3,double *offset1,double *offset2,double *offset3,char const *axis_id){
        {(error_status = cbf_get_axis_reference_poise(self,
          vector1, vector2, vector3,
          offset1, offset2, offset3,
          axis_id));}


;
      }
SWIGINTERN void cbf_handle_struct_get_axis_rotation(cbf_handle_struct *self,char const *axis_id,double *rotation){
    {(error_status = cbf_get_axis_rotation(self,axis_id,
    rotation));}
;
    }
SWIGINTERN char const *cbf_handle_struct_get_axis_rotation_axis(cbf_handle_struct *self,char const *axis_id){
    const char* rot_axis;
    {(error_status = cbf_get_axis_rotation_axis(self,axis_id,
    &rot_axis));}
;
    return rot_axis;
    }
SWIGINTERN void cbf_handle_struct_get_axis_setting(cbf_handle_struct *self,char const *axis_id,double *start,double *increment){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_axis_setting(self,reserved,axis_id,
                         start,increment));}
;
        }
SWIGINTERN char const *cbf_handle_struct_get_axis_type(cbf_handle_struct *self,char const *axis_id){
    cbf_axis_type axis_type;
    {(error_status = cbf_get_axis_type(self,axis_id,
    &axis_type));}
;
    if (axis_type == CBF_TRANSLATION_AXIS) return "translation";
    if (axis_type == CBF_ROTATION_AXIS) return "rotation";
    return "general";
    }
SWIGINTERN void cbf_handle_struct_get_axis_vector(cbf_handle_struct *self,char const *axis_id,double *vector1,double *vector2,double *vector3){
    {(error_status = cbf_get_axis_vector(self,axis_id,
    vector1, vector2,vector3));}
;
    }
SWIGINTERN void cbf_handle_struct_get_bin_sizes(cbf_handle_struct *self,int element_number,double *slowbinsize,double *fastbinsize){
    {(error_status = cbf_get_bin_sizes (self, (unsigned int)element_number, slowbinsize, fastbinsize));};
  }
SWIGINTERN char const *cbf_handle_struct_get_crystal_id(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_crystal_id(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_get_datestamp(cbf_handle_struct *self,int *year,int *month,int *day,int *hour,int *minute,double *second,int *timezone){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_datestamp(self,reserved,
              year,month,day,hour,minute,second,timezone));}
;
        }
SWIGINTERN cbf_handle cbf_handle_struct_get_dictionary(cbf_handle_struct *self){
   cbf_handle temp;
   {(error_status = cbf_get_dictionary(self,&temp));};
   return temp;
}
SWIGINTERN char const *cbf_handle_struct_get_diffrn_id(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_diffrn_id(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_get_divergence(cbf_handle_struct *self,double *div_x_source,double *div_y_source,double *div_x_y_source){
       {(error_status = cbf_get_divergence(self,
                                     div_x_source,
                                     div_y_source,
                                     div_x_y_source));}


;
       }
SWIGINTERN double cbf_handle_struct_get_doublevalue(cbf_handle_struct *self){
     double result;
       {(error_status = cbf_get_doublevalue(self,&result));};
       return result;}
SWIGINTERN char const *cbf_handle_struct_get_element_id(cbf_handle_struct *self,unsigned int element_number){
       const char * result;
       {(error_status = cbf_get_element_id (self, element_number, &result));};
       return result;
       }
SWIGINTERN void cbf_handle_struct_get_element_number(cbf_handle_struct *self){
        {(error_status = CBF_NOTIMPLEMENTED);};}
SWIGINTERN void cbf_handle_struct_get_gain(cbf_handle_struct *self,unsigned int element_number,double *gain,double *gain_esd){
        {(error_status = cbf_get_gain (self, element_number, gain, gain_esd));};
        }
SWIGINTERN void cbf_handle_struct_get_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_image(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_image_fs(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimfast, (size_t)ndimslow));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_image_sf(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_image_size(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimfast){
        unsigned int reserved;
        size_t inslow, infast;
        reserved = 0;
        {(error_status = cbf_get_image_size(self,reserved,element_number,&inslow,&infast));};
        *ndimslow = (int)inslow;
        *ndimfast = (int)infast;
        }
SWIGINTERN void cbf_handle_struct_get_image_size_fs(cbf_handle_struct *self,unsigned int element_number,int *ndimfast,int *ndimslow){
        unsigned int reserved;
        size_t infast, inslow;
        reserved = 0;
        {(error_status = cbf_get_image_size_fs(self,reserved,element_number,&infast,&inslow));};
        *ndimfast = (int)infast; /* FIXME - is that how to convert? */
        *ndimslow = (int)inslow;
        }
SWIGINTERN void cbf_handle_struct_get_image_size_sf(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimfast){
        unsigned int reserved;
        size_t inslow, infast;
        reserved = 0;
        {(error_status = cbf_get_image_size(self,reserved,element_number,&inslow,&infast));};
        *ndimslow = (int)inslow;
        *ndimfast = (int)infast;
        }
SWIGINTERN void cbf_handle_struct_get_integerarray_as_string(cbf_handle_struct *self,char **s,int *slen){
        int binary_id, elsigned, elunsigned;
        size_t elements, elements_read, elsize;
        int minelement, maxelement;
        unsigned int compression;
        void * array;
        *slen = 0; /* Initialise in case of problems */
        {(error_status = cbf_get_integerarrayparameters(self, &compression,
               &binary_id, &elsize, &elsigned, &elunsigned,
               &elements, &minelement, &maxelement));}

;

        if ((array=malloc(elsize*elements))) {
              /* cbf_failnez (cbf_select_column(cbf,colnum)) */
               {(error_status = cbf_get_integerarray(self, &binary_id,
                            (void *)array, elsize, elsigned,
                            elements, &elements_read));}

;

         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*elements;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement){
        unsigned int  comp;
        size_t elsiz, elem;
        {(error_status = cbf_get_integerarrayparameters(self,
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem,
          minelement, maxelement));}

;
        *compression = comp; /* FIXME - does this convert in C? */
        *elsize = elsiz;
        *elements = elem;
        }
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters_wdims(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_integerarrayparameters_wdims(self,
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem,
          minelement, maxelement, &byteorder,&df,&dm,&ds,&pd ));}

;
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;

        }
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters_wdims_fs(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_integerarrayparameters_wdims_fs(self,
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem,
          minelement, maxelement, &byteorder,&df,&dm,&ds,&pd ));}

;
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;

        }
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters_wdims_sf(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement,char **bo,int *bolen,int *dimslow,int *dimmid,int *dimfast,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_integerarrayparameters_wdims_sf(self,
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem,
          minelement, maxelement, &byteorder,&ds,&dm,&df,&pd ));}

;
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;

        }
SWIGINTERN int cbf_handle_struct_get_integervalue(cbf_handle_struct *self){
     int result;
       {(error_status = cbf_get_integervalue(self,&result));};
       return result;}
SWIGINTERN void cbf_handle_struct_get_integration_time(cbf_handle_struct *self,double *time){
        unsigned int reserved;
        double tim;
        reserved = 0;
        {(error_status = cbf_get_integration_time(self,reserved,&tim));};
        *time = tim;
        }
SWIGINTERN void cbf_handle_struct_get_orientation_matrix(cbf_handle_struct *self,double *m0,double *m1,double *m2,double *m3,double *m4,double *m5,double *m6,double *m7,double *m8){
        double m[9];
        {(error_status = cbf_get_orientation_matrix(self,m));};
        *m0 = m[0]; *m1=m[1] ; *m2=m[2] ;
        *m3 = m[3]; *m4=m[4] ; *m5=m[5] ;
        *m6 = m[6]; *m7=m[7] ; *m8=m[8] ;
        }
SWIGINTERN void cbf_handle_struct_get_overload(cbf_handle_struct *self,unsigned int element_number,double *overload){
        {(error_status = cbf_get_overload(self,element_number,overload));};
        }
SWIGINTERN void cbf_handle_struct_get_pixel_size(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double *psize){
        {(error_status = cbf_get_pixel_size(self,
                                       element_number,
                                       axis_number,
                                       psize));}


;
    }
SWIGINTERN void cbf_handle_struct_get_pixel_size_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double *psize){
        {(error_status = cbf_get_pixel_size_fs(self,
                                       element_number,
                                       axis_number,
                                       psize));}


;
    }
SWIGINTERN void cbf_handle_struct_get_pixel_size_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double *psize){
        {(error_status = cbf_get_pixel_size_sf(self,
                                       element_number,
                                       axis_number,
                                       psize));}


;
    }
SWIGINTERN void cbf_handle_struct_get_polarization(cbf_handle_struct *self,double *in1,double *in2){
        {(error_status = cbf_get_polarization (self, in1, in2));};
     }
SWIGINTERN void cbf_handle_struct_get_real_3d_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimmid,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_real_3d_image(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_real_3d_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_real_3d_image_fs(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimfast, (size_t)ndimmid, (size_t)ndimslow));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_real_3d_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimmid,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_real_3d_image_sf(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_real_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_real_image(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_real_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimfast,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_real_image_fs(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimfast, (size_t)ndimslow));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_real_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_real_image_sf(self,
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimfast));}


;
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_realarray_as_string(cbf_handle_struct *self,char **s,int *slen){
        int binary_id;
        size_t elements, elements_read, elsize;
        unsigned int compression;
        void * array;
        *slen = 0; /* Initialise in case of problems */
        {(error_status = cbf_get_realarrayparameters(self, &compression,
               &binary_id, &elsize,
               &elements));}

;

        if ((array=malloc(elsize*elements))) {
              /* cbf_failnez (cbf_select_column(cbf,colnum)) */
               {(error_status = cbf_get_realarray(self, &binary_id,
                            (void *)array, elsize,
                            elements, &elements_read));}

;

         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*elements;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_realarrayparameters(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements){
        unsigned int  comp;
        size_t elsiz, elem;
        {(error_status = cbf_get_realarrayparameters(self,
                                 &comp ,binary_id, &elsiz, &elem ));}
;
        *compression = comp; /* FIXME - does this convert in C? */
        *elsize = elsiz;
        *elements = elem;
        }
SWIGINTERN void cbf_handle_struct_get_realarrayparameters_wdims(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_realarrayparameters_wdims(self,
         &comp,binary_id, &elsiz, &elem,
         &byteorder,&df,&dm,&ds,&pd ));}

;
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;

        }
SWIGINTERN void cbf_handle_struct_get_realarrayparameters_wdims_fs(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_realarrayparameters_wdims_fs(self,
         &comp,binary_id, &elsiz, &elem,
         &byteorder,&df,&dm,&ds,&pd ));}

;
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;

        }
SWIGINTERN void cbf_handle_struct_get_realarrayparameters_wdims_sf(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements,char **bo,int *bolen,int *dimslow,int *dimmid,int *dimfast,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_realarrayparameters_wdims_sf(self,
         &comp,binary_id, &elsiz, &elem,
         &byteorder,&ds,&dm,&df,&pd ));}

;
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;

        }
SWIGINTERN void cbf_handle_struct_get_reciprocal_cell(cbf_handle_struct *self,double *astar,double *bstar,double *cstar,double *alphastar,double *betastar,double *gammastar){
     double rcell[6];
     {(error_status = cbf_get_reciprocal_cell(self,rcell,NULL));};
    *astar =      rcell[0];
    *bstar =      rcell[1];
    *cstar =      rcell[2];
    *alphastar =  rcell[3];
    *betastar =   rcell[4];
    *gammastar =  rcell[5];
   }
SWIGINTERN void cbf_handle_struct_get_reciprocal_cell_esd(cbf_handle_struct *self,double *a_esd,double *b_esd,double *c_esd,double *alpha_esd,double *beta_esd,double *gamma_esd){
     double cell_esd[6];
     {(error_status = cbf_get_reciprocal_cell(self,NULL,cell_esd));};
     *a_esd = cell_esd[0];
     *b_esd = cell_esd[1];
     *c_esd = cell_esd[2];
     *alpha_esd = cell_esd[3];
     *beta_esd = cell_esd[4];
     *gamma_esd = cell_esd[5];
   }
SWIGINTERN void cbf_handle_struct_get_timestamp(cbf_handle_struct *self,double *time,int *timezone){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_timestamp(self,reserved,time,timezone));};
        }
SWIGINTERN char const *cbf_handle_struct_get_typeofvalue(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_typeofvalue(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_get_unit_cell(cbf_handle_struct *self,double *a,double *b,double *c,double *alpha,double *beta,double *gamma){
     double cell[6];
     {(error_status = cbf_get_unit_cell(self,cell,NULL));};
     *a = cell[0];
     *b = cell[1];
     *c = cell[2];
     *alpha = cell[3];
     *beta = cell[4];
     *gamma = cell[5];
   }
SWIGINTERN void cbf_handle_struct_get_unit_cell_esd(cbf_handle_struct *self,double *a_esd,double *b_esd,double *c_esd,double *alpha_esd,double *beta_esd,double *gamma_esd){
     double cell_esd[6];
     {(error_status = cbf_get_unit_cell(self,NULL,cell_esd));};
     *a_esd = cell_esd[0];
     *b_esd = cell_esd[1];
     *c_esd = cell_esd[2];
     *alpha_esd = cell_esd[3];
     *beta_esd = cell_esd[4];
     *gamma_esd = cell_esd[5];
   }
SWIGINTERN char const *cbf_handle_struct_get_value(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_value(self, &result));};
    return result;}
SWIGINTERN double cbf_handle_struct_get_wavelength(cbf_handle_struct *self){
     double result;
       {(error_status = cbf_get_wavelength(self,&result));};
       return result;}
SWIGINTERN void cbf_handle_struct_insert_row(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_insert_row(self,arg));};}
SWIGINTERN void cbf_handle_struct_new_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_new_column(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_new_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_new_row(cbf_handle_struct *self){
      {(error_status = cbf_new_row(self));};}
SWIGINTERN void cbf_handle_struct_new_saveframe(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_saveframe(self,arg));};}
SWIGINTERN void cbf_handle_struct_next_category(cbf_handle_struct *self){
      {(error_status = cbf_next_category(self));};}
SWIGINTERN void cbf_handle_struct_next_column(cbf_handle_struct *self){
      {(error_status = cbf_next_column(self));};}
SWIGINTERN void cbf_handle_struct_next_datablock(cbf_handle_struct *self){
      {(error_status = cbf_next_datablock(self));};}
SWIGINTERN void cbf_handle_struct_next_row(cbf_handle_struct *self){
      {(error_status = cbf_next_row(self));};}
SWIGINTERN void cbf_handle_struct_read_file(cbf_handle_struct *self,char *filename,int headers){
       /* CBFlib needs a stream that will remain open
          hence DO NOT open from python */
       FILE *stream;
       if ( ! ( stream = fopen (filename, "rb")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
         {(error_status = cbf_read_file(self, stream, headers));};
    }
       }
SWIGINTERN void cbf_handle_struct_read_template(cbf_handle_struct *self,char *filename){
       /* CBFlib needs a stream that will remain open
        hence DO NOT open from python */
       FILE *stream;
       if ( ! ( stream = fopen (filename, "rb")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
        {(error_status = cbf_read_template (self, stream));}; }
    }
SWIGINTERN void cbf_handle_struct_read_widefile(cbf_handle_struct *self,char *filename,int headers){
       /* CBFlib needs a stream that will remain open
          hence DO NOT open from python */
       FILE *stream;
       if ( ! ( stream = fopen (filename, "rb")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
         {(error_status = cbf_read_widefile(self, stream, headers));};
    }
       }
SWIGINTERN void cbf_handle_struct_remove_category(cbf_handle_struct *self){
      {(error_status = cbf_remove_category(self));};}
SWIGINTERN void cbf_handle_struct_remove_column(cbf_handle_struct *self){
      {(error_status = cbf_remove_column(self));};}
SWIGINTERN void cbf_handle_struct_remove_datablock(cbf_handle_struct *self){
      {(error_status = cbf_remove_datablock(self));};}
SWIGINTERN void cbf_handle_struct_remove_row(cbf_handle_struct *self){
      {(error_status = cbf_remove_row(self));};}
SWIGINTERN void cbf_handle_struct_remove_saveframe(cbf_handle_struct *self){
      {(error_status = cbf_remove_saveframe(self));};}
SWIGINTERN void cbf_handle_struct_require_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_require_category(self,arg));};}
SWIGINTERN char const *cbf_handle_struct_require_category_root(cbf_handle_struct *self,char const *categoryname){
  const char* result;
  {(error_status = cbf_require_category_root(self,categoryname, &result));};
  return result;
}
SWIGINTERN void cbf_handle_struct_require_column(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_require_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_require_column_doublevalue(cbf_handle_struct *self,char const *columnname,double *number,double const defaultvalue){
    {(error_status = cbf_require_column_doublevalue(self,
                  columnname,number,defaultvalue));}
;
    }
SWIGINTERN void cbf_handle_struct_require_column_integervalue(cbf_handle_struct *self,char const *columnname,int *number,int const defaultvalue){
    {(error_status = cbf_require_column_integervalue(self,
           columnname, number,defaultvalue));}
;
    }
SWIGINTERN char const *cbf_handle_struct_require_column_value(cbf_handle_struct *self,char const *columnname,char const *defaultvalue){
   const char * result;
   {(error_status = cbf_require_column_value(self,columnname,
                                    &result,defaultvalue));}
;
   return result;
}
SWIGINTERN void cbf_handle_struct_require_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_require_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_require_doublevalue(cbf_handle_struct *self,double *number,double defaultvalue){
   {(error_status = cbf_require_doublevalue(self,number,defaultvalue));};
}
SWIGINTERN void cbf_handle_struct_require_integervalue(cbf_handle_struct *self,int *number,int thedefault){

     {(error_status = cbf_require_integervalue(self,number,thedefault));};

     }
SWIGINTERN cbf_detector cbf_handle_struct_require_reference_detector(cbf_handle_struct *self,unsigned int element_number){
    cbf_detector detector;
    {(error_status = cbf_require_reference_detector(self,&detector,element_number));};
    return detector;
    }
SWIGINTERN char const *cbf_handle_struct_require_tag_root(cbf_handle_struct *self,char const *tagname){
 const char* result;
 {(error_status = cbf_require_tag_root(self,tagname,&result));};
 return result;
 }
SWIGINTERN char const *cbf_handle_struct_require_value(cbf_handle_struct *self,char const *defaultvalue){
     const char * result;
     {(error_status = cbf_require_value(self, &result, defaultvalue));};
     return result;
    }
SWIGINTERN void cbf_handle_struct_reset_category(cbf_handle_struct *self){
      {(error_status = cbf_reset_category(self));};}
SWIGINTERN void cbf_handle_struct_reset_datablock(cbf_handle_struct *self){
      {(error_status = cbf_reset_datablock(self));};}
SWIGINTERN void cbf_handle_struct_reset_datablocks(cbf_handle_struct *self){
      {(error_status = cbf_reset_datablocks(self));};}
SWIGINTERN void cbf_handle_struct_reset_saveframe(cbf_handle_struct *self){
      {(error_status = cbf_reset_saveframe(self));};}
SWIGINTERN CBF_NODETYPE cbf_handle_struct_rewind_blockitem(cbf_handle_struct *self){
     CBF_NODETYPE result;
       {(error_status = cbf_rewind_blockitem(self,&result));};
       return result;}
SWIGINTERN void cbf_handle_struct_rewind_category(cbf_handle_struct *self){
      {(error_status = cbf_rewind_category(self));};}
SWIGINTERN void cbf_handle_struct_rewind_column(cbf_handle_struct *self){
      {(error_status = cbf_rewind_column(self));};}
SWIGINTERN void cbf_handle_struct_rewind_datablock(cbf_handle_struct *self){
      {(error_status = cbf_rewind_datablock(self));};}
SWIGINTERN void cbf_handle_struct_rewind_row(cbf_handle_struct *self){
      {(error_status = cbf_rewind_row(self));};}
SWIGINTERN void cbf_handle_struct_rewind_saveframe(cbf_handle_struct *self){
      {(error_status = cbf_rewind_saveframe(self));};}
SWIGINTERN unsigned int cbf_handle_struct_row_number(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_row_number(self,&result));};
      return result;}
SWIGINTERN void cbf_handle_struct_select_category(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_select_column(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_select_datablock(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_select_row(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_row(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_3d_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_3d_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t) ndimmid, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_3d_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_3d_image_fs (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimfast, (size_t) ndimmid, (size_t)ndimslow));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_3d_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_3d_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t) ndimmid, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_axis_setting(cbf_handle_struct *self,char const *axis_id,double start,double increment){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_axis_setting(self,reserved,
                         axis_id,start,increment));}
;
        }
SWIGINTERN void cbf_handle_struct_set_bin_sizes(cbf_handle_struct *self,int element_number,double slowbinsize_in,double fastbinsize_in){
     {(error_status = cbf_set_bin_sizes(self,element_number,slowbinsize_in,fastbinsize_in));};
   }
SWIGINTERN void cbf_handle_struct_set_category_root(cbf_handle_struct *self,char const *categoryname,char const *categoryroot){
   {(error_status = cbf_set_category_root(self,categoryname,categoryroot));};
}
SWIGINTERN void cbf_handle_struct_set_crystal_id(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_crystal_id(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_current_timestamp(cbf_handle_struct *self,int timezone){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_current_timestamp(self,reserved,timezone));};
        }
SWIGINTERN void cbf_handle_struct_set_datablockname(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_datablockname(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_datestamp(cbf_handle_struct *self,int year,int month,int day,int hour,int minute,double second,int timezone,double precision){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_datestamp(self,reserved,
              year,month,day,hour,minute,second,timezone,precision));}
;
        }
SWIGINTERN void cbf_handle_struct_set_dictionary(cbf_handle_struct *self,cbf_handle other){
   {(error_status = cbf_set_dictionary(self,other));};
}
SWIGINTERN void cbf_handle_struct_set_diffrn_id(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_diffrn_id(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_divergence(cbf_handle_struct *self,double div_x_source,double div_y_source,double div_x_y_source){
      {(error_status = cbf_set_divergence (self, div_x_source,
                              div_y_source,div_x_y_source));}
;
      }
SWIGINTERN void cbf_handle_struct_set_doublevalue(cbf_handle_struct *self,char const *format,double number){
        {(error_status = cbf_set_doublevalue(self,format,number));};}
SWIGINTERN void cbf_handle_struct_set_gain(cbf_handle_struct *self,unsigned int element_number,double gain,double gain_esd){
        {(error_status = cbf_set_gain (self, element_number, gain, gain_esd));};
        }
SWIGINTERN void cbf_handle_struct_set_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimfast,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimfast, (size_t)ndimslow));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integerarray(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements){
        /* safety check on args */
        size_t els, ele;
        void *array;
        if(len == elsize*elements){
           array = data;
           els = elsize;
           ele = elements;
           {(error_status = cbf_set_integerarray (self, compression, binary_id,
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integerarray_wdims(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?bolen:14] = 0;
           {(error_status = cbf_set_integerarray_wdims (self, compression, binary_id,
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements, (const char *)byteorder,
           (size_t)dimfast, (size_t)dimmid, (size_t)dimslow, (size_t)padding));}

;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integerarray_wdims_fs(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?bolen:14] = 0;
           {(error_status = cbf_set_integerarray_wdims_fs (self, compression, binary_id,
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements, (const char *)byteorder,
           (size_t)dimfast, (size_t)dimmid, (size_t)dimslow, (size_t)padding));}

;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integerarray_wdims_sf(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements,char *bo,int bolen,int dimslow,int dimmid,int dimfast,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?bolen:14] = 0;
           {(error_status = cbf_set_integerarray_wdims_sf (self, compression, binary_id,
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements, (const char *)byteorder,
           (size_t)dimslow, (size_t)dimmid, (size_t)dimfast, (size_t)padding));}

;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integervalue(cbf_handle_struct *self,int number){
        {(error_status = cbf_set_integervalue(self,number));};}
SWIGINTERN void cbf_handle_struct_set_integration_time(cbf_handle_struct *self,double time){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_integration_time(self,reserved,time));};
        }
SWIGINTERN void cbf_handle_struct_set_orientation_matrix(cbf_handle_struct *self,double m0,double m1,double m2,double m3,double m4,double m5,double m6,double m7,double m8){
        double m[9];
        m[0] = m0; m[1]=m1 ; m[2]=m2 ;
        m[3] = m3; m[4]=m4 ; m[5]=m5 ;
        m[6] = m6; m[7]=m7 ; m[8]=m8 ;
        {(error_status = cbf_get_orientation_matrix(self,m));};
        }
SWIGINTERN void cbf_handle_struct_set_overload(cbf_handle_struct *self,unsigned int element_number,double overload){
        {(error_status = cbf_set_overload(self,element_number,overload));};
        }
SWIGINTERN void cbf_handle_struct_set_pixel_size(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double psize){
         {(error_status = cbf_set_pixel_size(self,
                                        element_number,
                                        axis_number,
                                        psize));}


;
     }
SWIGINTERN void cbf_handle_struct_set_pixel_size_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double psize){
         {(error_status = cbf_set_pixel_size_fs(self,
                                        element_number,
                                        axis_number,
                                        psize));}


;
     }
SWIGINTERN void cbf_handle_struct_set_pixel_size_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double psize){
         {(error_status = cbf_set_pixel_size_sf(self,
                                        element_number,
                                        axis_number,
                                        psize));}


;
     }
SWIGINTERN void cbf_handle_struct_set_polarization(cbf_handle_struct *self,double polarizn_source_ratio,double polarizn_source_norm){
         {(error_status = cbf_set_polarization(self,
                         polarizn_source_ratio,
                         polarizn_source_norm));}

;
     }
SWIGINTERN void cbf_handle_struct_set_real_3d_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_3d_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_real_3d_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimfast,int ndimmid,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_3d_image_fs (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimfast, (size_t)ndimmid, (size_t)ndimslow));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_real_3d_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_3d_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_real_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_real_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimfast,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_image_fs (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimfast, (size_t)ndimslow));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_real_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimfast));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_realarray(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements){
        /* safety check on args */
        size_t els, ele;
        void *array;
        if(len == elsize*elements){
           array = data;
           els = elsize;
           ele = elements;
           {(error_status = cbf_set_realarray (self, compression, binary_id,
           (void *) data,  (size_t) elsize, (size_t) elements));}
;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_realarray_wdims(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?bolen:14] = 0;
           {(error_status = cbf_set_realarray_wdims (self, compression, binary_id,
           (void *) data,  (size_t) elsize, (size_t) elements, (const char *)byteorder,
           (size_t)dimfast, (size_t)dimmid, (size_t)dimslow, (size_t)padding));}

;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_realarray_wdims_fs(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?bolen:14] = 0;
           {(error_status = cbf_set_realarray_wdims_fs (self, compression, binary_id,
           (void *) data,  (size_t) elsize, (size_t) elements, (const char *)byteorder,
           (size_t) dimfast, (size_t) dimmid, (size_t) dimslow, (size_t)padding));}

;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_realarray_wdims_sf(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements,char *bo,int bolen,int dimslow,int dimmid,int dimfast,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?bolen:14] = 0;
           {(error_status = cbf_set_realarray_wdims_sf (self, compression, binary_id,
           (void *) data,  (size_t) elsize, (size_t) elements, (const char *)byteorder,
           (size_t) dimslow, (size_t) dimmid, (size_t) dimfast, (size_t)padding));}

;
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_reciprocal_cell(cbf_handle_struct *self,double cell[6]){
     {(error_status = cbf_set_reciprocal_cell(self,cell,NULL));};
   }
SWIGINTERN void cbf_handle_struct_set_reciprocal_cell_esd(cbf_handle_struct *self,double cell_esd[6]){
     {(error_status = cbf_set_reciprocal_cell(self,NULL,cell_esd));};
   }
SWIGINTERN void cbf_handle_struct_set_saveframename(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_saveframename(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_tag_category(cbf_handle_struct *self,char const *tagname,char const *categoryname_in){
     {(error_status = cbf_set_tag_category(self,tagname, categoryname_in));};
     }
SWIGINTERN void cbf_handle_struct_set_tag_root(cbf_handle_struct *self,char const *tagname,char const *tagroot_in){
   {(error_status = cbf_set_tag_root(self,tagname,tagroot_in));};
}
SWIGINTERN void cbf_handle_struct_set_timestamp(cbf_handle_struct *self,double time,int timezone,double precision){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_timestamp(self,reserved,time,timezone,precision));};
        }
SWIGINTERN void cbf_handle_struct_set_typeofvalue(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_typeofvalue(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_unit_cell(cbf_handle_struct *self,double cell[6]){
     {(error_status = cbf_set_unit_cell(self,cell,NULL));};
   }
SWIGINTERN void cbf_handle_struct_set_unit_cell_esd(cbf_handle_struct *self,double cell_esd[6]){
     {(error_status = cbf_set_unit_cell(self,NULL,cell_esd));};
   }
SWIGINTERN void cbf_handle_struct_set_value(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_value(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_wavelength(cbf_handle_struct *self,double wavelength){
        {(error_status = cbf_set_wavelength(self,wavelength));};}
SWIGINTERN void cbf_handle_struct_write_file(cbf_handle_struct *self,char const *filename,int ciforcbf,int headers,int encoding){
       FILE *stream;
       int readable;
       /* Make readable false so we can close the file immediately */
       readable = 0;
       if ( ! ( stream = fopen (filename, "w+b")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
        {(error_status = cbf_write_file(self, stream, readable,
                    ciforcbf, headers, encoding));}
;
        fclose(stream);
        }
       }
SWIGINTERN void cbf_handle_struct_write_widefile(cbf_handle_struct *self,char const *filename,int ciforcbf,int headers,int encoding){
       FILE *stream;
       int readable;
       /* Make readable false so we can close the file immediately */
       readable = 0;
       if ( ! ( stream = fopen (filename, "w+b")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
        {(error_status = cbf_write_widefile(self, stream, readable,
                    ciforcbf, headers, encoding));}
;
        fclose(stream);

        }
       }
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_new_doubleArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  doubleArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_doubleArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (doubleArray *)new_doubleArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_doubleArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_doubleArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_doubleArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_doubleArray" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  delete_doubleArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "doubleArray___getitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_doubleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray___getitem__" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "doubleArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (double)doubleArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  size_t arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "doubleArray___setitem__", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_doubleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray___setitem__" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "doubleArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "doubleArray___setitem__" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  doubleArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_doubleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray_cast" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  result = (double *)doubleArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  doubleArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray_frompointer" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = (double *)(argp1);
  result = (doubleArray *)doubleArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_doubleArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *doubleArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_doubleArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *doubleArray_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_intArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  intArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_intArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (intArray *)new_intArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_intArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_intArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_intArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_intArray" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  delete_intArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "intArray___getitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_intArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray___getitem__" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "intArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (int)intArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  size_t arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "intArray___setitem__", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_intArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray___setitem__" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "intArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "intArray___setitem__" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  intArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_intArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray_cast" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  result = (int *)intArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int *arg1 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  intArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray_frompointer" "', argument " "1"" of type '" "int *""'"); 
  }
  arg1 = (int *)(argp1);
  result = (intArray *)intArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_intArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *intArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_intArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *intArray_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_shortArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  shortArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shortArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (shortArray *)new_shortArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_shortArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_shortArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_shortArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_shortArray" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  delete_shortArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  short result;
  
  if (!SWIG_Python_UnpackTuple(args, "shortArray___getitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_shortArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray___getitem__" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "shortArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (short)shortArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_short((short)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  size_t arg2 ;
  short arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  short val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "shortArray___setitem__", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_shortArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray___setitem__" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "shortArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_short(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "shortArray___setitem__" "', argument " "3"" of type '" "short""'");
  } 
  arg3 = (short)(val3);
  shortArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  short *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_shortArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray_cast" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  result = (short *)shortArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_short, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  short *arg1 = (short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  shortArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_short, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray_frompointer" "', argument " "1"" of type '" "short *""'"); 
  }
  arg1 = (short *)(argp1);
  result = (shortArray *)shortArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_shortArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *shortArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_shortArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *shortArray_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_longArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  longArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_longArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (longArray *)new_longArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_longArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_longArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_longArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_longArray" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  delete_longArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  long result;
  
  if (!SWIG_Python_UnpackTuple(args, "longArray___getitem__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_longArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray___getitem__" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "longArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (long)longArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_long((long)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  size_t arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "longArray___setitem__", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_longArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray___setitem__" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "longArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_long(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "longArray___setitem__" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = (long)(val3);
  longArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  long *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_longArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray_cast" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  result = (long *)longArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  long *arg1 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  longArray *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray_frompointer" "', argument " "1"" of type '" "long *""'"); 
  }
  arg1 = (long *)(argp1);
  result = (longArray *)longArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_longArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *longArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_longArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *longArray_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_airy_disk(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double *arg7 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[6] ;
  
  arg7 = &temp7;
  if (!SWIG_Python_UnpackTuple(args, "airy_disk", 6, 6, swig_obj)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "airy_disk" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "airy_disk" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "airy_disk" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "airy_disk" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "airy_disk" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "airy_disk" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    error_status=0;
    airy_disk(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_airy_disk_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double *arg9 = (double *) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  PyObject *swig_obj[8] ;
  
  arg9 = &temp9;
  if (!SWIG_Python_UnpackTuple(args, "airy_disk_volume", 8, 8, swig_obj)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "airy_disk_volume" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "airy_disk_volume" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "airy_disk_volume" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "airy_disk_volume" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "airy_disk_volume" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "airy_disk_volume" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "airy_disk_volume" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(swig_obj[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "airy_disk_volume" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  {
    error_status=0;
    airy_disk_volume(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_cell_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 = (double *) 0 ;
  double temp1[6] ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    if (swig_obj[0] == Py_None) arg1 = NULL;
    else 
    if (!convert_darray(swig_obj[0],temp1,6)) {
      return NULL;
    }
    arg1 = &temp1[0];
  }
  {
    error_status=0;
    compute_cell_volume(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_reciprocal_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double temp1[6] ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    if (swig_obj[0] == Py_None) arg1 = NULL;
    else 
    if (!convert_darray(swig_obj[0],temp1,6)) {
      return NULL;
    }
    arg1 = &temp1[0];
  }
  {
    error_status=0;
    compute_reciprocal_cell(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_local_integer_byte_order(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char **arg1 = (char **) 0 ;
  int *arg2 = (int *) 0 ;
  char *temp1 = 0 ;
  int tempn1 ;
  
  arg1 = &temp1; arg2 = &tempn1;
  if (!SWIG_Python_UnpackTuple(args, "get_local_integer_byte_order", 0, 0, 0)) SWIG_fail;
  {
    error_status=0;
    get_local_integer_byte_order(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg1) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg1,*arg2));
    free(*arg1);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_local_real_byte_order(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char **arg1 = (char **) 0 ;
  int *arg2 = (int *) 0 ;
  char *temp1 = 0 ;
  int tempn1 ;
  
  arg1 = &temp1; arg2 = &tempn1;
  if (!SWIG_Python_UnpackTuple(args, "get_local_real_byte_order", 0, 0, 0)) SWIG_fail;
  {
    error_status=0;
    get_local_real_byte_order(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg1) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg1,*arg2));
    free(*arg1);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_local_real_format(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char **arg1 = (char **) 0 ;
  int *arg2 = (int *) 0 ;
  char *temp1 = 0 ;
  int tempn1 ;
  
  arg1 = &temp1; arg2 = &tempn1;
  if (!SWIG_Python_UnpackTuple(args, "get_local_real_format", 0, 0, 0)) SWIG_fail;
  {
    error_status=0;
    get_local_real_format(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg1) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg1,*arg2));
    free(*arg1);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_matrix_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_a_4__double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_positioner_struct_matrix_set" "', argument " "2"" of type '" "double [3][4]""'"); 
  } 
  arg2 = (double (*)[4])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)4; ++jj) arg1->matrix[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""matrix""' of type '""double [3][4]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""matrix""' of type '""double [3][4]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double (*result)[4] = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (double (*)[4])(double (*)[4]) ((arg1)->matrix);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a_4__double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axis_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  cbf_axis_struct *arg2 = (cbf_axis_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_axis_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axis_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_cbf_axis_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_positioner_struct_axis_set" "', argument " "2"" of type '" "cbf_axis_struct *""'"); 
  }
  arg2 = (cbf_axis_struct *)(argp2);
  if (arg1) (arg1)->axis = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axis_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  cbf_axis_struct *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axis_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (cbf_axis_struct *) ((arg1)->axis);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_axis_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axes_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_axes_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axes_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_axes_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->axes = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axes_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axes_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result =  ((arg1)->axes);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_is_valid_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_matrix_is_valid_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_is_valid_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_matrix_is_valid_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->matrix_is_valid = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_is_valid_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_is_valid_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (int) ((arg1)->matrix_is_valid);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_ratio_used_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_matrix_ratio_used_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_ratio_used_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_matrix_ratio_used_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->matrix_ratio_used = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_ratio_used_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_ratio_used_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (double) ((arg1)->matrix_ratio_used);
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axis_index_limit_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_axis_index_limit_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axis_index_limit_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_axis_index_limit_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->axis_index_limit = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axis_index_limit_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axis_index_limit_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result =  ((arg1)->axis_index_limit);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_cbf_positioner_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_cbf_positioner_struct", 0, 0, 0)) SWIG_fail;
  {
    error_status=0;
    result = (cbf_positioner_struct *)new_cbf_positioner_struct();
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_cbf_positioner_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cbf_positioner_struct" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  {
    error_status=0;
    delete_cbf_positioner_struct(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_goniometer_poise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_get_goniometer_poise", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_goniometer_poise" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_get_goniometer_poise" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    error_status=0;
    cbf_positioner_struct_get_goniometer_poise(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_reciprocal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  PyObject *swig_obj[6] ;
  
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_get_reciprocal", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    error_status=0;
    cbf_positioner_struct_get_reciprocal(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_rotation_axis(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_rotation_axis" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  {
    error_status=0;
    cbf_positioner_struct_get_rotation_axis(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_rotation_range(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_rotation_range" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  {
    error_status=0;
    cbf_positioner_struct_get_rotation_range(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_rotate_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  PyObject *swig_obj[5] ;
  
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  if (!SWIG_Python_UnpackTuple(args, "cbf_positioner_struct_rotate_vector", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    error_status=0;
    cbf_positioner_struct_rotate_vector(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *cbf_positioner_struct_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_cbf_positioner_struct, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *cbf_positioner_struct_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_cbf_detector_struct_positioner_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  cbf_positioner arg2 = (cbf_positioner) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_positioner_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_positioner_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_cbf_positioner_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_positioner_set" "', argument " "2"" of type '" "cbf_positioner""'"); 
  }
  arg2 = (cbf_positioner)(argp2);
  if (arg1) (arg1)->positioner = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_positioner_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  cbf_positioner result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_positioner_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (cbf_positioner) ((arg1)->positioner);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_displacement_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[2] ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_displacement_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_displacement_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    if (swig_obj[1] == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(swig_obj[1],temp2,2)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) *(double *)&arg1->displacement[ii] = *((double *)arg2 + ii);
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""displacement""' of type '""double [2]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_displacement_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_displacement_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (double *)(double *) ((arg1)->displacement);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_increment_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[2] ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_increment_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_increment_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    if (swig_obj[1] == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(swig_obj[1],temp2,2)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) *(double *)&arg1->increment[ii] = *((double *)arg2 + ii);
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""increment""' of type '""double [2]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_increment_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_increment_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (double *)(double *) ((arg1)->increment);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_axes_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_axes_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_axes_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_axes_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->axes = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_axes_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_axes_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result =  ((arg1)->axes);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_index_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  size_t *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_index_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_index_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_size_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_index_set" "', argument " "2"" of type '" "size_t [2]""'"); 
  } 
  arg2 = (size_t *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) *(size_t *)&arg1->index[ii] = *((size_t *)arg2 + ii);
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""index""' of type '""size_t [2]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_index_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_index_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (size_t *)(size_t *) ((arg1)->index);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_cbf_detector_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_cbf_detector_struct", 0, 0, 0)) SWIG_fail;
  {
    error_status=0;
    result = (cbf_detector_struct *)new_cbf_detector_struct();
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_cbf_detector_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cbf_detector_struct" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    delete_cbf_detector_struct(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_beam_center(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_beam_center" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_beam_center(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_beam_center_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_beam_center_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_beam_center_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_beam_center_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_beam_center_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_beam_center_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axes" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axes(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axes_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axes_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axes_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axes_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axes_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axes_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axis_fast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axis_fast" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axis_fast(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axis_slow(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axis_slow" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axis_slow(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_distance" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_distance(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_normal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_normal" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_normal(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_surface_axes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_detector_surface_axes", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_surface_axes" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_detector_surface_axes" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    result = (char *)cbf_detector_struct_get_detector_surface_axes(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_inferred_pixel_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_inferred_pixel_size", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_inferred_pixel_size" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_inferred_pixel_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_detector_struct_get_inferred_pixel_size(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_inferred_pixel_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_inferred_pixel_size_fs", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_inferred_pixel_size_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_inferred_pixel_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_detector_struct_get_inferred_pixel_size_fs(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_inferred_pixel_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_inferred_pixel_size_sf", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_inferred_pixel_size_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_inferred_pixel_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_detector_struct_get_inferred_pixel_size_sf(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_area(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_area", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_area" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_area" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_area" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_area(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_area_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_area_fs", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_area_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_area_fs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_area_fs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_area_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_area_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_area_sf", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_area_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_area_sf" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_area_sf" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_area_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_coordinates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_coordinates", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_coordinates" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_coordinates" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_coordinates" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_coordinates(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_coordinates_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_coordinates_fs", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_coordinates_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_coordinates_fs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_coordinates_fs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_coordinates_fs(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_coordinates_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_coordinates_sf", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_coordinates_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_coordinates_sf" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_coordinates_sf" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_coordinates_sf(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_normal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_normal", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_normal" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_normal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_normal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_normal(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_normal_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!SWIG_Python_UnpackTuple(args, "cbf_detector_struct_get_pixel_normal_fs", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_normal_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_normal_fs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_normal_fs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_normal_fs(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_beam_center(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_beam_center" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_beam_center(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_beam_center_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_beam_center_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_beam_center_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_beam_center_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_beam_center_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_beam_center_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_reference_beam_center(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_reference_beam_center" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_reference_beam_center(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_reference_beam_center_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_reference_beam_center_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_reference_beam_center_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_reference_beam_center_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_reference_beam_center_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_reference_beam_center_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *cbf_detector_struct_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_cbf_detector_struct, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *cbf_detector_struct_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_cbf_handle_struct_node_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  cbf_node *arg2 = (cbf_node *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_node_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_node_set" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_cbf_node, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_node_set" "', argument " "2"" of type '" "cbf_node *""'"); 
  }
  arg2 = (cbf_node *)(argp2);
  if (arg1) (arg1)->node = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_node_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  cbf_node *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_node_get" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  result = (cbf_node *) ((arg1)->node);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_node, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_row_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_row_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_row_set" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_row_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->row = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_row_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_row_get" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  result = (int) ((arg1)->row);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_search_row_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_search_row_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_search_row_set" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_search_row_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->search_row = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_search_row_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_search_row_get" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  result = (int) ((arg1)->search_row);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_cbf_handle_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_cbf_handle_struct", 0, 0, 0)) SWIG_fail;
  {
    error_status=0;
    result = (cbf_handle_struct *)new_cbf_handle_struct();
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_handle_struct, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_cbf_handle_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cbf_handle_struct" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    delete_cbf_handle_struct(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_category_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_category_name" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_category_name(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_column_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_column_name" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_column_name(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_detector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  cbf_detector result;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_construct_detector", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_detector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_construct_detector" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (cbf_detector)cbf_handle_struct_construct_detector(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_goniometer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  cbf_goniometer result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_goniometer" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (cbf_goniometer)cbf_handle_struct_construct_goniometer(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_positioner(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  cbf_positioner result;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_construct_positioner", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_positioner" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_construct_positioner" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (cbf_positioner)cbf_handle_struct_construct_positioner(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_reference_detector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  cbf_detector result;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_construct_reference_detector", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_reference_detector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_construct_reference_detector" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (cbf_detector)cbf_handle_struct_construct_reference_detector(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_reference_positioner(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  cbf_positioner result;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_construct_reference_positioner", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_reference_positioner" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_construct_reference_positioner" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (cbf_positioner)cbf_handle_struct_construct_reference_positioner(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_axis_ancestors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_count_axis_ancestors", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_axis_ancestors" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_count_axis_ancestors" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_count_axis_ancestors(arg1,(char const *)arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_categories(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_categories" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_categories(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_columns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_columns" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_columns(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_datablocks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_datablocks" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_datablocks(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_elements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_elements" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_elements(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_rows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_rows" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_rows(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_datablock_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_datablock_name" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_datablock_name(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_delete_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_delete_row", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_delete_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_delete_row" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_delete_row(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_category", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_category_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_category_root", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_category_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_category_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_find_category_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_column", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_column" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_column(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_datablock", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_nextrow(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_nextrow", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_nextrow" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_nextrow" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_nextrow(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_row", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_row" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_row(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_tag_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_tag_category", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_tag_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_tag_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_find_tag_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_tag_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_find_tag_root", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_tag_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_tag_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_find_tag_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_force_new_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_force_new_category", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_force_new_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_force_new_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_force_new_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_force_new_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_force_new_datablock", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_force_new_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_force_new_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_force_new_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_force_new_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_force_new_saveframe", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_force_new_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_force_new_saveframe" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_force_new_saveframe(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[7] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_3d_image_as_string", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[6], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[7] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_3d_image_fs_as_string", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[6], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[7] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_3d_image_sf_as_string", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[6], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_3d_image_size", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_size(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_3d_image_size_fs", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_size_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_3d_image_size_sf", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_size_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_ancestor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_ancestor", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_ancestor" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_ancestor" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_axis_ancestor" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_axis_ancestor(arg1,(char const *)arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_depends_on(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_depends_on", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_depends_on" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_depends_on" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_axis_depends_on(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_equipment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_equipment", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_equipment" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_equipment" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_axis_equipment(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_equipment_component(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_equipment_component", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_equipment_component" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_equipment_component" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_axis_equipment_component(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_offset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_offset", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_offset" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_offset" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_get_axis_offset(arg1,(char const *)arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_poise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  char *arg10 = (char *) 0 ;
  char *arg11 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  int res11 ;
  char *buf11 = 0 ;
  int alloc11 = 0 ;
  PyObject *swig_obj[4] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_poise", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_poise" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_axis_poise" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  res10 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "cbf_handle_struct_get_axis_poise" "', argument " "10"" of type '" "char const *""'");
  }
  arg10 = (char *)(buf10);
  res11 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf11, NULL, &alloc11);
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "cbf_handle_struct_get_axis_poise" "', argument " "11"" of type '" "char const *""'");
  }
  arg11 = (char *)(buf11);
  {
    error_status=0;
    cbf_handle_struct_get_axis_poise(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10,(char const *)arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
  if (alloc11 == SWIG_NEWOBJ) free((char*)buf11);
  return resultobj;
fail:
  if (alloc10 == SWIG_NEWOBJ) free((char*)buf10);
  if (alloc11 == SWIG_NEWOBJ) free((char*)buf11);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_reference_poise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  char *arg8 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_reference_poise", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_reference_poise" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res8 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_get_axis_reference_poise" "', argument " "8"" of type '" "char const *""'");
  }
  arg8 = (char *)(buf8);
  {
    error_status=0;
    cbf_handle_struct_get_axis_reference_poise(arg1,arg2,arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_rotation", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_rotation" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_rotation" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_get_axis_rotation(arg1,(char const *)arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_rotation_axis(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_rotation_axis", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_rotation_axis" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_rotation_axis" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_axis_rotation_axis(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_setting(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_setting", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_setting" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_setting" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_get_axis_setting(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_type", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_type" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_type" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_axis_type(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_axis_vector", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_vector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_vector" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_get_axis_vector(arg1,(char const *)arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_bin_sizes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_bin_sizes", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_bin_sizes" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_bin_sizes" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_bin_sizes(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_crystal_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_crystal_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_crystal_id(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_datestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  double *arg7 = (double *) 0 ;
  int *arg8 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_datestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_datestamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_dictionary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  cbf_handle result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_dictionary" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (cbf_handle)cbf_handle_struct_get_dictionary(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_diffrn_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_diffrn_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_diffrn_id(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_divergence(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_divergence" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_divergence(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (double)cbf_handle_struct_get_doublevalue(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_element_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_element_id", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_element_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_element_id" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_element_id(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_element_number(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_element_number" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_element_number(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_gain(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_gain", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_gain" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_gain" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_gain(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[6] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_image_as_string", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[6] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_image_fs_as_string", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[6] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_image_sf_as_string", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_image_size", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_image_size(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_image_size_fs", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_image_size_fs(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_image_size_sf", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_image_size_sf(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarray_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char **arg2 = (char **) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 = 0 ;
  int tempn2 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2; arg3 = &tempn2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarray_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarray_as_string(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg2) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg2,*arg3));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg2,*arg3));
#endif
    free(*arg2);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  char **arg10 = (char **) 0 ;
  int *arg11 = (int *) 0 ;
  int *arg12 = (int *) 0 ;
  int *arg13 = (int *) 0 ;
  int *arg14 = (int *) 0 ;
  int *arg15 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  char *temp10 = 0 ;
  int tempn10 ;
  int temp12 ;
  int res12 = SWIG_TMPOBJ ;
  int temp13 ;
  int res13 = SWIG_TMPOBJ ;
  int temp14 ;
  int res14 = SWIG_TMPOBJ ;
  int temp15 ;
  int res15 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10; arg11 = &tempn10;
  arg12 = &temp12;
  arg13 = &temp13;
  arg14 = &temp14;
  arg15 = &temp15;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (*arg10) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg10,*arg11));
    free(*arg10);
  }
  if (SWIG_IsTmpObj(res12)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg12)));
  } else {
    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res13)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg13)));
  } else {
    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res14)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg14)));
  } else {
    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res15)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg15)));
  } else {
    int new_flags = SWIG_IsNewObj(res15) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg15), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  char **arg10 = (char **) 0 ;
  int *arg11 = (int *) 0 ;
  int *arg12 = (int *) 0 ;
  int *arg13 = (int *) 0 ;
  int *arg14 = (int *) 0 ;
  int *arg15 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  char *temp10 = 0 ;
  int tempn10 ;
  int temp12 ;
  int res12 = SWIG_TMPOBJ ;
  int temp13 ;
  int res13 = SWIG_TMPOBJ ;
  int temp14 ;
  int res14 = SWIG_TMPOBJ ;
  int temp15 ;
  int res15 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10; arg11 = &tempn10;
  arg12 = &temp12;
  arg13 = &temp13;
  arg14 = &temp14;
  arg15 = &temp15;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (*arg10) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg10,*arg11));
    free(*arg10);
  }
  if (SWIG_IsTmpObj(res12)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg12)));
  } else {
    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res13)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg13)));
  } else {
    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res14)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg14)));
  } else {
    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res15)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg15)));
  } else {
    int new_flags = SWIG_IsNewObj(res15) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg15), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  char **arg10 = (char **) 0 ;
  int *arg11 = (int *) 0 ;
  int *arg12 = (int *) 0 ;
  int *arg13 = (int *) 0 ;
  int *arg14 = (int *) 0 ;
  int *arg15 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  char *temp10 = 0 ;
  int tempn10 ;
  int temp12 ;
  int res12 = SWIG_TMPOBJ ;
  int temp13 ;
  int res13 = SWIG_TMPOBJ ;
  int temp14 ;
  int res14 = SWIG_TMPOBJ ;
  int temp15 ;
  int res15 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10; arg11 = &tempn10;
  arg12 = &temp12;
  arg13 = &temp13;
  arg14 = &temp14;
  arg15 = &temp15;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (*arg10) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg10,*arg11));
    free(*arg10);
  }
  if (SWIG_IsTmpObj(res12)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg12)));
  } else {
    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res13)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg13)));
  } else {
    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res14)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg14)));
  } else {
    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res15)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg15)));
  } else {
    int new_flags = SWIG_IsNewObj(res15) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg15), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (int)cbf_handle_struct_get_integervalue(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integration_time(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integration_time" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integration_time(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_orientation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  double *arg10 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  double temp10 ;
  int res10 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_orientation_matrix" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_orientation_matrix(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_overload(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[2] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_overload", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_overload" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_overload" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_overload(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_pixel_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_pixel_size", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_pixel_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_pixel_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_pixel_size" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    error_status=0;
    cbf_handle_struct_get_pixel_size(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_pixel_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_pixel_size_fs", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_pixel_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_pixel_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_pixel_size_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    error_status=0;
    cbf_handle_struct_get_pixel_size_fs(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_pixel_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject *swig_obj[3] ;
  
  arg4 = &temp4;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_pixel_size_sf", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_pixel_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_pixel_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_pixel_size_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    error_status=0;
    cbf_handle_struct_get_pixel_size_sf(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_polarization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_polarization" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_polarization(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_3d_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[6] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_real_3d_image_as_string", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_real_3d_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_3d_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[6] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_real_3d_image_fs_as_string", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_real_3d_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_3d_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[6] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_real_3d_image_sf_as_string", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[5], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_real_3d_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[5] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_real_image_as_string", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_get_real_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[5] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_real_image_fs_as_string", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_get_real_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[5] ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_get_real_image_sf_as_string", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(swig_obj[2], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[3], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[4], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_get_real_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg3,*arg4));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
#endif
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarray_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char **arg2 = (char **) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 = 0 ;
  int tempn2 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2; arg3 = &tempn2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarray_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarray_as_string(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg2) {
#if PY_VERSION_HEX >= 0x03000000
    resultobj = SWIG_Python_AppendOutput(resultobj, PyBytes_FromStringAndSize(*arg2,*arg3));
#else
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg2,*arg3));
#endif
    free(*arg2);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  int *arg10 = (int *) 0 ;
  int *arg11 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  char *temp6 = 0 ;
  int tempn6 ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int temp10 ;
  int res10 = SWIG_TMPOBJ ;
  int temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6; arg7 = &tempn6;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  arg11 = &temp11;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (*arg6) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg6,*arg7));
    free(*arg6);
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  int *arg10 = (int *) 0 ;
  int *arg11 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  char *temp6 = 0 ;
  int tempn6 ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int temp10 ;
  int res10 = SWIG_TMPOBJ ;
  int temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6; arg7 = &tempn6;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  arg11 = &temp11;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (*arg6) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg6,*arg7));
    free(*arg6);
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  int *arg10 = (int *) 0 ;
  int *arg11 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  char *temp6 = 0 ;
  int tempn6 ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int temp10 ;
  int res10 = SWIG_TMPOBJ ;
  int temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6; arg7 = &tempn6;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  arg11 = &temp11;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (*arg6) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg6,*arg7));
    free(*arg6);
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_reciprocal_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_reciprocal_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_reciprocal_cell(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_reciprocal_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_reciprocal_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_reciprocal_cell_esd(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_timestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_timestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_timestamp(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_typeofvalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_typeofvalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_typeofvalue(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_unit_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_unit_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_unit_cell(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_unit_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject *swig_obj[1] ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_unit_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_unit_cell_esd(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_value(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_wavelength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_wavelength" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (double)cbf_handle_struct_get_wavelength(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_insert_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_insert_row", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_insert_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_insert_row" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_insert_row(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_new_category", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_new_column", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_column" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_column(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_new_datablock", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_new_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_new_saveframe", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_saveframe" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_saveframe(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_column(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_read_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_read_file", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_read_file" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_read_file" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_read_file" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    cbf_handle_struct_read_file(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_read_template(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_read_template", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_read_template" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_read_template" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_read_template(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_read_widefile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_read_widefile", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_read_widefile" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_read_widefile" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_read_widefile" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    cbf_handle_struct_read_widefile(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_column(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_saveframe(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_category", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_require_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_category_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_category_root", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_category_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_category_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_category_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_column", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_require_column(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[3] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_column_doublevalue", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column_doublevalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode4 = SWIG_AsVal_double(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_require_column_doublevalue" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_require_column_doublevalue(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int *arg3 = (int *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[3] ;
  
  arg3 = &temp3;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_column_integervalue", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column_integervalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode4 = SWIG_AsVal_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_require_column_integervalue" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    error_status=0;
    cbf_handle_struct_require_column_integervalue(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_column_value", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column_value" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_require_column_value" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_column_value(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_datablock", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_require_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &temp2;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_doublevalue", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode3 = SWIG_AsVal_double(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_require_doublevalue" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_require_doublevalue(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &temp2;
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_integervalue", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_require_integervalue" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    cbf_handle_struct_require_integervalue(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_reference_detector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  cbf_detector result;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_reference_detector", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_reference_detector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_require_reference_detector" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (cbf_detector)cbf_handle_struct_require_reference_detector(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_tag_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_tag_root", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_tag_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_tag_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_tag_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_require_value", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_value" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_value(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_datablocks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_datablocks" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_datablocks(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_saveframe(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_blockitem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  CBF_NODETYPE result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_blockitem" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (CBF_NODETYPE)cbf_handle_struct_rewind_blockitem(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_column(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_saveframe(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_row_number(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_row_number" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_row_number(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_select_category", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_category" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_category(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_select_column", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_column" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_column(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_select_datablock", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_datablock" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_datablock(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_select_row", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_row" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_row(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_3d_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject *swig_obj[9] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_3d_image", 9, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(swig_obj[8], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_3d_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_3d_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject *swig_obj[9] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_3d_image_fs", 9, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(swig_obj[8], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_3d_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_3d_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject *swig_obj[9] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_3d_image_sf", 9, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(swig_obj[8], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_3d_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_axis_setting(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_axis_setting", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_axis_setting(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_bin_sizes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_bin_sizes", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_bin_sizes(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_category_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_category_root", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_category_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_category_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_set_category_root" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    cbf_handle_struct_set_category_root(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_crystal_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_crystal_id", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_crystal_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_crystal_id" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_crystal_id(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_current_timestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_current_timestamp", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_current_timestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_current_timestamp" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_current_timestamp(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_datablockname(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_datablockname", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_datablockname" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_datablockname" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_datablockname(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_datestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  double arg7 ;
  int arg8 ;
  double arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[9] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_datestamp", 9, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_double(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_double(swig_obj[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_datestamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_dictionary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  cbf_handle arg2 = (cbf_handle) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_dictionary", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_dictionary" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_dictionary" "', argument " "2"" of type '" "cbf_handle""'"); 
  }
  arg2 = (cbf_handle)(argp2);
  {
    error_status=0;
    cbf_handle_struct_set_dictionary(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_diffrn_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_diffrn_id", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_diffrn_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_diffrn_id" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_diffrn_id(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_divergence(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_divergence", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_divergence" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_divergence" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_divergence" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_divergence" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_divergence(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_doublevalue", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_doublevalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_doublevalue" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_set_doublevalue(arg1,(char const *)arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_gain(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_gain", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_gain" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_gain" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_gain" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_gain" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_gain(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[8] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_image", 8, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_image" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_image" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[8] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_image_fs", 8, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[8] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_image_sf", 8, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[7] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_integerarray", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  char *arg9 = (char *) 0 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  size_t size9 = 0 ;
  int alloc9 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject *swig_obj[12] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_integerarray_wdims", 12, 12, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  res9 = SWIG_AsCharPtrAndSize(swig_obj[7], &buf9, &size9, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "9"" of type '" "char *""'");
  }  
  arg9 = (char *)(buf9);
  arg10 = (int)(size9 - 1);
  ecode11 = SWIG_AsVal_int(swig_obj[8], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(swig_obj[9], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(swig_obj[10], &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(swig_obj[11], &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  char *arg9 = (char *) 0 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  size_t size9 = 0 ;
  int alloc9 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject *swig_obj[12] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_integerarray_wdims_fs", 12, 12, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  res9 = SWIG_AsCharPtrAndSize(swig_obj[7], &buf9, &size9, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "9"" of type '" "char *""'");
  }  
  arg9 = (char *)(buf9);
  arg10 = (int)(size9 - 1);
  ecode11 = SWIG_AsVal_int(swig_obj[8], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(swig_obj[9], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(swig_obj[10], &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(swig_obj[11], &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  char *arg9 = (char *) 0 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  size_t size9 = 0 ;
  int alloc9 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject *swig_obj[12] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_integerarray_wdims_sf", 12, 12, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  res9 = SWIG_AsCharPtrAndSize(swig_obj[7], &buf9, &size9, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "9"" of type '" "char *""'");
  }  
  arg9 = (char *)(buf9);
  arg10 = (int)(size9 - 1);
  ecode11 = SWIG_AsVal_int(swig_obj[8], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(swig_obj[9], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(swig_obj[10], &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(swig_obj[11], &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_integervalue", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integervalue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_integervalue(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integration_time(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_integration_time", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integration_time" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integration_time" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_integration_time(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_orientation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  PyObject *swig_obj[10] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_orientation_matrix", 10, 10, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(swig_obj[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(swig_obj[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(swig_obj[9], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_orientation_matrix(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_overload(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_overload", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_overload" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_overload" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_overload" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_set_overload(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_pixel_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_pixel_size", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_pixel_size(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_pixel_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_pixel_size_fs", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_pixel_size_fs(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_pixel_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_pixel_size_sf", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_pixel_size_sf(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_polarization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_polarization", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_polarization" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_polarization" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_polarization" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_set_polarization(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_3d_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[8] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_real_3d_image", 8, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_real_3d_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_3d_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[8] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_real_3d_image_fs", 8, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_real_3d_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_3d_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[8] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_real_3d_image_sf", 8, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[7], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_real_3d_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[7] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_real_image", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_image" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_real_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[7] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_real_image_fs", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_real_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[7] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_real_image_sf", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[6], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_real_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_realarray", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_set_realarray(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  char *arg8 = (char *) 0 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  size_t size8 = 0 ;
  int alloc8 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject *swig_obj[11] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_realarray_wdims", 11, 11, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  res8 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf8, &size8, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "8"" of type '" "char *""'");
  }  
  arg8 = (char *)(buf8);
  arg9 = (int)(size8 - 1);
  ecode10 = SWIG_AsVal_int(swig_obj[7], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(swig_obj[8], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(swig_obj[9], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(swig_obj[10], &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    error_status=0;
    cbf_handle_struct_set_realarray_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  char *arg8 = (char *) 0 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  size_t size8 = 0 ;
  int alloc8 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject *swig_obj[11] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_realarray_wdims_fs", 11, 11, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  res8 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf8, &size8, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "8"" of type '" "char *""'");
  }  
  arg8 = (char *)(buf8);
  arg9 = (int)(size8 - 1);
  ecode10 = SWIG_AsVal_int(swig_obj[7], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(swig_obj[8], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(swig_obj[9], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(swig_obj[10], &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    error_status=0;
    cbf_handle_struct_set_realarray_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  char *arg8 = (char *) 0 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  Py_ssize_t size4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  size_t size8 = 0 ;
  int alloc8 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject *swig_obj[11] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_realarray_wdims_sf", 11, 11, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = PyBytes_AsStringAndSize(swig_obj[3], &buf4, &size4) == -1 ? SWIG_TypeError : SWIG_OK;
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = (int)(size4);
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  res8 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf8, &size8, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "8"" of type '" "char *""'");
  }  
  arg8 = (char *)(buf8);
  arg9 = (int)(size8 - 1);
  ecode10 = SWIG_AsVal_int(swig_obj[7], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(swig_obj[8], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(swig_obj[9], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(swig_obj[10], &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    error_status=0;
    cbf_handle_struct_set_realarray_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_reciprocal_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_reciprocal_cell", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_reciprocal_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (swig_obj[1] == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(swig_obj[1],temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_reciprocal_cell(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_reciprocal_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_reciprocal_cell_esd", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_reciprocal_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (swig_obj[1] == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(swig_obj[1],temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_reciprocal_cell_esd(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_saveframename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_saveframename", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_saveframename" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_saveframename" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_saveframename(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_tag_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_tag_category", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_tag_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_tag_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_set_tag_category" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    cbf_handle_struct_set_tag_category(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_tag_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_tag_root", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_tag_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_tag_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_set_tag_root" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    cbf_handle_struct_set_tag_root(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_timestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_timestamp", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_timestamp(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_typeofvalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_typeofvalue", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_typeofvalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_typeofvalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_typeofvalue(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_unit_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_unit_cell", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_unit_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (swig_obj[1] == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(swig_obj[1],temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_unit_cell(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_unit_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_unit_cell_esd", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_unit_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (swig_obj[1] == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(swig_obj[1],temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_unit_cell_esd(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_value", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_value" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_value(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_wavelength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_set_wavelength", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_wavelength" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_wavelength" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_wavelength(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_write_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_write_file", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_write_file" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_write_file" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_write_file" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_write_file" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_write_file" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    error_status=0;
    cbf_handle_struct_write_file(arg1,(char const *)arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_write_widefile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  
  if (!SWIG_Python_UnpackTuple(args, "cbf_handle_struct_write_widefile", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_write_widefile" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_write_widefile" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_write_widefile" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_write_widefile" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_write_widefile" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    error_status=0;
    cbf_handle_struct_write_widefile(arg1,(char const *)arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *cbf_handle_struct_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_cbf_handle_struct, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *cbf_handle_struct_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

static PyMethodDef SwigMethods[] = {
	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { "new_doubleArray", _wrap_new_doubleArray, METH_O, NULL},
	 { "delete_doubleArray", _wrap_delete_doubleArray, METH_O, NULL},
	 { "doubleArray___getitem__", _wrap_doubleArray___getitem__, METH_VARARGS, NULL},
	 { "doubleArray___setitem__", _wrap_doubleArray___setitem__, METH_VARARGS, NULL},
	 { "doubleArray_cast", _wrap_doubleArray_cast, METH_O, NULL},
	 { "doubleArray_frompointer", _wrap_doubleArray_frompointer, METH_O, NULL},
	 { "doubleArray_swigregister", doubleArray_swigregister, METH_O, NULL},
	 { "doubleArray_swiginit", doubleArray_swiginit, METH_VARARGS, NULL},
	 { "new_intArray", _wrap_new_intArray, METH_O, NULL},
	 { "delete_intArray", _wrap_delete_intArray, METH_O, NULL},
	 { "intArray___getitem__", _wrap_intArray___getitem__, METH_VARARGS, NULL},
	 { "intArray___setitem__", _wrap_intArray___setitem__, METH_VARARGS, NULL},
	 { "intArray_cast", _wrap_intArray_cast, METH_O, NULL},
	 { "intArray_frompointer", _wrap_intArray_frompointer, METH_O, NULL},
	 { "intArray_swigregister", intArray_swigregister, METH_O, NULL},
	 { "intArray_swiginit", intArray_swiginit, METH_VARARGS, NULL},
	 { "new_shortArray", _wrap_new_shortArray, METH_O, NULL},
	 { "delete_shortArray", _wrap_delete_shortArray, METH_O, NULL},
	 { "shortArray___getitem__", _wrap_shortArray___getitem__, METH_VARARGS, NULL},
	 { "shortArray___setitem__", _wrap_shortArray___setitem__, METH_VARARGS, NULL},
	 { "shortArray_cast", _wrap_shortArray_cast, METH_O, NULL},
	 { "shortArray_frompointer", _wrap_shortArray_frompointer, METH_O, NULL},
	 { "shortArray_swigregister", shortArray_swigregister, METH_O, NULL},
	 { "shortArray_swiginit", shortArray_swiginit, METH_VARARGS, NULL},
	 { "new_longArray", _wrap_new_longArray, METH_O, NULL},
	 { "delete_longArray", _wrap_delete_longArray, METH_O, NULL},
	 { "longArray___getitem__", _wrap_longArray___getitem__, METH_VARARGS, NULL},
	 { "longArray___setitem__", _wrap_longArray___setitem__, METH_VARARGS, NULL},
	 { "longArray_cast", _wrap_longArray_cast, METH_O, NULL},
	 { "longArray_frompointer", _wrap_longArray_frompointer, METH_O, NULL},
	 { "longArray_swigregister", longArray_swigregister, METH_O, NULL},
	 { "longArray_swiginit", longArray_swiginit, METH_VARARGS, NULL},
	 { "airy_disk", _wrap_airy_disk, METH_VARARGS, "\n"
		"\n"
		"Returns : Float value\n"
		"*args   : double x,double y,double cenx,double ceny,double volume,double fwhm\n"
		"\n"
		"C prototype: int cbf_airy_disk(double x, double y, double cenx, double ceny,\n"
		"                 double      volume, double fwhm, double * value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_airy_disk sets value to point to the value taken at (x,y) of an \n"
		"truncated Airy function approximation to a point-spread function of \n"
		"total included volume volume and full width at half max fwhm centered \n"
		"on (cenx, ceny).\n"
		"cbf_airy_disk_volume sets to point to the integral in the box with \n"
		"diagonal corners (xlo, ylo) and of (xhi, yhi) of a truncated Airy \n"
		"function approximation to a point-spread function of total included \n"
		"volume volume and full width at half max fwhm centered on (cenx, \n"
		"ceny).\n"
		"The Airy function used is an 8-digit approximation up to the first \n"
		"minimum, after which it is forced to zero, so it cannot be used to \n"
		"simulate diffraction rings.\n"
		"ARGUMENTS\n"
		"x           the x-coordinate of a point in the real plane y           \n"
		"the y-coordinate of a point in the real plane xlo         the \n"
		"x-coordinate of a point in the real plane marking the left bound of \n"
		"integration ylo         the y-coordinate of a point in the real plane \n"
		"marking the bottom bound of integration xhi         the x-coordinate \n"
		"of a point in the real plane marking the right bound of integration \n"
		"yhi         the y-coordinate of a point in the real plane marking the \n"
		"top bound of integration cenx        the x-coordinate of a point in \n"
		"the real plane marking the PSF center ceny        the y-coordinate of \n"
		"a point in the real plane marking the PSF center volume      the \n"
		"total volume of the PSF fwhm        the full-width at half max of the \n"
		"PSF value       Pointer to the value of the Airy function volumeout   \n"
		"Pointer to the value of the integral/TR>\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "airy_disk_volume", _wrap_airy_disk_volume, METH_VARARGS, "\n"
		"\n"
		"Returns : Float volumeout\n"
		"*args   : double xlo,double ylo,double xhi,double yhi,double cenx,double ceny,\n"
		"          double volumein,double fwhm\n"
		"\n"
		"C prototype: int cbf_airy_disk_volume(double xlo, double ylo, double xhi,\n"
		"                 double yhi,      double cenx, double ceny, double volume,\n"
		"                 double fwhm, double *      volumeout);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_airy_disk sets value to point to the value taken at (x,y) of an \n"
		"truncated Airy function approximation to a point-spread function of \n"
		"total included volume volume and full width at half max fwhm centered \n"
		"on (cenx, ceny).\n"
		"cbf_airy_disk_volume sets to point to the integral in the box with \n"
		"diagonal corners (xlo, ylo) and of (xhi, yhi) of a truncated Airy \n"
		"function approximation to a point-spread function of total included \n"
		"volume volume and full width at half max fwhm centered on (cenx, \n"
		"ceny).\n"
		"The Airy function used is an 8-digit approximation up to the first \n"
		"minimum, after which it is forced to zero, so it cannot be used to \n"
		"simulate diffraction rings.\n"
		"ARGUMENTS\n"
		"x           the x-coordinate of a point in the real plane y           \n"
		"the y-coordinate of a point in the real plane xlo         the \n"
		"x-coordinate of a point in the real plane marking the left bound of \n"
		"integration ylo         the y-coordinate of a point in the real plane \n"
		"marking the bottom bound of integration xhi         the x-coordinate \n"
		"of a point in the real plane marking the right bound of integration \n"
		"yhi         the y-coordinate of a point in the real plane marking the \n"
		"top bound of integration cenx        the x-coordinate of a point in \n"
		"the real plane marking the PSF center ceny        the y-coordinate of \n"
		"a point in the real plane marking the PSF center volume      the \n"
		"total volume of the PSF fwhm        the full-width at half max of the \n"
		"PSF value       Pointer to the value of the Airy function volumeout   \n"
		"Pointer to the value of the integral/TR>\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "compute_cell_volume", _wrap_compute_cell_volume, METH_O, "\n"
		"\n"
		"Returns : Float volume\n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_compute_cell_volume ( double cell[6], double *volume );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_compute_cell_volume sets *volume to point to the volume of the \n"
		"unit cell computed from the double values in cell[0:2] for the cell \n"
		"edge lengths a, b and c in Ångstroms and the double values given in \n"
		"cell[3:5] for the cell angles α, β and γ in degrees.\n"
		"ARGUMENTS\n"
		"cell     Pointer to the array of 6 doubles giving the cell \n"
		"parameters. volume   Pointer to the doubles for cell volume.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "compute_reciprocal_cell", _wrap_compute_reciprocal_cell, METH_O, "\n"
		"\n"
		"Returns : Float astar,Float bstar,Float cstar,Float alphastar,Float betastar,\n"
		"          Float gammastar\n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_compute_reciprocal_cell ( double cell[6],\n"
		"                 double rcell[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_compute_reciprocal_cell sets rcell to point to the array of \n"
		"reciprocal cell parameters computed from the double values cell[0:2] \n"
		"giving the cell edge lengths a, b and c in Ångstroms, and the double \n"
		"values cell[3:5] giving the cell angles α, β and γ in degrees. The \n"
		"double values rcell[0:2] will be set to the reciprocal cell lengths \n"
		"a^*, b^* and c^* in Ångstroms^-1 and the double values rcell[3:5] \n"
		"will be set to the reciprocal cell angles α^*, β^* and γ^* in \n"
		"degrees.\n"
		"ARGUMENTS\n"
		"cell     Pointer to the array of 6 doubles giving the cell \n"
		"parameters. rcell    Pointer to the destination array of 6 doubles \n"
		"giving the reciprocal cell parameters. volume   Pointer to the \n"
		"doubles for cell volume.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "get_local_integer_byte_order", _wrap_get_local_integer_byte_order, METH_NOARGS, "\n"
		"\n"
		"Returns : char **bo,int *bolen\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_local_integer_byte_order (char ** byte_order);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_local_integer_byte_order returns the byte order of integers \n"
		"on the machine on which the API is being run in the form of a \n"
		"character string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_byte_order returns the byte order of reals on the \n"
		"machine on which the API is being run in the form of a character \n"
		"string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_format returns the format of floats on the machine \n"
		"on which the API is being run in the form of a character string \n"
		"returned as the value pointed to by real_format. The strings returned \n"
		"must not be modified in any way.\n"
		"The values returned in byte_order may be the strings  \"little_endian \n"
		"\" or  \"big-endian \". The values returned in real_format may be the \n"
		"strings  \"ieee 754-1985 \" or  \"other \". Additional values may be \n"
		"returned by future versions of the API.\n"
		"ARGUMENTS\n"
		"byte_order    pointer to the returned string real_format   pointer to \n"
		"the returned string\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "get_local_real_byte_order", _wrap_get_local_real_byte_order, METH_NOARGS, "\n"
		"\n"
		"Returns : char **bo,int *bolen\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_local_real_byte_order (char ** byte_order);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_local_integer_byte_order returns the byte order of integers \n"
		"on the machine on which the API is being run in the form of a \n"
		"character string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_byte_order returns the byte order of reals on the \n"
		"machine on which the API is being run in the form of a character \n"
		"string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_format returns the format of floats on the machine \n"
		"on which the API is being run in the form of a character string \n"
		"returned as the value pointed to by real_format. The strings returned \n"
		"must not be modified in any way.\n"
		"The values returned in byte_order may be the strings  \"little_endian \n"
		"\" or  \"big-endian \". The values returned in real_format may be the \n"
		"strings  \"ieee 754-1985 \" or  \"other \". Additional values may be \n"
		"returned by future versions of the API.\n"
		"ARGUMENTS\n"
		"byte_order    pointer to the returned string real_format   pointer to \n"
		"the returned string\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "get_local_real_format", _wrap_get_local_real_format, METH_NOARGS, "\n"
		"\n"
		"Returns : char **rf,int *rflen\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_local_real_format (char ** real_format );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_local_integer_byte_order returns the byte order of integers \n"
		"on the machine on which the API is being run in the form of a \n"
		"character string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_byte_order returns the byte order of reals on the \n"
		"machine on which the API is being run in the form of a character \n"
		"string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_format returns the format of floats on the machine \n"
		"on which the API is being run in the form of a character string \n"
		"returned as the value pointed to by real_format. The strings returned \n"
		"must not be modified in any way.\n"
		"The values returned in byte_order may be the strings  \"little_endian \n"
		"\" or  \"big-endian \". The values returned in real_format may be the \n"
		"strings  \"ieee 754-1985 \" or  \"other \". Additional values may be \n"
		"returned by future versions of the API.\n"
		"ARGUMENTS\n"
		"byte_order    pointer to the returned string real_format   pointer to \n"
		"the returned string\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_positioner_struct_matrix_set", _wrap_cbf_positioner_struct_matrix_set, METH_VARARGS, "cbf_positioner_struct_matrix_set(cbf_positioner_struct self, double [3][4] matrix)"},
	 { "cbf_positioner_struct_matrix_get", _wrap_cbf_positioner_struct_matrix_get, METH_O, "cbf_positioner_struct_matrix_get(cbf_positioner_struct self) -> double [3][4]"},
	 { "cbf_positioner_struct_axis_set", _wrap_cbf_positioner_struct_axis_set, METH_VARARGS, "cbf_positioner_struct_axis_set(cbf_positioner_struct self, cbf_axis_struct * axis)"},
	 { "cbf_positioner_struct_axis_get", _wrap_cbf_positioner_struct_axis_get, METH_O, "cbf_positioner_struct_axis_get(cbf_positioner_struct self) -> cbf_axis_struct *"},
	 { "cbf_positioner_struct_axes_set", _wrap_cbf_positioner_struct_axes_set, METH_VARARGS, "cbf_positioner_struct_axes_set(cbf_positioner_struct self, size_t axes)"},
	 { "cbf_positioner_struct_axes_get", _wrap_cbf_positioner_struct_axes_get, METH_O, "cbf_positioner_struct_axes_get(cbf_positioner_struct self) -> size_t"},
	 { "cbf_positioner_struct_matrix_is_valid_set", _wrap_cbf_positioner_struct_matrix_is_valid_set, METH_VARARGS, "cbf_positioner_struct_matrix_is_valid_set(cbf_positioner_struct self, int matrix_is_valid)"},
	 { "cbf_positioner_struct_matrix_is_valid_get", _wrap_cbf_positioner_struct_matrix_is_valid_get, METH_O, "cbf_positioner_struct_matrix_is_valid_get(cbf_positioner_struct self) -> int"},
	 { "cbf_positioner_struct_matrix_ratio_used_set", _wrap_cbf_positioner_struct_matrix_ratio_used_set, METH_VARARGS, "cbf_positioner_struct_matrix_ratio_used_set(cbf_positioner_struct self, double matrix_ratio_used)"},
	 { "cbf_positioner_struct_matrix_ratio_used_get", _wrap_cbf_positioner_struct_matrix_ratio_used_get, METH_O, "cbf_positioner_struct_matrix_ratio_used_get(cbf_positioner_struct self) -> double"},
	 { "cbf_positioner_struct_axis_index_limit_set", _wrap_cbf_positioner_struct_axis_index_limit_set, METH_VARARGS, "cbf_positioner_struct_axis_index_limit_set(cbf_positioner_struct self, size_t axis_index_limit)"},
	 { "cbf_positioner_struct_axis_index_limit_get", _wrap_cbf_positioner_struct_axis_index_limit_get, METH_O, "cbf_positioner_struct_axis_index_limit_get(cbf_positioner_struct self) -> size_t"},
	 { "new_cbf_positioner_struct", _wrap_new_cbf_positioner_struct, METH_NOARGS, "new_cbf_positioner_struct() -> cbf_positioner_struct"},
	 { "delete_cbf_positioner_struct", _wrap_delete_cbf_positioner_struct, METH_O, "delete_cbf_positioner_struct(cbf_positioner_struct self)"},
	 { "cbf_positioner_struct_get_goniometer_poise", _wrap_cbf_positioner_struct_get_goniometer_poise, METH_VARARGS, "\n"
		"\n"
		"Returns : Float vector1,Float vector2,Float vector3,Float offset1,Float offset2,\n"
		"          Float offset3,Float angle\n"
		"*args   : Float ratio\n"
		"\n"
		"C prototype: int cbf_get_goniometer_poise(cbf_goniometer goniometer,\n"
		"                 double ratio,      double * vector1, double * vector2,\n"
		"                 double * vector3, double * offset1,      double * offset2,\n"
		"                 double * offset3, double * angle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_axis_poise sets vector1, vector2, vector3 to point to the \n"
		"components of the axis vector for axis axis_id, offset1, offset2, \n"
		"offset3 to point to the components of the axis base offset vector for \n"
		"axis axis_id, and angle to point to the angle of rotation of axis \n"
		"axis_id after application of the axis settings for frame frame_id, \n"
		"using ratio, a value between 0 and 1, indicating how far into the \n"
		"internal motion in the frame to go. If frame_id is the string  \". \n"
		"\", the first frame found is used. If there is more than one frame, \n"
		"which frame will be found is indeterminate. If frame_id is NULL, the \n"
		"overall setting for the scan are used, rather than those for any \n"
		"particular frame. The vector and offset reported are the reference \n"
		"vector and offset of the axis axis_id transformed by application of \n"
		"all motions of the axes on which axis_id depends.\n"
		"cbf_get_goniometer_poise vector1, vector2, vector3 to point to the \n"
		"components of the axis vector for the goniometer axis, offset1, \n"
		"offset2, offset3 to point to the components of the axis base offset \n"
		"vector for the goniometer axis, and angle to point to the angle of \n"
		"rotation of the goniometer axis after application of all axis \n"
		"settings in the goniometer deriving the vector, offset and angle from \n"
		"the resulting matrix. Calculation of the vector is indeterminate if \n"
		"the angle is zero.\n"
		"cbf_get_axis_reference_poise sets vector1, vector2, vector3 to point \n"
		"to the components of the axis vector for axis axis_id, offset1, \n"
		"offset2, offset3 to point to the components of the axis base offset \n"
		"vector for axis axis_id unmodified by axis rotations. Any of the \n"
		"pointers may be specified as NULL.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. ratio        A number between 0 and 1 \n"
		"indication how far into the frame to go vector1      Pointer to the \n"
		"first component of the axis vector vector2      Pointer to the second \n"
		"component of the axis vector vector3      Pointer to the third \n"
		"component of the axis vector offset1      Pointer to the first \n"
		"component of the axis offset offset2      Pointer to the second \n"
		"component of the axis offset offset3      Pointer to the third \n"
		"component of the axis offset angle        Pointer to the rotation \n"
		"angle axis_id      The specified axis frame_id     The specified \n"
		"frame positioner   CBF goniometer\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_positioner_struct_get_reciprocal", _wrap_cbf_positioner_struct_get_reciprocal, METH_VARARGS, "\n"
		"\n"
		"Returns : double reciprocal1,double reciprocal2,double reciprocal3\n"
		"*args   : double ratio,double wavelength,double real1,double real2,double real3\n"
		"\n"
		"C prototype: int cbf_get_reciprocal (cbf_goniometer goniometer,\n"
		"                 unsigned int      reserved, double ratio, double wavelength,\n"
		"                 double real1, double real2,      double real3,\n"
		"                 double *reciprocal1, double *reciprocal2,\n"
		"                 double      *reciprocal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_reciprocal sets *reciprocal1, * reciprocal2, and * \n"
		"reciprocal3 to the 3 components of the of the reciprocal-space vector \n"
		"corresponding to the real-space vector (real1, real2, real3). The \n"
		"reciprocal-space vector is oriented to correspond to the goniometer \n"
		"setting with all axes at 0. The value wavelength is the wavlength in \n"
		"Å and the value ratio specifies the current goniometer setting and \n"
		"varies from 0.0 at the beginning of the exposur e to 1.0 at the end, \n"
		"irrespective of the actual rotation range.\n"
		"Any of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer    Goniometer handle. reserved      Unused. Any value \n"
		"other than 0 is invalid. ratio         Goniometer setting. 0 = \n"
		"beginning of exposure, 1 = end. wavelength    Wavelength in Å. real1  \n"
		"       x component of the real-space vector. real2         y \n"
		"component of the real-space vector. real3         z component of the \n"
		"real-space vector. reciprocal1   Pointer to the destination x \n"
		"component of the reciprocal-space vector. reciprocal2   Pointer to \n"
		"the destination y component of the reciprocal-space vector. \n"
		"reciprocal3   Pointer to the destination z component of the \n"
		"reciprocal-space vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_positioner_struct_get_rotation_axis", _wrap_cbf_positioner_struct_get_rotation_axis, METH_O, "\n"
		"\n"
		"Returns : double vector1,double vector2,double vector3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_rotation_axis (cbf_goniometer goniometer,\n"
		"                 unsigned int      reserved, double *vector1, double *vector2,\n"
		"                 double *vector3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_rotation_axis sets *vector1, *vector2, and *vector3 to the 3 \n"
		"components of the goniometer rotation axis used for the exposure.\n"
		"Any of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer   Goniometer handle. reserved     Unused. Any value other \n"
		"than 0 is invalid. vector1      Pointer to the destination x \n"
		"component of the rotation axis. vector2      Pointer to the \n"
		"destination y component of the rotation axis. vector3      Pointer to \n"
		"the destination z component of the rotation axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_positioner_struct_get_rotation_range", _wrap_cbf_positioner_struct_get_rotation_range, METH_O, "\n"
		"\n"
		"Returns : Float start,Float increment\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_rotation_range (cbf_goniometer goniometer,\n"
		"                 unsigned int      reserved, double *start, double *increment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_rotation_range sets *start and *increment to the \n"
		"corresponding values of the goniometer rotation axis used for the \n"
		"exposure.\n"
		"Either of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer   Goniometer handle. reserved     Unused. Any value other \n"
		"than 0 is invalid. start        Pointer to the destination start \n"
		"value. increment    Pointer to the destination increment value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_positioner_struct_rotate_vector", _wrap_cbf_positioner_struct_rotate_vector, METH_VARARGS, "\n"
		"\n"
		"Returns : double final1,double final2,double final3\n"
		"*args   : double ratio,double initial1,double initial2,double initial3\n"
		"\n"
		"C prototype: int cbf_rotate_vector (cbf_goniometer goniometer,\n"
		"                 unsigned int reserved,      double ratio, double initial1,\n"
		"                 double initial2, double initial3, double      *final1,\n"
		"                 double *final2, double *final3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rotate_vector sets *final1, *final2, and *final3 to the 3 \n"
		"components of the of the vector (initial1, initial2, initial3) after \n"
		"reorientation by applying the goniometer rotations. The value ratio \n"
		"specif ies the goniometer setting and varies from 0.0 at the \n"
		"beginning of the exposure to 1.0 at the end, irrespective of the \n"
		"actual rotation range.\n"
		"Any of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer   Goniometer handle. reserved     Unused. Any value other \n"
		"than 0 is invalid. ratio        Goniometer setting. 0 = beginning of \n"
		"exposure, 1 = end. initial1     x component of the initial vector. \n"
		"initial2     y component of the initial vector. initial3     z \n"
		"component of the initial vector. vector1      Pointer to the \n"
		"destination x component of the final vector. vector2      Pointer to \n"
		"the destination y component of the final vector. vector3      Pointer \n"
		"to the destination z component of the final vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_positioner_struct_swigregister", cbf_positioner_struct_swigregister, METH_O, NULL},
	 { "cbf_positioner_struct_swiginit", cbf_positioner_struct_swiginit, METH_VARARGS, NULL},
	 { "cbf_detector_struct_positioner_set", _wrap_cbf_detector_struct_positioner_set, METH_VARARGS, "cbf_detector_struct_positioner_set(cbf_detector_struct self, cbf_positioner_struct positioner)"},
	 { "cbf_detector_struct_positioner_get", _wrap_cbf_detector_struct_positioner_get, METH_O, "cbf_detector_struct_positioner_get(cbf_detector_struct self) -> cbf_positioner_struct"},
	 { "cbf_detector_struct_displacement_set", _wrap_cbf_detector_struct_displacement_set, METH_VARARGS, "cbf_detector_struct_displacement_set(cbf_detector_struct self, double [2] displacement)"},
	 { "cbf_detector_struct_displacement_get", _wrap_cbf_detector_struct_displacement_get, METH_O, "cbf_detector_struct_displacement_get(cbf_detector_struct self) -> double [2]"},
	 { "cbf_detector_struct_increment_set", _wrap_cbf_detector_struct_increment_set, METH_VARARGS, "cbf_detector_struct_increment_set(cbf_detector_struct self, double [2] increment)"},
	 { "cbf_detector_struct_increment_get", _wrap_cbf_detector_struct_increment_get, METH_O, "cbf_detector_struct_increment_get(cbf_detector_struct self) -> double [2]"},
	 { "cbf_detector_struct_axes_set", _wrap_cbf_detector_struct_axes_set, METH_VARARGS, "cbf_detector_struct_axes_set(cbf_detector_struct self, size_t axes)"},
	 { "cbf_detector_struct_axes_get", _wrap_cbf_detector_struct_axes_get, METH_O, "cbf_detector_struct_axes_get(cbf_detector_struct self) -> size_t"},
	 { "cbf_detector_struct_index_set", _wrap_cbf_detector_struct_index_set, METH_VARARGS, "cbf_detector_struct_index_set(cbf_detector_struct self, size_t [2] index)"},
	 { "cbf_detector_struct_index_get", _wrap_cbf_detector_struct_index_get, METH_O, "cbf_detector_struct_index_get(cbf_detector_struct self) -> size_t [2]"},
	 { "new_cbf_detector_struct", _wrap_new_cbf_detector_struct, METH_NOARGS, "new_cbf_detector_struct() -> cbf_detector_struct"},
	 { "delete_cbf_detector_struct", _wrap_delete_cbf_detector_struct, METH_O, "delete_cbf_detector_struct(cbf_detector_struct self)"},
	 { "cbf_detector_struct_get_beam_center", _wrap_cbf_detector_struct_get_beam_center, METH_O, "\n"
		"\n"
		"Returns : double index1,double index2,double center1,double center2\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_beam_center (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_beam_center_fs", _wrap_cbf_detector_struct_get_beam_center_fs, METH_O, "\n"
		"\n"
		"Returns : double indexfast,double indexslow,double centerfast,double centerslow\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_beam_center_fs (cbf_detector detector,\n"
		"                 double *indexfast,      double *indexslow, double *centerfast,\n"
		"                 double *centerslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_beam_center_sf", _wrap_cbf_detector_struct_get_beam_center_sf, METH_O, "\n"
		"\n"
		"Returns : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_beam_center_sf (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_axes", _wrap_cbf_detector_struct_get_detector_axes, METH_O, "\n"
		"\n"
		"Returns : double slowaxis1,double slowaxis2,double slowaxis3,double fastaxis1,\n"
		"          double fastaxis2,double fastaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axes (cbf_detector detector,\n"
		"                 double *slowaxis1,      double *slowaxis2, double *slowaxis3,\n"
		"                 double *fastaxis1, double      *fastaxis2, double *fastaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes. cbf_get_detector_surface_axes sets *axis_id1 \n"
		"and *axis_id2 to the names of the two surface axes of the detector or \n"
		" \". \",\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id2    Pointer to the destination second \n"
		"surface axis name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_axes_fs", _wrap_cbf_detector_struct_get_detector_axes_fs, METH_O, "cbf_detector_struct_get_detector_axes_fs(cbf_detector_struct self)"},
	 { "cbf_detector_struct_get_detector_axes_sf", _wrap_cbf_detector_struct_get_detector_axes_sf, METH_O, "\n"
		"\n"
		"Returns : double slowaxis1,double slowaxis2,double slowaxis3,double fastaxis1,\n"
		"          double fastaxis2,double fastaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axes_sf (cbf_detector detector,\n"
		"                 double *slowaxis1,      double *slowaxis2, double *slowaxis3,\n"
		"                 double *fastaxis1, double      *fastaxis2, double *fastaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes. cbf_get_detector_surface_axes sets *axis_id1 \n"
		"and *axis_id2 to the names of the two surface axes of the detector or \n"
		" \". \",\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id2    Pointer to the destination second \n"
		"surface axis name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_axis_fast", _wrap_cbf_detector_struct_get_detector_axis_fast, METH_O, "\n"
		"\n"
		"Returns : double fastaxis1,double fastaxis2,double fastaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axis_fast (cbf_detector detector,\n"
		"                 double      *fastaxis1, double *fastaxis2, double *fastaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes. cbf_get_detector_surface_axes sets *axis_id1 \n"
		"and *axis_id2 to the names of the two surface axes of the detector or \n"
		" \". \",\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id2    Pointer to the destination second \n"
		"surface axis name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_axis_slow", _wrap_cbf_detector_struct_get_detector_axis_slow, METH_O, "\n"
		"\n"
		"Returns : double slowaxis1,double slowaxis2,double slowaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axis_slow (cbf_detector detector,\n"
		"                 double      *slowaxis1, double *slowaxis2, double *slowaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes. cbf_get_detector_surface_axes sets *axis_id1 \n"
		"and *axis_id2 to the names of the two surface axes of the detector or \n"
		" \". \",\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id1    Pointer to the destination first \n"
		"surface axis name. axis_id2    Pointer to the destination second \n"
		"surface axis name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_distance", _wrap_cbf_detector_struct_get_detector_distance, METH_O, "\n"
		"\n"
		"Returns : double distance\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_distance (cbf_detector detector,\n"
		"                 double *distance);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_distance sets *distance to the nearest distance from \n"
		"the sample position to the detector plane.\n"
		"ARGUMENTS\n"
		"detector   Detector handle. distance   Pointer to the destination \n"
		"distance.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_normal", _wrap_cbf_detector_struct_get_detector_normal, METH_O, "\n"
		"\n"
		"Returns : double normal1,double normal2,double normal3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_normal (cbf_detector detector,\n"
		"                 double *normal1,      double *normal2, double *normal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_normal sets *normal1, *normal2, and *normal3 to the \n"
		"3 components of the of the normal vector to the detector plane. The \n"
		"vector is normalized.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector   Detector handle. normal1    Pointer to the destination x \n"
		"component of the normal vector. normal2    Pointer to the destination \n"
		"y component of the normal vector. normal3    Pointer to the \n"
		"destination z component of the normal vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_detector_surface_axes", _wrap_cbf_detector_struct_get_detector_surface_axes, METH_VARARGS, "cbf_detector_struct_get_detector_surface_axes(cbf_detector_struct self, int index) -> char const *"},
	 { "cbf_detector_struct_get_inferred_pixel_size", _wrap_cbf_detector_struct_get_inferred_pixel_size, METH_VARARGS, "\n"
		"\n"
		"Returns : Float pixel size\n"
		"*args   : Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_inferred_pixel_size (cbf_detector detector,\n"
		"                 int axis_number,      double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_inferred_pixel_size, cbf_get_inferred_pixel_size_sf set \n"
		"*psize to point to the double value in millimeters of the pixel size \n"
		"for the axis axis_number value. The slow index is treated as axis 1 \n"
		"and the next faster index is treated as axis 2. \n"
		"cbf_get_inferred_pixel_size_fs sets *psize to point to the double \n"
		"value in millimeters of the pixel size for the axis axis_number \n"
		"value. The fast index is treated as axis 1 and the next slower index \n"
		"is treated as axis 2.\n"
		"If the axis number is negative, the axes are used in the reverse \n"
		"order so that an axis_number of -1 indicates the fast axes in a call \n"
		"to cbf_get_inferred_pixel_size or cbf_get_inferred_pixel_size_sf and \n"
		"indicates the fast axis in a call to cbf_get_inferred_pixel_size_fs.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. axis_number   The number of the axis. \n"
		"area          Pointer to the destination pizel size in mm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_inferred_pixel_size_fs", _wrap_cbf_detector_struct_get_inferred_pixel_size_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : Float pixel size\n"
		"*args   : Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_inferred_pixel_size_fs(cbf_detector detector,\n"
		"                 int      axis_number, double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_inferred_pixel_size, cbf_get_inferred_pixel_size_sf set \n"
		"*psize to point to the double value in millimeters of the pixel size \n"
		"for the axis axis_number value. The slow index is treated as axis 1 \n"
		"and the next faster index is treated as axis 2. \n"
		"cbf_get_inferred_pixel_size_fs sets *psize to point to the double \n"
		"value in millimeters of the pixel size for the axis axis_number \n"
		"value. The fast index is treated as axis 1 and the next slower index \n"
		"is treated as axis 2.\n"
		"If the axis number is negative, the axes are used in the reverse \n"
		"order so that an axis_number of -1 indicates the fast axes in a call \n"
		"to cbf_get_inferred_pixel_size or cbf_get_inferred_pixel_size_sf and \n"
		"indicates the fast axis in a call to cbf_get_inferred_pixel_size_fs.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. axis_number   The number of the axis. \n"
		"area          Pointer to the destination pizel size in mm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_inferred_pixel_size_sf", _wrap_cbf_detector_struct_get_inferred_pixel_size_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : Float pixel size\n"
		"*args   : Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_inferred_pixel_size_sf(cbf_detector detector,\n"
		"                 int      axis_number, double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_inferred_pixel_size, cbf_get_inferred_pixel_size_sf set \n"
		"*psize to point to the double value in millimeters of the pixel size \n"
		"for the axis axis_number value. The slow index is treated as axis 1 \n"
		"and the next faster index is treated as axis 2. \n"
		"cbf_get_inferred_pixel_size_fs sets *psize to point to the double \n"
		"value in millimeters of the pixel size for the axis axis_number \n"
		"value. The fast index is treated as axis 1 and the next slower index \n"
		"is treated as axis 2.\n"
		"If the axis number is negative, the axes are used in the reverse \n"
		"order so that an axis_number of -1 indicates the fast axes in a call \n"
		"to cbf_get_inferred_pixel_size or cbf_get_inferred_pixel_size_sf and \n"
		"indicates the fast axis in a call to cbf_get_inferred_pixel_size_fs.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. axis_number   The number of the axis. \n"
		"area          Pointer to the destination pizel size in mm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_area", _wrap_cbf_detector_struct_get_pixel_area, METH_VARARGS, "\n"
		"\n"
		"Returns : double area,double projected_area\n"
		"*args   : double index1,double index2\n"
		"\n"
		"C prototype: int cbf_get_pixel_area (cbf_detector detector, double indexslow,\n"
		"                 double      indexfast, double *area, double *projected_area);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_area, cbf_get_pixel_area_fs and cbf_get_pixel_area_sf \n"
		"set *area to the area of the pixel at (indexfast, indexslow) on the \n"
		"detector surface and *projected_area to the apparent area of the \n"
		"pixel as viewed from the sample position, with indexslow being the \n"
		"slow axis and indexfast being the fast axis.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector         Detector handle. indexfast        Fast index. \n"
		"indexslow        Slow index. area             Pointer to the \n"
		"destination area in mm2. projected_area   Pointer to the destination \n"
		"apparent area in mm2.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_area_fs", _wrap_cbf_detector_struct_get_pixel_area_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : double area,double projected_area\n"
		"*args   : double indexfast,double indexslow\n"
		"\n"
		"C prototype: int cbf_get_pixel_area_fs(cbf_detector detector,\n"
		"                 double indexfast,      double indexslow, double *area,\n"
		"                 double *projected_area);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_area, cbf_get_pixel_area_fs and cbf_get_pixel_area_sf \n"
		"set *area to the area of the pixel at (indexfast, indexslow) on the \n"
		"detector surface and *projected_area to the apparent area of the \n"
		"pixel as viewed from the sample position, with indexslow being the \n"
		"slow axis and indexfast being the fast axis.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector         Detector handle. indexfast        Fast index. \n"
		"indexslow        Slow index. area             Pointer to the \n"
		"destination area in mm2. projected_area   Pointer to the destination \n"
		"apparent area in mm2.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_area_sf", _wrap_cbf_detector_struct_get_pixel_area_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : double area,double projected_area\n"
		"*args   : double indexslow,double indexfast\n"
		"\n"
		"C prototype: int cbf_get_pixel_area_sf(cbf_detector detector,\n"
		"                 double indexslow,      double indexfast, double *area,\n"
		"                 double *projected_area);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_area, cbf_get_pixel_area_fs and cbf_get_pixel_area_sf \n"
		"set *area to the area of the pixel at (indexfast, indexslow) on the \n"
		"detector surface and *projected_area to the apparent area of the \n"
		"pixel as viewed from the sample position, with indexslow being the \n"
		"slow axis and indexfast being the fast axis.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector         Detector handle. indexfast        Fast index. \n"
		"indexslow        Slow index. area             Pointer to the \n"
		"destination area in mm2. projected_area   Pointer to the destination \n"
		"apparent area in mm2.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_coordinates", _wrap_cbf_detector_struct_get_pixel_coordinates, METH_VARARGS, "\n"
		"\n"
		"Returns : double coordinate1,double coordinate2,double coordinate3\n"
		"*args   : double index1,double index2\n"
		"\n"
		"C prototype: int cbf_get_pixel_coordinates (cbf_detector detector,\n"
		"                 double indexslow,      double indexfast, double *coordinate1,\n"
		"                 double *coordinate2, double      *coordinate3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_coordinates, cbf_get_pixel_coordinates_fs and \n"
		"cbf_get_pixel_coordinates_sf ses *coordinate1, *coordinate2, and \n"
		"*coordinate3 to the vector position of pixel (indexfast, indexslow) \n"
		"on the detector surface. If indexslow and indexfast are integers then \n"
		"the coordinates correspond to the center of a pixel.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. indexslow     Slow index. indexfast    \n"
		" Fast index. coordinate1   Pointer to the destination x component. \n"
		"coordinate2   Pointer to the destination y component. coordinate3   \n"
		"Pointer to the destination z component.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_coordinates_fs", _wrap_cbf_detector_struct_get_pixel_coordinates_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : double coordinate1,double coordinate2,double coordinate3\n"
		"*args   : double indexfast,double indexslow\n"
		"\n"
		"C prototype: int cbf_get_pixel_coordinates_fs (cbf_detector detector,\n"
		"                 double      indexfast, double indexslow, double *coordinate1,\n"
		"                 double *coordinate2,      double *coordinate3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_coordinates, cbf_get_pixel_coordinates_fs and \n"
		"cbf_get_pixel_coordinates_sf ses *coordinate1, *coordinate2, and \n"
		"*coordinate3 to the vector position of pixel (indexfast, indexslow) \n"
		"on the detector surface. If indexslow and indexfast are integers then \n"
		"the coordinates correspond to the center of a pixel.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. indexslow     Slow index. indexfast    \n"
		" Fast index. coordinate1   Pointer to the destination x component. \n"
		"coordinate2   Pointer to the destination y component. coordinate3   \n"
		"Pointer to the destination z component.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_coordinates_sf", _wrap_cbf_detector_struct_get_pixel_coordinates_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : double coordinate1,double coordinate2,double coordinate3\n"
		"*args   : double indexslow,double indexfast\n"
		"\n"
		"C prototype: int cbf_get_pixel_coordinates_sf (cbf_detector detector,\n"
		"                 double      indexslow, double indexfast, double *coordinate1,\n"
		"                 double *coordinate2,      double *coordinate3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_coordinates, cbf_get_pixel_coordinates_fs and \n"
		"cbf_get_pixel_coordinates_sf ses *coordinate1, *coordinate2, and \n"
		"*coordinate3 to the vector position of pixel (indexfast, indexslow) \n"
		"on the detector surface. If indexslow and indexfast are integers then \n"
		"the coordinates correspond to the center of a pixel.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. indexslow     Slow index. indexfast    \n"
		" Fast index. coordinate1   Pointer to the destination x component. \n"
		"coordinate2   Pointer to the destination y component. coordinate3   \n"
		"Pointer to the destination z component.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_normal", _wrap_cbf_detector_struct_get_pixel_normal, METH_VARARGS, "\n"
		"\n"
		"Returns : double normal1,double normal2,double normal3\n"
		"*args   : double index1,double index2\n"
		"\n"
		"C prototype: int cbf_get_pixel_normal (cbf_detector detector,\n"
		"                 double indexslow,      double indexfast, double *normal1,\n"
		"                 double *normal2, double *normal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_normal, cbf_get_pixel_normal_fs and \n"
		"cbf_get_pixel_normal_sf set *normal1, *normal2, and *normal3 to the 3 \n"
		"components of the of the normal vector to the pixel at (indexfast, \n"
		"indexslow). The vector is normalized.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. indexslow   Slow index. indexfast   Fast \n"
		"index. normal1     Pointer to the destination x component of the \n"
		"normal vector. normal2     Pointer to the destination y component of \n"
		"the normal vector. normal3     Pointer to the destination z component \n"
		"of the normal vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_get_pixel_normal_fs", _wrap_cbf_detector_struct_get_pixel_normal_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : double normal1,double normal2,double normal3\n"
		"*args   : double indexfast,double indexslow\n"
		"\n"
		"C prototype: int cbf_get_pixel_normal_fs (cbf_detector detector,\n"
		"                 double indexfast,      double indexslow, double *normal1,\n"
		"                 double *normal2, double *normal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_normal, cbf_get_pixel_normal_fs and \n"
		"cbf_get_pixel_normal_sf set *normal1, *normal2, and *normal3 to the 3 \n"
		"components of the of the normal vector to the pixel at (indexfast, \n"
		"indexslow). The vector is normalized.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. indexslow   Slow index. indexfast   Fast \n"
		"index. normal1     Pointer to the destination x component of the \n"
		"normal vector. normal2     Pointer to the destination y component of \n"
		"the normal vector. normal3     Pointer to the destination z component \n"
		"of the normal vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_set_beam_center", _wrap_cbf_detector_struct_set_beam_center, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_beam_center (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_set_beam_center_fs", _wrap_cbf_detector_struct_set_beam_center_fs, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : double indexfast,double indexslow,double centerfast,double centerslow\n"
		"\n"
		"C prototype: int cbf_set_beam_center_fs (cbf_detector detector,\n"
		"                 double *indexfast,      double *indexslow, double *centerfast,\n"
		"                 double *centerslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_set_beam_center_sf", _wrap_cbf_detector_struct_set_beam_center_sf, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_beam_center_sf (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_set_reference_beam_center", _wrap_cbf_detector_struct_set_reference_beam_center, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_reference_beam_center (cbf_detector detector,\n"
		"                 double      *indexslow, double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_set_reference_beam_center_fs", _wrap_cbf_detector_struct_set_reference_beam_center_fs, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : double indexfast,double indexslow,double centerfast,double centerslow\n"
		"\n"
		"C prototype: int cbf_set_reference_beam_center_fs (cbf_detector detector,\n"
		"                 double      *indexfast, double *indexslow, double *centerfast,\n"
		"                 double *centerslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_set_reference_beam_center_sf", _wrap_cbf_detector_struct_set_reference_beam_center_sf, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_reference_beam_center_sf (cbf_detector detector,\n"
		"                 double      *indexslow, double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_detector_struct_swigregister", cbf_detector_struct_swigregister, METH_O, NULL},
	 { "cbf_detector_struct_swiginit", cbf_detector_struct_swiginit, METH_VARARGS, NULL},
	 { "cbf_handle_struct_node_set", _wrap_cbf_handle_struct_node_set, METH_VARARGS, "cbf_handle_struct_node_set(cbf_handle_struct self, cbf_node * node)"},
	 { "cbf_handle_struct_node_get", _wrap_cbf_handle_struct_node_get, METH_O, "cbf_handle_struct_node_get(cbf_handle_struct self) -> cbf_node *"},
	 { "cbf_handle_struct_row_set", _wrap_cbf_handle_struct_row_set, METH_VARARGS, "cbf_handle_struct_row_set(cbf_handle_struct self, int row)"},
	 { "cbf_handle_struct_row_get", _wrap_cbf_handle_struct_row_get, METH_O, "cbf_handle_struct_row_get(cbf_handle_struct self) -> int"},
	 { "cbf_handle_struct_search_row_set", _wrap_cbf_handle_struct_search_row_set, METH_VARARGS, "cbf_handle_struct_search_row_set(cbf_handle_struct self, int search_row)"},
	 { "cbf_handle_struct_search_row_get", _wrap_cbf_handle_struct_search_row_get, METH_O, "cbf_handle_struct_search_row_get(cbf_handle_struct self) -> int"},
	 { "new_cbf_handle_struct", _wrap_new_cbf_handle_struct, METH_NOARGS, "new_cbf_handle_struct() -> cbf_handle_struct"},
	 { "delete_cbf_handle_struct", _wrap_delete_cbf_handle_struct, METH_O, "delete_cbf_handle_struct(cbf_handle_struct self)"},
	 { "cbf_handle_struct_category_name", _wrap_cbf_handle_struct_category_name, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_category_name (cbf_handle handle,\n"
		"                 const char **categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_category_name sets *categoryname to point to the name of the \n"
		"current category of the current data block.\n"
		"The category name will be valid as long as the category exists.\n"
		"The name must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   Pointer to the destination \n"
		"category name pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_column_name", _wrap_cbf_handle_struct_column_name, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_column_name (cbf_handle handle, const char **columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_column_name sets *columnname to point to the name of the current \n"
		"column of the current category.\n"
		"The column name will be valid as long as the column exists.\n"
		"The name must not be modified by the program in any way.\n"
		"cbf_set_column_name sets the name of the current column to \n"
		"newcolumnname\n"
		"ARGUMENTS\n"
		"handle          CBF handle. columnname      Pointer to the \n"
		"destination column name pointer. newcolumnname   New column name \n"
		"pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_construct_detector", _wrap_cbf_handle_struct_construct_detector, METH_VARARGS, "\n"
		"\n"
		"Returns : pycbf detector object\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_construct_detector (cbf_handle handle,\n"
		"                 cbf_detector *detector,      unsigned int element_number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_detector constructs a detector object for detector \n"
		"element number element_number using the description in the CBF object \n"
		"handle and initialises the detector handle *detector.\n"
		"cbf_construct_reference_detector constructs a detector object for \n"
		"detector element number element_number using the description in the \n"
		"CBF object handle and initialises the detector handle *detector using \n"
		"the reference settings of the axes. cbf_require_reference_detector is \n"
		"similar, but try to force the creations of missing intermediate \n"
		"categories needed to construct a detector object.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. detector         Pointer to the \n"
		"destination detector handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_construct_goniometer", _wrap_cbf_handle_struct_construct_goniometer, METH_O, "\n"
		"\n"
		"Returns : pycbf goniometer object\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_construct_goniometer (cbf_handle handle,\n"
		"                 cbf_goniometer      *goniometer);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_goniometer constructs a goniometer object using the \n"
		"description in the CBF object handle and initialises the goniometer \n"
		"handle *goniometer.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. goniometer   Pointer to the destination \n"
		"goniometer handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_construct_positioner", _wrap_cbf_handle_struct_construct_positioner, METH_VARARGS, "\n"
		"\n"
		"Returns : pycbf positioner object\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_construct_positioner (cbf_handle handle,\n"
		"                 cbf_positioner      *positioner, const char *axis_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_positioner constructs a positioner object for the axis \n"
		"given by axis_id using the description in the CBF object handle and \n"
		"initialises the positioner handle *positioner.\n"
		"cbf_construct_reference positioner constructs a positioner object for \n"
		"the axis given by axis_id using the description in the CBF object \n"
		"handle and initialises the detector handle *detector using the \n"
		"reference settings of the axes.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. detector   Pointer to the destination detector \n"
		"handle. axis_id    The identifier of the axis in the  \"axis \" \n"
		"category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_construct_reference_detector", _wrap_cbf_handle_struct_construct_reference_detector, METH_VARARGS, "\n"
		"\n"
		"Returns : pycbf detector object\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_construct_reference_detector (cbf_handle handle,\n"
		"                 cbf_detector      *detector, unsigned int element_number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_detector constructs a detector object for detector \n"
		"element number element_number using the description in the CBF object \n"
		"handle and initialises the detector handle *detector.\n"
		"cbf_construct_reference_detector constructs a detector object for \n"
		"detector element number element_number using the description in the \n"
		"CBF object handle and initialises the detector handle *detector using \n"
		"the reference settings of the axes. cbf_require_reference_detector is \n"
		"similar, but try to force the creations of missing intermediate \n"
		"categories needed to construct a detector object.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. detector         Pointer to the \n"
		"destination detector handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_construct_reference_positioner", _wrap_cbf_handle_struct_construct_reference_positioner, METH_VARARGS, "\n"
		"\n"
		"Returns : pycbf positioner object\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_construct_reference_positioner (cbf_handle handle,\n"
		"                      cbf_positioner *positioner, const char *axis_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_positioner constructs a positioner object for the axis \n"
		"given by axis_id using the description in the CBF object handle and \n"
		"initialises the positioner handle *positioner.\n"
		"cbf_construct_reference positioner constructs a positioner object for \n"
		"the axis given by axis_id using the description in the CBF object \n"
		"handle and initialises the detector handle *detector using the \n"
		"reference settings of the axes.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. detector   Pointer to the destination detector \n"
		"handle. axis_id    The identifier of the axis in the  \"axis \" \n"
		"category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_count_axis_ancestors", _wrap_cbf_handle_struct_count_axis_ancestors, METH_VARARGS, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_count_axis_ancestors (cbf_handle handle,\n"
		"                 const char *axis_id,      unsigned int *ancestors);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_count_categories", _wrap_cbf_handle_struct_count_categories, METH_O, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_categories (cbf_handle handle,\n"
		"                 unsigned int *categories);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_categories puts the number of categories in the current \n"
		"data block in *categories.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. categories   Pointer to the destination \n"
		"category count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_count_columns", _wrap_cbf_handle_struct_count_columns, METH_O, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_columns (cbf_handle handle, unsigned int *columns);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_columns puts the number of columns in the current category \n"
		"in *columns.\n"
		"ARGUMENTS\n"
		"handle    CBF handle. columns   Pointer to the destination column \n"
		"count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_count_datablocks", _wrap_cbf_handle_struct_count_datablocks, METH_O, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_datablocks (cbf_handle handle,\n"
		"                 unsigned int *datablocks);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_datablocks puts the number of data blocks in *datablocks .\n"
		"ARGUMENTS\n"
		"handle       CBF handle. datablocks   Pointer to the destination data \n"
		"block count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_count_elements", _wrap_cbf_handle_struct_count_elements, METH_O, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_elements (cbf_handle handle,\n"
		"                 unsigned int *elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_elements sets *elements to the number of detector elements.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. elements   Pointer to the destination count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_count_rows", _wrap_cbf_handle_struct_count_rows, METH_O, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_rows (cbf_handle handle, unsigned int *rows);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_rows puts the number of rows in the current category in \n"
		"*rows .\n"
		"ARGUMENTS\n"
		"handle   CBF handle. rows     Pointer to the destination row count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_datablock_name", _wrap_cbf_handle_struct_datablock_name, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_datablock_name (cbf_handle handle,\n"
		"                 const char **datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_datablock_name sets *datablockname to point to the name of the \n"
		"current data block.\n"
		"The data block name will be valid as long as the data block exists \n"
		"and has not been renamed.\n"
		"The name must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   Pointer to the \n"
		"destination data block name pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_delete_row", _wrap_cbf_handle_struct_delete_row, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_delete_row (cbf_handle handle, unsigned int rownumber);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_delete_row deletes a row from the current category. Rows starting \n"
		"from rownumber +1 are moved down by 1. If the current row was higher \n"
		"than rownumber, or if the current row is the last row, it will also \n"
		"move down by 1.\n"
		"The row numbers start from 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. rownumber   The number of the row to delete.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_category", _wrap_cbf_handle_struct_find_category, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_category makes the category in the current data block with \n"
		"name categoryname the current category.\n"
		"The comparison is case-insensitive.\n"
		"If the category does not exist, the function returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the category to \n"
		"find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_category_root", _wrap_cbf_handle_struct_find_category_root, METH_VARARGS, "\n"
		"\n"
		"Returns : String categoryroot\n"
		"*args   : String categoryname\n"
		"\n"
		"C prototype: int cbf_find_category_root (cbf_handle handle,\n"
		"                 const char* categoryname,      const char** categoryroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias. cbf_set_category_root sets \n"
		"categoryname_in as an alias of categoryroot in the dictionary \n"
		"associated with handle, creating the dictionary if necessary. \n"
		"cbf_require_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias, if there is one, or to the value of \n"
		"categoryname, if categoryname is not an alias.\n"
		"A returned categoryroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. categoryname      category name which \n"
		"may be an alias. categoryroot      pointer to a returned category \n"
		"root name. categoryroot_in   input category root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_column", _wrap_cbf_handle_struct_find_column, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_column (cbf_handle handle, const char *columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_column makes the columns in the current category with name \n"
		"columnname the current column.\n"
		"The comparison is case-insensitive.\n"
		"If the column does not exist, the function returns CBF_NOTFOUND.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   The name of column to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_datablock", _wrap_cbf_handle_struct_find_datablock, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_datablock (cbf_handle handle,\n"
		"                 const char *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_datablock makes the data block with name datablockname the \n"
		"current data block.\n"
		"The comparison is case-insensitive.\n"
		"If the data block does not exist, the function returns CBF_NOTFOUND.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the data \n"
		"block to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_nextrow", _wrap_cbf_handle_struct_find_nextrow, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_nextrow (cbf_handle handle, const char *value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_nextrow makes the makes the next row in the current column \n"
		"with value value the current row. The search starts from the row \n"
		"following the last row found with cbf_find_row or cbf_find_nextrow, \n"
		"or from the current row if the current row was defined using any \n"
		"other function.\n"
		"The comparison is case-sensitive.\n"
		"If no more matching rows exist, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. value    the value to search for.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_row", _wrap_cbf_handle_struct_find_row, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_row (cbf_handle handle, const char *value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_row makes the first row in the current column with value \n"
		"value the current row.\n"
		"The comparison is case-sensitive.\n"
		"If a matching row does not exist, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. value    The value of the row to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_tag_category", _wrap_cbf_handle_struct_find_tag_category, METH_VARARGS, "\n"
		"\n"
		"Returns : String categoryname\n"
		"*args   : String tagname\n"
		"\n"
		"C prototype: int cbf_find_tag_category (cbf_handle handle,\n"
		"                 const char* tagname, const      char** categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_category sets categoryname to the category associated \n"
		"with tagname in the dictionary associated with handle. \n"
		"cbf_set_tag_category upddates the dictionary associated with handle \n"
		"to indicated that tagname is in category categoryname_in.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. tagname           tag name. \n"
		"categoryname      pointer to a returned category name. \n"
		"categoryname_in   input category name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_find_tag_root", _wrap_cbf_handle_struct_find_tag_root, METH_VARARGS, "\n"
		"\n"
		"Returns : String tagroot\n"
		"*args   : String tagname\n"
		"\n"
		"C prototype: int cbf_find_tag_root (cbf_handle handle, const char* tagname,\n"
		"                 const      char** tagroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_root sets *tagroot to the root tag of which tagname is \n"
		"an alias. cbf_set_tag_root sets tagname as an alias of tagroot_in in \n"
		"the dictionary associated with handle, creating the dictionary if \n"
		"necessary. cbf_require_tag_root sets *tagroot to the root tag of \n"
		"which tagname is an alias, if there is one, or to the value of \n"
		"tagname, if tagname is not an alias.\n"
		"A returned tagroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. tagname      tag name which may be an alias. \n"
		"tagroot      pointer to a returned tag root name. tagroot_in   input \n"
		"tag root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_force_new_category", _wrap_cbf_handle_struct_force_new_category, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_force_new_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_force_new_category creates a new category in the current data \n"
		"block with name categoryname and makes it the current category. \n"
		"Duplicate category names are allowed.\n"
		"Even if a category with this name already exists, a new category of \n"
		"the same name is created and becomes the current category. The allows \n"
		"for the creation of unlooped tag/value lists drawn from the same \n"
		"category.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the new \n"
		"category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_force_new_datablock", _wrap_cbf_handle_struct_force_new_datablock, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_force_new_datablock (cbf_handle handle,\n"
		"                 const char    *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_force_new_datablock creates a new data block with name \n"
		"datablockname and makes it the current data block. Duplicate data \n"
		"block names are allowed. cbf_force_new_saveframe creates a new savew \n"
		"frame with name saveframename and makes it the current save frame. \n"
		"Duplicate save frame names are allowed.\n"
		"Even if a save frame with this name already exists, a new save frame \n"
		"is created and becomes the current save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_force_new_saveframe", _wrap_cbf_handle_struct_force_new_saveframe, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_force_new_saveframe (cbf_handle handle,\n"
		"                 const char    *saveframename);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_force_new_datablock creates a new data block with name \n"
		"datablockname and makes it the current data block. Duplicate data \n"
		"block names are allowed. cbf_force_new_saveframe creates a new savew \n"
		"frame with name saveframename and makes it the current save frame. \n"
		"Duplicate save frame names are allowed.\n"
		"Even if a save frame with this name already exists, a new save frame \n"
		"is created and becomes the current save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_3d_image_as_string", _wrap_cbf_handle_struct_get_3d_image_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimmid,\n"
		"          int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_3d_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimslow, size_t ndimmid,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_3d_image_fs_as_string", _wrap_cbf_handle_struct_get_3d_image_fs_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimfast,int ndimmid,\n"
		"          int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_3d_image_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, int elsign,      size_t ndimfast,\n"
		"                 size_t ndimmid, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_3d_image_sf_as_string", _wrap_cbf_handle_struct_get_3d_image_sf_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimmid,\n"
		"          int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_3d_image_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, int elsign,      size_t ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_3d_image_size", _wrap_cbf_handle_struct_get_3d_image_size, METH_VARARGS, "\n"
		"\n"
		"Returns : size_t ndimslow,size_t ndimmid,size_t ndimfast\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_3d_image_size (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimslow, size_t *ndimmid, size_t      *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_3d_image_size_fs", _wrap_cbf_handle_struct_get_3d_image_size_fs, METH_VARARGS, "cbf_handle_struct_get_3d_image_size_fs(cbf_handle_struct self, unsigned int element_number)"},
	 { "cbf_handle_struct_get_3d_image_size_sf", _wrap_cbf_handle_struct_get_3d_image_size_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : size_t ndimslow,size_t ndimmid,size_t ndimfast\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_3d_image_size_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimslow, size_t *ndimmid, size_t      *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_ancestor", _wrap_cbf_handle_struct_get_axis_ancestor, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : String axis_id,Integer ancestor_index\n"
		"\n"
		"C prototype: int cbf_get_axis_ancestor (cbf_handle handle,\n"
		"                 const char *axis_id, const      unsigned int ancestor_index,\n"
		"                 const char * *ancestor);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_depends_on", _wrap_cbf_handle_struct_get_axis_depends_on, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_depends_on (cbf_handle handle,\n"
		"                 const char *axis_id,      const char * *depends_on);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_equipment", _wrap_cbf_handle_struct_get_axis_equipment, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_equipment (cbf_handle handle,\n"
		"                 const char *axis_id,      const char * *equipment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_equipment_component", _wrap_cbf_handle_struct_get_axis_equipment_component, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_equipment_component (cbf_handle handle,\n"
		"                 const char      *axis_id, const char * *equipment_component);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_offset", _wrap_cbf_handle_struct_get_axis_offset, METH_VARARGS, "\n"
		"\n"
		"Returns : Float offset1,Float offset2,Float offset3\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_offset (cbf_handle handle, const char *axis_id,\n"
		"                 double      *offset1, double *offset2, double *offset3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_poise", _wrap_cbf_handle_struct_get_axis_poise, METH_VARARGS, "\n"
		"\n"
		"Returns : Float vector1,Float vector2,Float vector3,Float offset1,Float offset2,\n"
		"          Float offset3,Float angle\n"
		"*args   : Float ratio,String axis_id,String frame_id\n"
		"\n"
		"C prototype: int cbf_get_axis_poise(cbf_handle handle, double ratio,\n"
		"                 double *      vector1, double * vector2, double * vector3,\n"
		"                 double * offset1, double *      offset2, double * offset3,\n"
		"                 double * angle, const char * axis_id,\n"
		"                 const      char * frame_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_axis_poise sets vector1, vector2, vector3 to point to the \n"
		"components of the axis vector for axis axis_id, offset1, offset2, \n"
		"offset3 to point to the components of the axis base offset vector for \n"
		"axis axis_id, and angle to point to the angle of rotation of axis \n"
		"axis_id after application of the axis settings for frame frame_id, \n"
		"using ratio, a value between 0 and 1, indicating how far into the \n"
		"internal motion in the frame to go. If frame_id is the string  \". \n"
		"\", the first frame found is used. If there is more than one frame, \n"
		"which frame will be found is indeterminate. If frame_id is NULL, the \n"
		"overall setting for the scan are used, rather than those for any \n"
		"particular frame. The vector and offset reported are the reference \n"
		"vector and offset of the axis axis_id transformed by application of \n"
		"all motions of the axes on which axis_id depends.\n"
		"cbf_get_goniometer_poise vector1, vector2, vector3 to point to the \n"
		"components of the axis vector for the goniometer axis, offset1, \n"
		"offset2, offset3 to point to the components of the axis base offset \n"
		"vector for the goniometer axis, and angle to point to the angle of \n"
		"rotation of the goniometer axis after application of all axis \n"
		"settings in the goniometer deriving the vector, offset and angle from \n"
		"the resulting matrix. Calculation of the vector is indeterminate if \n"
		"the angle is zero.\n"
		"cbf_get_axis_reference_poise sets vector1, vector2, vector3 to point \n"
		"to the components of the axis vector for axis axis_id, offset1, \n"
		"offset2, offset3 to point to the components of the axis base offset \n"
		"vector for axis axis_id unmodified by axis rotations. Any of the \n"
		"pointers may be specified as NULL.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. ratio        A number between 0 and 1 \n"
		"indication how far into the frame to go vector1      Pointer to the \n"
		"first component of the axis vector vector2      Pointer to the second \n"
		"component of the axis vector vector3      Pointer to the third \n"
		"component of the axis vector offset1      Pointer to the first \n"
		"component of the axis offset offset2      Pointer to the second \n"
		"component of the axis offset offset3      Pointer to the third \n"
		"component of the axis offset angle        Pointer to the rotation \n"
		"angle axis_id      The specified axis frame_id     The specified \n"
		"frame positioner   CBF goniometer\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_reference_poise", _wrap_cbf_handle_struct_get_axis_reference_poise, METH_VARARGS, "\n"
		"\n"
		"Returns : Float vector1,Float vector2,Float vector3,Float offset1,Float offset2,\n"
		"          Float offset3\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_reference_poise(cbf_handle handle,\n"
		"                 double * vector1,      double * vector2, double * vector3,\n"
		"                 double * offset1, double * offset2,      double * offset3,\n"
		"                 const char * axis_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_axis_poise sets vector1, vector2, vector3 to point to the \n"
		"components of the axis vector for axis axis_id, offset1, offset2, \n"
		"offset3 to point to the components of the axis base offset vector for \n"
		"axis axis_id, and angle to point to the angle of rotation of axis \n"
		"axis_id after application of the axis settings for frame frame_id, \n"
		"using ratio, a value between 0 and 1, indicating how far into the \n"
		"internal motion in the frame to go. If frame_id is the string  \". \n"
		"\", the first frame found is used. If there is more than one frame, \n"
		"which frame will be found is indeterminate. If frame_id is NULL, the \n"
		"overall setting for the scan are used, rather than those for any \n"
		"particular frame. The vector and offset reported are the reference \n"
		"vector and offset of the axis axis_id transformed by application of \n"
		"all motions of the axes on which axis_id depends.\n"
		"cbf_get_goniometer_poise vector1, vector2, vector3 to point to the \n"
		"components of the axis vector for the goniometer axis, offset1, \n"
		"offset2, offset3 to point to the components of the axis base offset \n"
		"vector for the goniometer axis, and angle to point to the angle of \n"
		"rotation of the goniometer axis after application of all axis \n"
		"settings in the goniometer deriving the vector, offset and angle from \n"
		"the resulting matrix. Calculation of the vector is indeterminate if \n"
		"the angle is zero.\n"
		"cbf_get_axis_reference_poise sets vector1, vector2, vector3 to point \n"
		"to the components of the axis vector for axis axis_id, offset1, \n"
		"offset2, offset3 to point to the components of the axis base offset \n"
		"vector for axis axis_id unmodified by axis rotations. Any of the \n"
		"pointers may be specified as NULL.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. ratio        A number between 0 and 1 \n"
		"indication how far into the frame to go vector1      Pointer to the \n"
		"first component of the axis vector vector2      Pointer to the second \n"
		"component of the axis vector vector3      Pointer to the third \n"
		"component of the axis vector offset1      Pointer to the first \n"
		"component of the axis offset offset2      Pointer to the second \n"
		"component of the axis offset offset3      Pointer to the third \n"
		"component of the axis offset angle        Pointer to the rotation \n"
		"angle axis_id      The specified axis frame_id     The specified \n"
		"frame positioner   CBF goniometer\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_rotation", _wrap_cbf_handle_struct_get_axis_rotation, METH_VARARGS, "\n"
		"\n"
		"Returns : Float\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_rotation (cbf_handle handle,\n"
		"                 const char *axis_id,      double *rotation);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_rotation_axis", _wrap_cbf_handle_struct_get_axis_rotation_axis, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_rotation_axis (cbf_handle handle,\n"
		"                 const char *axis_id,      const char * *rotation_axis);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_setting", _wrap_cbf_handle_struct_get_axis_setting, METH_VARARGS, "\n"
		"\n"
		"Returns : Float start,Float increment\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_setting (cbf_handle handle,\n"
		"                 unsigned int reserved,      const char *axis_id, double *start,\n"
		"                 double *increment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_type", _wrap_cbf_handle_struct_get_axis_type, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_type (cbf_handle handle, const char *axis_id,\n"
		"                      cbf_axis_type *axis_type);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_axis_vector", _wrap_cbf_handle_struct_get_axis_vector, METH_VARARGS, "\n"
		"\n"
		"Returns : Float vector1,Float vector2,Float vector3\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_vector (cbf_handle handle, const char *axis_id,\n"
		"                 double      *vector1, double *vector2, double *vector3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_axis_ancestors sets ancestors to the number of ancestors of \n"
		"axis axis_id. cbf_get_axis_ancestor sets *ancestor to the ancestor \n"
		"axis of index ancestor_index of axis axis_id, starting with axis_id \n"
		"for ancestor_index 0.\n"
		"cbf_get_axis_depends_on sets *depends_on to the immediate ancestor of \n"
		"axis_id or to  \". \" if there is no such ancestor. \n"
		"cbf_get_axis_equipment sets *equipment to the equipment of axis_id or \n"
		"to  \". \" if there is no such equipment. \n"
		"cbf_get_axis_equipment_component sets *equipment_component to the \n"
		"equipment_component of axis_id or to  \". \" if there is no such \n"
		"equipment_component.\n"
		"cbf_get_axis_offset sets *offset1, *offset2 and *offset3 to the \n"
		"components of the ofset of axis_id.\n"
		"cbf_get_axis_rotation sets rotation to the rotation of axis_id or to \n"
		"0 if there is no such rotation. cbf_get_axis_rotation_axis sets \n"
		"*rotation_axis to the rotation_axis of axis_id or to  \". \" if there \n"
		"is no such rotation_axis.\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id. Any of the destination pointers may be \n"
		"NULL.\n"
		"cbf_get_axis_type sets axis_type to the type of axis_id.\n"
		"cbf_get_axis_vector sets *vector1, *vector2 and *vector3 to the \n"
		"components of the vector of axis_id.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle                CBF handle. reserved              Unused. Any \n"
		"value other than 0 is invalid. axis_id               Axis id. \n"
		"ancestor_index        Integer index of the desired ancestor, starting \n"
		"with 0 for the current axis_id. ancestor              Pointer to \n"
		"destination ancestor name pointer. depends_on            Pointer to \n"
		"destination depends_on name pointer. equipment             Pointer to \n"
		"destination equipment name pointer. equipment_component   Pointer to \n"
		"destination equipment_component name pointer. offset1               \n"
		"Pointer to destination first offset component value. offset2          \n"
		"     Pointer to destination second offset component value. offset3    \n"
		"           Pointer to destination third offset component value. \n"
		"rotation              Pointer to destination rotation value. \n"
		"rotation_axis         Pointer to destination rotation_axisn name \n"
		"pointer. start                 Pointer to the destination start \n"
		"value. increment             Pointer to the destination increment \n"
		"value. type                  Pointer to destination axis type of type \n"
		". vector1               Pointer to destination first vector component \n"
		"value. vector2               Pointer to destination second vector \n"
		"component value. vector3               Pointer to destination third \n"
		"vector component value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_bin_sizes", _wrap_cbf_handle_struct_get_bin_sizes, METH_VARARGS, "\n"
		"\n"
		"Returns : Float slowbinsize,Float fastbinsize\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_bin_sizes(cbf_handle handle,\n"
		"                 unsigned int element_number,      double * slowbinsize,\n"
		"                 double * fastbinsize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_bin_sizes sets slowbinsize to point to the value of the \n"
		"number of pixels composing one array element in the dimension that \n"
		"changes at the second-fastest rate and fastbinsize to point to the \n"
		"value of the number of pixels composing one array element in the \n"
		"dimension that changes at the fastest rate for the dectector element \n"
		"with the ordinal element_number. cbf_set_bin_sizes sets the the pixel \n"
		"bin sizes in the  \"array_intensities \" category to the values of \n"
		"slowbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the second-fastest rate and \n"
		"fastbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate for the dectector \n"
		"element with the ordinal element_number.\n"
		"In order to allow for software binning involving fractions of pixels, \n"
		"the bin sizes are doubles rather than ints.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. slowbinsize      Pointer to the \n"
		"returned number of pixels composing one array element in the \n"
		"dimension that changes at the second-fastest rate. fastbinsize      \n"
		"Pointer to the returned number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate. slowbinsize_in   \n"
		"The number of pixels composing one array element in the dimension \n"
		"that changes at the second-fastest rate. fastbinsize_in   The number \n"
		"of pixels composing one array element in the dimension that changes \n"
		"at the fastest rate.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_crystal_id", _wrap_cbf_handle_struct_get_crystal_id, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_crystal_id (cbf_handle handle,\n"
		"                 const char **crystal_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_crystal_id sets *crystal_id to point to the ASCII value of \n"
		"the  \"diffrn.crystal_id \" entry.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"The value will be valid as long as the item exists and has not been \n"
		"set to a new value.\n"
		"The value must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. crystal_id   Pointer to the destination \n"
		"value pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_datestamp", _wrap_cbf_handle_struct_get_datestamp, METH_O, "\n"
		"\n"
		"Returns : int year,int month,int day,int hour,int minute,double second,\n"
		"          int timezone\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_datestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 int      *year, int *month, int *day, int *hour, int *minute,\n"
		"                 double *second, int      *timezone);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_datestamp sets *year, *month, *day, *hour, *minute and \n"
		"*second to the corresponding values of the collection timestamp. \n"
		"*timezone is set to timezone difference from UTC in minutes. The \n"
		"parameter < i>reserved is presently unused and should be set to 0.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused. Any value other than 0 is \n"
		"invalid. year       Pointer to the destination timestamp year. month  \n"
		"    Pointer to the destination timestamp month (1-12). day        \n"
		"Pointer to the destination timestamp day (1-31). hour       Pointer \n"
		"to the destination timestamp hour (0-23). minute     Pointer to the \n"
		"destination timestamp minute (0-59). second     Pointer to the \n"
		"destination timestamp second (0-60.0). timezone   Pointer to the \n"
		"destination timezone difference from UTC in minutes.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_dictionary", _wrap_cbf_handle_struct_get_dictionary, METH_O, "\n"
		"\n"
		"Returns : CBFHandle dictionary\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_dictionary (cbf_handle handle,\n"
		"                 cbf_handle * dictionary);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_dictionary sets *dictionary to the handle of a CBF which has \n"
		"been associated with the CBF handle by cbf_set_dictionary. \n"
		"cbf_set_dictionary associates the CBF handle dictionary_in with \n"
		"handle as its dictionary. cbf_require_dictionary sets *dictionary to \n"
		"the handle of a CBF which has been associated with the CBF handle by \n"
		"cbf_set_dictionary or creates a new empty CBF and associates it with \n"
		"handle, returning the new handle in *dictionary.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. dictionary      Pointer to CBF handle of \n"
		"dictionary. dictionary_in   CBF handle of dcitionary.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_diffrn_id", _wrap_cbf_handle_struct_get_diffrn_id, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_diffrn_id (cbf_handle handle,\n"
		"                 const char **diffrn_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_diffrn_id sets *diffrn_id to point to the ASCII value of the  \n"
		"\"diffrn.id \" entry. cbf_require_diffrn_id also sets *diffrn_id to \n"
		"point to the ASCII value of the  \"diffrn.id \" entry, but, if the  \n"
		"\"diffrn.id \" entry does not exist, it sets the value in the CBF and \n"
		"in*diffrn_id to the character string given by default_id, creating \n"
		"the category and column is necessary.\n"
		"The diffrn_id will be valid as long as the item exists and has not \n"
		"been set to a new value.\n"
		"The diffrn_id must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. diffrn_id    Pointer to the destination \n"
		"value pointer. default_id   Character string default value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_divergence", _wrap_cbf_handle_struct_get_divergence, METH_O, "\n"
		"\n"
		"Returns : Float div_x_source,Float div_y_source,Float div_x_y_source\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_divergence (cbf_handle handle, double *div_x_source,\n"
		"                 double      *div_y_source, double *div_x_y_source);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_divergence sets *div_x_source, *div_y_source and \n"
		"*div_x_y_source to the corresponding source divergence parameters.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. div_x_source     Pointer to the \n"
		"destination div_x_source. div_y_source     Pointer to the destination \n"
		"div_y_source. div_x_y_source   Pointer to the destination \n"
		"div_x_y_source.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_doublevalue", _wrap_cbf_handle_struct_get_doublevalue, METH_O, "\n"
		"\n"
		"Returns : double\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_doublevalue (cbf_handle handle, double *number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_doublevalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal floating-point \n"
		"number. cbf_require_doublevalue sets *number to the value of the \n"
		"ASCII item at the current column and row interpreted as a decimal \n"
		"floating-point number, setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         Pointer to the destination \n"
		"number. defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_element_id", _wrap_cbf_handle_struct_get_element_id, METH_VARARGS, "\n"
		"\n"
		"Returns : String\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_element_id (cbf_handle handle,\n"
		"                 unsigned int element_number,      const char **element_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_element_number sets element_number to a number that can be \n"
		"used in other cbf_simple calls to identify the detector element \n"
		"element_id and optionally the specific array_id> and \n"
		"array_section_id. cbf_get_element_id sets *element_id to point to the \n"
		"ASCII value of the element_number'th  \n"
		"\"diffrn_data_frame.detector_element_id \" entry, counting from 0. \n"
		"The element_number is the ordinal of the detector element in the \n"
		"DIFFRN_DETECTOR_ELEMENT category. If an array_section_id is specified \n"
		"(i.e. is not NULL), the element_number is the sum of the ordinal of \n"
		"the detector element plus the number of detector elements multiplied \n"
		"by the ordinal of array_section_id for the specified array_id> in the \n"
		"ARRAY_STRUCTURE_LIST_SECTION category.\n"
		"If the detector element does not exist, the function returns \n"
		"CBF_NOTFOUND.\n"
		"The element_id will be valid as long as the item exists and has not \n"
		"been set to a new value.\n"
		"The element_id must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle             CBF handle. element_number     The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. element_id         Pointer to the \n"
		"destination string for cbf_get_element_id, but the string itself for \n"
		"cbf_get_element_number. array_id           The optional array id or \n"
		"NULL. array_section_id   The optional array_section_id or NULL.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_element_number", _wrap_cbf_handle_struct_get_element_number, METH_O, "cbf_handle_struct_get_element_number(cbf_handle_struct self)"},
	 { "cbf_handle_struct_get_gain", _wrap_cbf_handle_struct_get_gain, METH_VARARGS, "\n"
		"\n"
		"Returns : Float gain,Float gain_esd\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_gain (cbf_handle handle, unsigned int element_number,\n"
		"                 double      *gain, double *gain_esd);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_gain sets *gain and *gain_esd to the corresponding gain \n"
		"parameters for element number element_number.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. gain             Pointer to the \n"
		"destination gain. gain_esd         Pointer to the destination \n"
		"gain_esd.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_image_as_string", _wrap_cbf_handle_struct_get_image_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_image_fs_as_string", _wrap_cbf_handle_struct_get_image_fs_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimfast,int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_image_fs (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimfast, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_image_sf_as_string", _wrap_cbf_handle_struct_get_image_sf_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_image_sf (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_image_size", _wrap_cbf_handle_struct_get_image_size, METH_VARARGS, "\n"
		"\n"
		"Returns : size_t ndim1,size_t ndim2\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_image_size (cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, size_t *ndimslow,\n"
		"                 size_t *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_image_size_fs", _wrap_cbf_handle_struct_get_image_size_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : size_t ndimfast,size_t ndimslow\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_image_size_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimfast, size_t *ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_image_size_sf", _wrap_cbf_handle_struct_get_image_size_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : size_t ndimslow,size_t ndimfast\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_image_size_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimslow, size_t *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integerarray_as_string", _wrap_cbf_handle_struct_get_integerarray_as_string, METH_O, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarray (cbf_handle handle, int *binary_id,\n"
		"                 void *array,    size_t elsize, int elsigned, size_t elements,\n"
		"                 size_t *elements_read);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarray reads the binary value of the item at the \n"
		"current column and row into an integer array. The array consists of \n"
		"elements elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsigned is non-0 and unsigned otherwise. \n"
		"*binary_id is set to the binary section identifier and *elements_read \n"
		"to the number of elements actually read. cbf_get_realarray reads the \n"
		"binary value of the item at the current column and row into a real \n"
		"array. The array consists of elements elements of elsize bytes each, \n"
		"starting at array. *binary_id is set to the binary section identifier \n"
		"and *elements_read to the number of elements actually read.\n"
		"If any element in the integer binary data cant fit into the \n"
		"destination element, the destination is set the nearest possible \n"
		"value.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"If the requested number of elements cant be read, the function will \n"
		"read as many as it can and then return CBF_ENDOFDATA.\n"
		"Currently, the destination array must consist of chars, shorts or \n"
		"ints (signed or unsigned). If elsize is not equal to sizeof (char), \n"
		"sizeof (short) or sizeof (int), for cbf_get_integerarray, or \n"
		"sizeof(double) or sizeof(float), for cbf_get_realarray the function \n"
		"returns CBF_ARGUMENT.\n"
		"An additional restriction in the current version of CBFlib is that \n"
		"values too large to fit in an int are not correctly decompressed. As \n"
		"an example, if the machine with 32-bit ints is reading an array \n"
		"containing a value outside the range 0 .. 2^^32-1 (unsigned) or \n"
		"-2^^31 .. 2^^31-1 (signed), the array will not be correctly \n"
		"decompressed. This restriction will be removed in a future release. \n"
		"For cbf_get_realarray, only IEEE format is supported. No conversion \n"
		"to other floating point formats is done at this time.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. binary_id       Pointer to the \n"
		"destination integer binary identifier. array           Pointer to the \n"
		"destination array. elsize          Size in bytes of each destination \n"
		"array element. elsigned        Set to non-0 if the destination array \n"
		"elements are signed. elements        The number of elements to read. \n"
		"elements_read   Pointer to the destination number of elements \n"
		"actually read.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integerarrayparameters", _wrap_cbf_handle_struct_get_integerarrayparameters, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integerarrayparameters_wdims", _wrap_cbf_handle_struct_get_integerarrayparameters_wdims, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement,char **bo,int *bolen,\n"
		"          int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters_wdims (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement, const    char **byteorder,\n"
		"                 size_t *dimfast, size_t *dimmid, size_t *dimslow,\n"
		"                 size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integerarrayparameters_wdims_fs", _wrap_cbf_handle_struct_get_integerarrayparameters_wdims_fs, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement,char **bo,int *bolen,\n"
		"          int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters_wdims_fs (cbf_handle handle,\n"
		"                 unsigned    int *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement, const    char **byteorder,\n"
		"                 size_t *dimfast, size_t *dimmid, size_t *dimslow,\n"
		"                 size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integerarrayparameters_wdims_sf", _wrap_cbf_handle_struct_get_integerarrayparameters_wdims_sf, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement,char **bo,int *bolen,\n"
		"          int dimslow,int dimmid,int dimfast,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters_wdims_sf (cbf_handle handle,\n"
		"                 unsigned    int *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement, const    char **byteorder,\n"
		"                 size_t *dimslow, size_t *dimmid, size_t *dimfast,\n"
		"                 size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integervalue", _wrap_cbf_handle_struct_get_integervalue, METH_O, "\n"
		"\n"
		"Returns : int\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integervalue (cbf_handle handle, int *number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integervalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal integer. \n"
		"cbf_require_integervalue sets *number to the value of the ASCII item \n"
		"at the current column and row interpreted as a decimal integer, \n"
		"setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         pointer to the number. \n"
		"defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_integration_time", _wrap_cbf_handle_struct_get_integration_time, METH_O, "\n"
		"\n"
		"Returns : Float time\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integration_time (cbf_handle handle,\n"
		"                 unsigned int reserved,      double *time);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integration_time sets *time to the integration time in \n"
		"seconds. The parameter reserved is presently unused and should be set \n"
		"to 0.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused. Any value other than 0 is \n"
		"invalid. time       Pointer to the destination time.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_orientation_matrix", _wrap_cbf_handle_struct_get_orientation_matrix, METH_O, "\n"
		"\n"
		"Returns : Float matrix_0,Float matrix_1,Float matrix_2,Float matrix_3,\n"
		"          Float matrix_4,Float matrix_5,Float matrix_6,Float matrix_7,\n"
		"          Float matrix_8\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_orientation_matrix (cbf_handle handle,\n"
		"                 double ub_matrix[9]);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_orientation_matrix sets ub_matrix to point to the array of \n"
		"orientation matrix entries in the  \"diffrn \" category in the order \n"
		"of columns:\n"
		" \"UB[1][1] \"  \"UB[1][2] \"  \"UB[1][3] \"  \"UB[2][1] \"  \n"
		"\"UB[2][2] \"  \"UB[2][3] \"  \"UB[3][1] \"  \"UB[3][2] \"  \n"
		"\"UB[3][3] \"\n"
		"cbf_set_orientation_matrix sets the values in the  \"diffrn \" \n"
		"category to the values pointed to by ub_matrix.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. ubmatric   Source or destination array of 9 \n"
		"doubles giving the orientation matrix parameters.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_overload", _wrap_cbf_handle_struct_get_overload, METH_VARARGS, "\n"
		"\n"
		"Returns : Float overload\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_overload (cbf_handle handle,\n"
		"                 unsigned int element_number,      double *overload);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_overload sets *overload to the overload value for element \n"
		"number element_number.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. overload         Pointer to the \n"
		"destination overload.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_pixel_size", _wrap_cbf_handle_struct_get_pixel_size, METH_VARARGS, "\n"
		"\n"
		"Returns : Float pixel_size\n"
		"*args   : Int element_number,Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_pixel_size (cbf_handle handle,\n"
		"                 unsigned int element_number,      int axis_number,\n"
		"                 double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_size and cbf_get_pixel_size_sf set *psize to point to \n"
		"the double value in millimeters of the axis axis_number of the \n"
		"detector element element_number. The axis_number is numbered from 1, \n"
		"starting with the slowest axis. cbf_get_pixel_size_fs sets *psize to \n"
		"point to the double value in millimeters of the axis axis_number of \n"
		"the detector element element_number. The axis_number is numbered from \n"
		"1, starting with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"\" category, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, starting from 1 for the fastest for cbf_get_pixel_size and \n"
		"cbf_get_pixel_size_fs and the slowest for cbf_get_pixel_size_sf. \n"
		"psize            Pointer to the destination pixel size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_pixel_size_fs", _wrap_cbf_handle_struct_get_pixel_size_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : Float pixel_size\n"
		"*args   : Int element_number,Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_pixel_size_fs(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_size and cbf_get_pixel_size_sf set *psize to point to \n"
		"the double value in millimeters of the axis axis_number of the \n"
		"detector element element_number. The axis_number is numbered from 1, \n"
		"starting with the slowest axis. cbf_get_pixel_size_fs sets *psize to \n"
		"point to the double value in millimeters of the axis axis_number of \n"
		"the detector element element_number. The axis_number is numbered from \n"
		"1, starting with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"\" category, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, starting from 1 for the fastest for cbf_get_pixel_size and \n"
		"cbf_get_pixel_size_fs and the slowest for cbf_get_pixel_size_sf. \n"
		"psize            Pointer to the destination pixel size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_pixel_size_sf", _wrap_cbf_handle_struct_get_pixel_size_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : Float pixel_size\n"
		"*args   : Int element_number,Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_pixel_size_sf(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_size and cbf_get_pixel_size_sf set *psize to point to \n"
		"the double value in millimeters of the axis axis_number of the \n"
		"detector element element_number. The axis_number is numbered from 1, \n"
		"starting with the slowest axis. cbf_get_pixel_size_fs sets *psize to \n"
		"point to the double value in millimeters of the axis axis_number of \n"
		"the detector element element_number. The axis_number is numbered from \n"
		"1, starting with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"\" category, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, starting from 1 for the fastest for cbf_get_pixel_size and \n"
		"cbf_get_pixel_size_fs and the slowest for cbf_get_pixel_size_sf. \n"
		"psize            Pointer to the destination pixel size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_polarization", _wrap_cbf_handle_struct_get_polarization, METH_O, "\n"
		"\n"
		"Returns : float polarizn_source_ratio,float polarizn_source_norm\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_polarization (cbf_handle handle,\n"
		"                 double      *polarizn_source_ratio,\n"
		"                 double *polarizn_source_norm);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_polarization sets *polarizn_source_ratio and \n"
		"*polarizn_source_norm to the corresponding source polarization \n"
		"parameters.\n"
		"Either destination pointer may be NULL.\n"
		"ARGUMENTS\n"
		"handle                  CBF handle. polarizn_source_ratio   Pointer \n"
		"to the destination polarizn_source_ratio. polarizn_source_norm    \n"
		"Pointer to the destination polarizn_source_norm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_real_3d_image_as_string", _wrap_cbf_handle_struct_get_real_3d_image_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimmid,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_3d_image (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_real_3d_image_fs_as_string", _wrap_cbf_handle_struct_get_real_3d_image_fs_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimfast,int ndimmid,int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_real_3d_image_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimfast,\n"
		"                 size_t ndimmid, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_real_3d_image_sf_as_string", _wrap_cbf_handle_struct_get_real_3d_image_sf_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimmid,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_3d_image_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_real_image_as_string", _wrap_cbf_handle_struct_get_real_image_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_image (cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, void *array, size_t elsize,\n"
		"                 size_t      ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_real_image_fs_as_string", _wrap_cbf_handle_struct_get_real_image_fs_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimfast,int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_real_image_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimfast,\n"
		"                 size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_real_image_sf_as_string", _wrap_cbf_handle_struct_get_real_image_sf_as_string, METH_VARARGS, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_image_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow×ndimfast elements of elsize bytes each, starting \n"
		"at array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of \n"
		"ndimslow×ndimmid×ndimfast elements of elsize bytes each, starting at \n"
		"array. The elements are signed if elsign is non-0 and unsigned \n"
		"otherwise. cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_realarray_as_string", _wrap_cbf_handle_struct_get_realarray_as_string, METH_O, "\n"
		"\n"
		"Returns : (Binary)String\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarray (cbf_handle handle, int *binary_id,\n"
		"                 void *array,    size_t elsize, size_t elements,\n"
		"                 size_t *elements_read);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarray reads the binary value of the item at the \n"
		"current column and row into an integer array. The array consists of \n"
		"elements elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsigned is non-0 and unsigned otherwise. \n"
		"*binary_id is set to the binary section identifier and *elements_read \n"
		"to the number of elements actually read. cbf_get_realarray reads the \n"
		"binary value of the item at the current column and row into a real \n"
		"array. The array consists of elements elements of elsize bytes each, \n"
		"starting at array. *binary_id is set to the binary section identifier \n"
		"and *elements_read to the number of elements actually read.\n"
		"If any element in the integer binary data cant fit into the \n"
		"destination element, the destination is set the nearest possible \n"
		"value.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"If the requested number of elements cant be read, the function will \n"
		"read as many as it can and then return CBF_ENDOFDATA.\n"
		"Currently, the destination array must consist of chars, shorts or \n"
		"ints (signed or unsigned). If elsize is not equal to sizeof (char), \n"
		"sizeof (short) or sizeof (int), for cbf_get_integerarray, or \n"
		"sizeof(double) or sizeof(float), for cbf_get_realarray the function \n"
		"returns CBF_ARGUMENT.\n"
		"An additional restriction in the current version of CBFlib is that \n"
		"values too large to fit in an int are not correctly decompressed. As \n"
		"an example, if the machine with 32-bit ints is reading an array \n"
		"containing a value outside the range 0 .. 2^^32-1 (unsigned) or \n"
		"-2^^31 .. 2^^31-1 (signed), the array will not be correctly \n"
		"decompressed. This restriction will be removed in a future release. \n"
		"For cbf_get_realarray, only IEEE format is supported. No conversion \n"
		"to other floating point formats is done at this time.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. binary_id       Pointer to the \n"
		"destination integer binary identifier. array           Pointer to the \n"
		"destination array. elsize          Size in bytes of each destination \n"
		"array element. elsigned        Set to non-0 if the destination array \n"
		"elements are signed. elements        The number of elements to read. \n"
		"elements_read   Pointer to the destination number of elements \n"
		"actually read.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_realarrayparameters", _wrap_cbf_handle_struct_get_realarrayparameters, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elements\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_realarrayparameters_wdims", _wrap_cbf_handle_struct_get_realarrayparameters_wdims, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elements,char **bo,\n"
		"          int *bolen,int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters_wdims (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements, const char    **byteorder, size_t *dimfast,\n"
		"                 size_t *dimmid, size_t *dimslow, size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_realarrayparameters_wdims_fs", _wrap_cbf_handle_struct_get_realarrayparameters_wdims_fs, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elements,char **bo,\n"
		"          int *bolen,int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters_wdims_fs (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements, const char    **byteorder, size_t *dimfast,\n"
		"                 size_t *dimmid, size_t *dimslow, size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_realarrayparameters_wdims_sf", _wrap_cbf_handle_struct_get_realarrayparameters_wdims_sf, METH_O, "\n"
		"\n"
		"Returns : int compression,int binary_id,int elsize,int elements,char **bo,\n"
		"          int *bolen,int dimslow,int dimmid,int dimfast,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters_wdims_sf (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements, const char    **byteorder, size_t *dimslow,\n"
		"                 size_t *dimmid, size_t *dimfast, size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_reciprocal_cell", _wrap_cbf_handle_struct_get_reciprocal_cell, METH_O, "\n"
		"\n"
		"Returns : Float astar,Float bstar,Float cstar,Float alphastar,Float betastar,\n"
		"          Float gammastar\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_reciprocal_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_reciprocal_cell sets cell[0:2] to the double values of the \n"
		"reciprocal cell edge lengths a^*, b^* and c^* in Ångstroms^-1, \n"
		"cell[3:5] to the double values of the reciprocal cell angles α^*, β^* \n"
		"and γ^* in degrees, cell_esd[0:2] to the double values of the \n"
		"estimated strandard deviations of the reciprocal cell edge lengths \n"
		"a^*, b^* and c^* in Ångstroms^-1, cell_esd[3:5] to the double values \n"
		"of the estimated standard deviations of the the reciprocal cell \n"
		"angles α^*, β^* and γ^* in degrees.\n"
		"The values returned are retrieved from the first row of the  \"cell \n"
		"\" category. The value of  \"_cell.entry_id \" is ignored.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the reciprocal cell parameters are not retrieved.\n"
		"If cell_esd is NULL, the reciprocal cell parameter esds are not \n"
		"retrieved.\n"
		"If the  \"cell \" category is present, but some of the values are \n"
		"missing, zeros are returned for the missing values.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the destination array of \n"
		"6 doubles for the reciprocal cell parameters. cell_esd   Pointer to \n"
		"the destination array of 6 doubles for the reciprocal cell parameter \n"
		"esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. No errors is \n"
		"returned for missing values if the  \"cell \" category exists.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_reciprocal_cell_esd", _wrap_cbf_handle_struct_get_reciprocal_cell_esd, METH_O, "cbf_handle_struct_get_reciprocal_cell_esd(cbf_handle_struct self)"},
	 { "cbf_handle_struct_get_timestamp", _wrap_cbf_handle_struct_get_timestamp, METH_O, "\n"
		"\n"
		"Returns : Float time,Integer timezone\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_timestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 double      *time, int *timezone);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_timestamp sets *time to the collection timestamp in seconds \n"
		"since January 1 1970. *timezone is set to timezone difference from \n"
		"UTC in minutes. The parameter reserved is presently unused and should \n"
		"be set to 0.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused. Any value other than 0 is \n"
		"invalid. time       Pointer to the destination collection timestamp. \n"
		"timezone   Pointer to the destination timezone difference.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_typeofvalue", _wrap_cbf_handle_struct_get_typeofvalue, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_typeofvalue (cbf_handle handle,\n"
		"                 const char **typeofvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_value sets *typeofvalue to point an ASCII descriptor of the \n"
		"value of the item at the current column and row. The strings that may \n"
		"be returned are:\n"
		" \"null \" for a null value indicated by a  \". \" or a  \"? \"  \n"
		"\"bnry \" for a binary value  \"word \" for an unquoted string  \n"
		"\"dblq \" for a double-quoted string  \"sglq \" for a single-quoted \n"
		"string  \"text \" for a semicolon-quoted string (multiline text \n"
		"field)  \"prns \" for a parenthesis-bracketed string (multiline text \n"
		"field)  \"brcs \" for a brace-bracketed string (multiline text field) \n"
		" \"bkts \" for a square-bracket-bracketed string (multiline text \n"
		"field)  \"tsqs \" for a treble-single-quote quoted string (multiline \n"
		"text field)  \"tdqs \" for a treble-double-quote quoted string \n"
		"(multiline text field)\n"
		"Not all types are valid for all type of CIF files. In partcular the \n"
		"types  \"prns \",  \"brcs \",  \"bkts \" were introduced with DDLm \n"
		"and are not valid in DDL1 or DDL2 CIFS. The types  \"tsqs \" and  \n"
		"\"tdqs \" are not formally part of the CIF syntax. A field for which \n"
		"no value has been set sets *typeofvalue to NULL rather than to the \n"
		"string  \"null \".\n"
		"The typeofvalue must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. typeofvalue   Pointer to the destination \n"
		"type-of-value string pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_unit_cell", _wrap_cbf_handle_struct_get_unit_cell, METH_O, "\n"
		"\n"
		"Returns : Float a,Float b,Float c,Float alpha,Float beta,Float gamma\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_unit_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_unit_cell sets cell[0:2] to the double values of the cell \n"
		"edge lengths a, b and c in Ångstroms, cell[3:5] to the double values \n"
		"of the cell angles α, β and γ in degrees, cell_esd[0:2] to the double \n"
		"values of the estimated strandard deviations of the cell edge lengths \n"
		"a, b and c in Ångstroms, cell_esd[3:5] to the double values of the \n"
		"estimated standard deviations of the the cell angles α, β and γ in \n"
		"degrees.\n"
		"The values returned are retrieved from the first row of the  \"cell \n"
		"\" category. The value of  \"_cell.entry_id \" is ignored.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the cell parameters are not retrieved.\n"
		"If cell_esd is NULL, the cell parameter esds are not retrieved.\n"
		"If the  \"cell \" category is present, but some of the values are \n"
		"missing, zeros are returned for the missing values.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the destination array of \n"
		"6 doubles for the cell parameters. cell_esd   Pointer to the \n"
		"destination array of 6 doubles for the cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. No errors is \n"
		"returned for missing values if the  \"cell \" category exists.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_unit_cell_esd", _wrap_cbf_handle_struct_get_unit_cell_esd, METH_O, "cbf_handle_struct_get_unit_cell_esd(cbf_handle_struct self)"},
	 { "cbf_handle_struct_get_value", _wrap_cbf_handle_struct_get_value, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_value (cbf_handle handle, const char **value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_value sets *value to point to the ASCII value of the item at \n"
		"the current column and row. cbf_require_value sets *value to point to \n"
		"the ASCII value of the item at the current column and row, creating \n"
		"the data item if necessary and initializing it to a copy of \n"
		"defaultvalue.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"The value will be valid as long as the item exists and has not been \n"
		"set to a new value.\n"
		"The value must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. value          Pointer to the destination \n"
		"value pointer. defaultvalue   Default value character string.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_get_wavelength", _wrap_cbf_handle_struct_get_wavelength, METH_O, "\n"
		"\n"
		"Returns : double\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_wavelength (cbf_handle handle, double *wavelength);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_wavelength sets *wavelength to the current wavelength in Å.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. wavelength   Pointer to the destination.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_insert_row", _wrap_cbf_handle_struct_insert_row, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_insert_row (cbf_handle handle, unsigned int rownumber);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_insert_row adds a new row to the current category. The new row is \n"
		"inserted as row rownumber and existing rows starting from rownumber \n"
		"are moved up by 1. The new row becomes the current row.\n"
		"If the category has fewer than rownumber rows, the function returns \n"
		"CBF_NOTFOUND.\n"
		"The row numbers start from 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. rownumber   The row number of the new row.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_new_category", _wrap_cbf_handle_struct_new_category, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_category creates a new category in the current data block \n"
		"with name categoryname and makes it the current category.\n"
		"If a category with this name already exists, the existing category \n"
		"becomes the current category.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the new \n"
		"category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_new_column", _wrap_cbf_handle_struct_new_column, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_column (cbf_handle handle, const char *columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_column creates a new column in the current category with name \n"
		"columnname and makes it the current column.\n"
		"If a column with this name already exists, the existing column \n"
		"becomes the current category.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   The name of the new column.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_new_datablock", _wrap_cbf_handle_struct_new_datablock, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_datablock (cbf_handle handle,\n"
		"                 const char *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_datablock creates a new data block with name datablockname \n"
		"and makes it the current data block. cbf_new_saveframe creates a new \n"
		"save frame with name saveframename within the current data block and \n"
		"makes the new save frame the current save frame.\n"
		"If a data block or save frame with this name already exists, the \n"
		"existing data block or save frame becomes the current data block or \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_new_row", _wrap_cbf_handle_struct_new_row, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_row adds a new row to the current category and makes it the \n"
		"current row.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_new_saveframe", _wrap_cbf_handle_struct_new_saveframe, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_saveframe (cbf_handle handle,\n"
		"                 const char *saveframename);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_datablock creates a new data block with name datablockname \n"
		"and makes it the current data block. cbf_new_saveframe creates a new \n"
		"save frame with name saveframename within the current data block and \n"
		"makes the new save frame the current save frame.\n"
		"If a data block or save frame with this name already exists, the \n"
		"existing data block or save frame becomes the current data block or \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_next_category", _wrap_cbf_handle_struct_next_category, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_category makes the category following the current category \n"
		"in the current data block the current category.\n"
		"If there are no more categories, the function returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_next_column", _wrap_cbf_handle_struct_next_column, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_column (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_column makes the column following the current column in the \n"
		"current category the current column.\n"
		"If there are no more columns, the function returns CBF_NOTFOUND.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_next_datablock", _wrap_cbf_handle_struct_next_datablock, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_datablock makes the data block following the current data \n"
		"block the current data block.\n"
		"If there are no more data blocks, the function returns CBF_NOTFOUND.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_next_row", _wrap_cbf_handle_struct_next_row, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_row makes the row following the current row in the current \n"
		"category the current row.\n"
		"If there are no more rows, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_read_file", _wrap_cbf_handle_struct_read_file, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String filename,Integer headers\n"
		"\n"
		"C prototype: int cbf_read_file (cbf_handle handle, FILE *file, int flags);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_read_file reads the CBF or CIF file file into the CBF object \n"
		"specified by handle, using the CIF 1.0 convention of 80 character \n"
		"lines. cbf_read_widefile reads the CBF or CIF file file into the CBF \n"
		"object specified by handle, using the CIF 1.1 convention of 2048 \n"
		"character lines. A warning is issued to stderr for ascii lines over \n"
		"the limit. No test is performed on binary sections.\n"
		"Validation is performed in three ways levels: during the lexical \n"
		"scan, during the parse, and, if a dictionary was converted, against \n"
		"the value types, value enumerations, categories and parent-child \n"
		"relationships specified in the dictionary.\n"
		"flags controls the interpretation of binary section headers, the \n"
		"parsing of brackets constructs and the parsing of treble-quoted \n"
		"strings.\n"
		"MSG_DIGEST:               Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digest value. If the digests \n"
		"do not match, the call will return CBF_FORMAT. This evaluation and \n"
		"comparison is delayed (a  \"lazy \" evaluation) to ensure maximal \n"
		"processing efficiency. If an immediately evaluation is required, see \n"
		"MSG_DIGESTNOW, below. MSG_DIGESTNOW:            Instructs CBFlib to \n"
		"check that the digest of the binary section matches any header \n"
		"digeste value. If the digests do not match, the call will return \n"
		"CBF_FORMAT. This evaluation and comparison is performed during \n"
		"initial parsing of the section to ensure timely error reporting at \n"
		"the expense of processing efficiency. If a more efficient delayed ( \n"
		"\"lazy \") evaluation is required, see MSG_DIGEST, above. \n"
		"MSG_DIGESTWARN:           Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digeste value. If the \n"
		"digests do not match, a warning message will be sent to stderr, but \n"
		"processing will attempt to continue. This evaluation and comparison \n"
		"is first performed during initial parsing of the section to ensure \n"
		"timely error reporting at the expense of processing efficiency. An \n"
		"mismatch of the message digest usually indicates a serious error, but \n"
		"it is sometimes worth continuing processing to try to isolate the \n"
		"cause of the error. Use this option with caution. MSG_NODIGEST:       \n"
		"      Do not check the digest (default). PARSE_BRACKETS:           \n"
		"Accept DDLm bracket-delimited [item,item,...item] or \n"
		"{item,item,...item} or (item,item,...item) constructs as valid, \n"
		"stripping non-quoted embedded whitespace and comments. These \n"
		"constructs may span multiple lines. PARSE_LIBERAL_BRACKETS:   Accept \n"
		"DDLm bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping embedded \n"
		"non-quoted, non-separating whitespace and comments. These constructs \n"
		"may span multiple lines. In this case, whitespace may be used as an \n"
		"alternative to the comma. PARSE_TRIPLE_QUOTES:      Accept DDLm \n"
		"triple-quoted  \" \" \"item,item,...item \" \" \" or \n"
		"'''item,item,...item''' constructs as valid, stripping embedded \n"
		"whitespace and comments. These constructs may span multiple lines. If \n"
		"this flag is set, then ''' will not be interpreted as a quoted \n"
		"apoptrophe and  \" \" \" will not be interpreted as a quoted double \n"
		"quote mark and PARSE_NOBRACKETS:         Do not accept DDLm \n"
		"bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping non-quoted \n"
		"embedded whitespace and comments. These constructs may span multiple \n"
		"lines. PARSE_NOTRIPLE_QUOTES:    No not accept DDLm triple-quoted  \" \n"
		"\" \"item,item,...item \" \" \" or '''item,item,...item''' constructs \n"
		"as valid, stripping embedded whitespace and comments. These \n"
		"constructs may span multiple lines. If this flag is set, then ''' \n"
		"will be interpreted as a quoted apostrophe and  \" \" \" will be \n"
		"interpreted as a quoted double quote mark.\n"
		"CBFlib defers reading binary sections as long as possible. In the \n"
		"current version of CBFlib, this means that:\n"
		"1. The file must be a random-access file opened in binary mode (fopen \n"
		"( ,\n"
		"\n"
		""},
	 { "cbf_handle_struct_read_template", _wrap_cbf_handle_struct_read_template, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String filename\n"
		"\n"
		"C prototype: int cbf_read_template (cbf_handle handle, FILE *file);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_read_template reads the CBF or CIF file file into the CBF object \n"
		"specified by handle and selects the first datablock as the current \n"
		"datablock.\n"
		"ARGUMENTS\n"
		"handle   Pointer to a CBF handle. file     Pointer to a file \n"
		"descriptor.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_read_widefile", _wrap_cbf_handle_struct_read_widefile, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String filename,Integer headers\n"
		"\n"
		"C prototype: int cbf_read_widefile (cbf_handle handle, FILE *file, int flags);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_read_file reads the CBF or CIF file file into the CBF object \n"
		"specified by handle, using the CIF 1.0 convention of 80 character \n"
		"lines. cbf_read_widefile reads the CBF or CIF file file into the CBF \n"
		"object specified by handle, using the CIF 1.1 convention of 2048 \n"
		"character lines. A warning is issued to stderr for ascii lines over \n"
		"the limit. No test is performed on binary sections.\n"
		"Validation is performed in three ways levels: during the lexical \n"
		"scan, during the parse, and, if a dictionary was converted, against \n"
		"the value types, value enumerations, categories and parent-child \n"
		"relationships specified in the dictionary.\n"
		"flags controls the interpretation of binary section headers, the \n"
		"parsing of brackets constructs and the parsing of treble-quoted \n"
		"strings.\n"
		"MSG_DIGEST:               Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digest value. If the digests \n"
		"do not match, the call will return CBF_FORMAT. This evaluation and \n"
		"comparison is delayed (a  \"lazy \" evaluation) to ensure maximal \n"
		"processing efficiency. If an immediately evaluation is required, see \n"
		"MSG_DIGESTNOW, below. MSG_DIGESTNOW:            Instructs CBFlib to \n"
		"check that the digest of the binary section matches any header \n"
		"digeste value. If the digests do not match, the call will return \n"
		"CBF_FORMAT. This evaluation and comparison is performed during \n"
		"initial parsing of the section to ensure timely error reporting at \n"
		"the expense of processing efficiency. If a more efficient delayed ( \n"
		"\"lazy \") evaluation is required, see MSG_DIGEST, above. \n"
		"MSG_DIGESTWARN:           Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digeste value. If the \n"
		"digests do not match, a warning message will be sent to stderr, but \n"
		"processing will attempt to continue. This evaluation and comparison \n"
		"is first performed during initial parsing of the section to ensure \n"
		"timely error reporting at the expense of processing efficiency. An \n"
		"mismatch of the message digest usually indicates a serious error, but \n"
		"it is sometimes worth continuing processing to try to isolate the \n"
		"cause of the error. Use this option with caution. MSG_NODIGEST:       \n"
		"      Do not check the digest (default). PARSE_BRACKETS:           \n"
		"Accept DDLm bracket-delimited [item,item,...item] or \n"
		"{item,item,...item} or (item,item,...item) constructs as valid, \n"
		"stripping non-quoted embedded whitespace and comments. These \n"
		"constructs may span multiple lines. PARSE_LIBERAL_BRACKETS:   Accept \n"
		"DDLm bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping embedded \n"
		"non-quoted, non-separating whitespace and comments. These constructs \n"
		"may span multiple lines. In this case, whitespace may be used as an \n"
		"alternative to the comma. PARSE_TRIPLE_QUOTES:      Accept DDLm \n"
		"triple-quoted  \" \" \"item,item,...item \" \" \" or \n"
		"'''item,item,...item''' constructs as valid, stripping embedded \n"
		"whitespace and comments. These constructs may span multiple lines. If \n"
		"this flag is set, then ''' will not be interpreted as a quoted \n"
		"apoptrophe and  \" \" \" will not be interpreted as a quoted double \n"
		"quote mark and PARSE_NOBRACKETS:         Do not accept DDLm \n"
		"bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping non-quoted \n"
		"embedded whitespace and comments. These constructs may span multiple \n"
		"lines. PARSE_NOTRIPLE_QUOTES:    No not accept DDLm triple-quoted  \" \n"
		"\" \"item,item,...item \" \" \" or '''item,item,...item''' constructs \n"
		"as valid, stripping embedded whitespace and comments. These \n"
		"constructs may span multiple lines. If this flag is set, then ''' \n"
		"will be interpreted as a quoted apostrophe and  \" \" \" will be \n"
		"interpreted as a quoted double quote mark.\n"
		"CBFlib defers reading binary sections as long as possible. In the \n"
		"current version of CBFlib, this means that:\n"
		"1. The file must be a random-access file opened in binary mode (fopen \n"
		"( ,\n"
		"\n"
		""},
	 { "cbf_handle_struct_remove_category", _wrap_cbf_handle_struct_remove_category, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_category deletes the current category.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_remove_column", _wrap_cbf_handle_struct_remove_column, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_column (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_column deletes the current column.\n"
		"The current column becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_remove_datablock", _wrap_cbf_handle_struct_remove_datablock, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_datablock deletes the current data block. \n"
		"cbf_remove_saveframe deletes the current save frame.\n"
		"The current data block becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_remove_row", _wrap_cbf_handle_struct_remove_row, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_row deletes the current row in the current category.\n"
		"If the current row was the last row, it will move down by 1, \n"
		"otherwise, it will remain the same.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_remove_saveframe", _wrap_cbf_handle_struct_remove_saveframe, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_saveframe (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_datablock deletes the current data block. \n"
		"cbf_remove_saveframe deletes the current save frame.\n"
		"The current data block becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_category", _wrap_cbf_handle_struct_require_category, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_require_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewuire_category makes the category in the current data block \n"
		"with name categoryname the current category, if it exists, or creates \n"
		"the catagory if it does not exist.\n"
		"The comparison is case-insensitive.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the category to \n"
		"find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_category_root", _wrap_cbf_handle_struct_require_category_root, METH_VARARGS, "cbf_handle_struct_require_category_root(cbf_handle_struct self, char const * categoryname) -> char const *"},
	 { "cbf_handle_struct_require_column", _wrap_cbf_handle_struct_require_column, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_require_column (cbf_handle handle,\n"
		"                 const char *columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column makes the columns in the current category with \n"
		"name columnname the current column, if it exists, or creates it if it \n"
		"does not.\n"
		"The comparison is case-insensitive.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   The name of column to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_column_doublevalue", _wrap_cbf_handle_struct_require_column_doublevalue, METH_VARARGS, "\n"
		"\n"
		"Returns : Float defaultvalue\n"
		"*args   : String columnname,Float Value\n"
		"\n"
		"C prototype: int cbf_require_column_doublevalue (cbf_handle handle,\n"
		"                 const char      *columnname, double *number,\n"
		"                 const double defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column_doublevalue sets *number to the value of the ASCII \n"
		"item at the current row for the column given with the name given by \n"
		"*columnname, with the value interpreted as a decimal floating-point \n"
		"number, or to the number given by defaultvalue if the item cannot be \n"
		"found.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. columnname     Name of the column \n"
		"containing the number. number         pointer to the location to \n"
		"receive the floating-point value. defaultvalue   Value to use if the \n"
		"requested column and value cannot be found.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_column_integervalue", _wrap_cbf_handle_struct_require_column_integervalue, METH_VARARGS, "\n"
		"\n"
		"Returns : Int Value\n"
		"*args   : String Columnvalue,Int default\n"
		"\n"
		"C prototype: int cbf_require_column_integervalue (cbf_handle handle,\n"
		"                 const char      *columnname, int *number,\n"
		"                 const int defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column_doublevalue sets *number to the value of the ASCII \n"
		"item at the current row for the column given with the name given by \n"
		"*columnname, with the value interpreted as an integer number, or to \n"
		"the number given by defaultvalue if the item cannot be found.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. columnname     Name of the column \n"
		"containing the number. number         pointer to the location to \n"
		"receive the integer value. defaultvalue   Value to use if the \n"
		"requested column and value cannot be found.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_column_value", _wrap_cbf_handle_struct_require_column_value, METH_VARARGS, "\n"
		"\n"
		"Returns : String Name\n"
		"*args   : String columnnanme,String Default\n"
		"\n"
		"C prototype: int cbf_require_column_value (cbf_handle handle,\n"
		"                 const char *columnname,      const char **value,\n"
		"                 const char *defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column_doublevalue sets *value to the ASCII item at the \n"
		"current row for the column given with the name given by *columnname, \n"
		"or to the string given by defaultvalue if the item cannot be found.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. columnname     Name of the column \n"
		"containing the number. value          pointer to the location to \n"
		"receive the value. defaultvalue   Value to use if the requested \n"
		"column and value cannot be found.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_datablock", _wrap_cbf_handle_struct_require_datablock, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_require_datablock (cbf_handle handle,\n"
		"                 const char      *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_datablock makes the data block with name datablockname \n"
		"the current data block, if it exists, or creates it if it does not.\n"
		"The comparison is case-insensitive.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the data \n"
		"block to find or create.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_doublevalue", _wrap_cbf_handle_struct_require_doublevalue, METH_VARARGS, "\n"
		"\n"
		"Returns : Float Number\n"
		"*args   : Float Default\n"
		"\n"
		"C prototype: int cbf_require_doublevalue (cbf_handle handle, double *number,\n"
		"                 double    defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_doublevalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal floating-point \n"
		"number. cbf_require_doublevalue sets *number to the value of the \n"
		"ASCII item at the current column and row interpreted as a decimal \n"
		"floating-point number, setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         Pointer to the destination \n"
		"number. defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_integervalue", _wrap_cbf_handle_struct_require_integervalue, METH_VARARGS, "\n"
		"\n"
		"Returns : Int number\n"
		"*args   : Int thedefault\n"
		"\n"
		"C prototype: int cbf_require_integervalue (cbf_handle handle, int *number,\n"
		"                 int    defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integervalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal integer. \n"
		"cbf_require_integervalue sets *number to the value of the ASCII item \n"
		"at the current column and row interpreted as a decimal integer, \n"
		"setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         pointer to the number. \n"
		"defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_reference_detector", _wrap_cbf_handle_struct_require_reference_detector, METH_VARARGS, "\n"
		"\n"
		"Returns : pycbf detector object\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_require_reference_detector (cbf_handle handle,\n"
		"                 cbf_detector      *detector, unsigned int element_number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_detector constructs a detector object for detector \n"
		"element number element_number using the description in the CBF object \n"
		"handle and initialises the detector handle *detector.\n"
		"cbf_construct_reference_detector constructs a detector object for \n"
		"detector element number element_number using the description in the \n"
		"CBF object handle and initialises the detector handle *detector using \n"
		"the reference settings of the axes. cbf_require_reference_detector is \n"
		"similar, but try to force the creations of missing intermediate \n"
		"categories needed to construct a detector object.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. detector         Pointer to the \n"
		"destination detector handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_tag_root", _wrap_cbf_handle_struct_require_tag_root, METH_VARARGS, "\n"
		"\n"
		"Returns : String tagroot\n"
		"*args   : String tagname\n"
		"\n"
		"C prototype: int cbf_require_tag_root (cbf_handle handle, const char* tagname,\n"
		"                 const      char** tagroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_root sets *tagroot to the root tag of which tagname is \n"
		"an alias. cbf_set_tag_root sets tagname as an alias of tagroot_in in \n"
		"the dictionary associated with handle, creating the dictionary if \n"
		"necessary. cbf_require_tag_root sets *tagroot to the root tag of \n"
		"which tagname is an alias, if there is one, or to the value of \n"
		"tagname, if tagname is not an alias.\n"
		"A returned tagroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. tagname      tag name which may be an alias. \n"
		"tagroot      pointer to a returned tag root name. tagroot_in   input \n"
		"tag root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_require_value", _wrap_cbf_handle_struct_require_value, METH_VARARGS, "\n"
		"\n"
		"Returns : String Value\n"
		"*args   : String defaultvalue\n"
		"\n"
		"C prototype: int cbf_require_value (cbf_handle handle, const char **value,\n"
		"                 const char    *defaultvalue );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_value sets *value to point to the ASCII value of the item at \n"
		"the current column and row. cbf_require_value sets *value to point to \n"
		"the ASCII value of the item at the current column and row, creating \n"
		"the data item if necessary and initializing it to a copy of \n"
		"defaultvalue.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"The value will be valid as long as the item exists and has not been \n"
		"set to a new value.\n"
		"The value must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. value          Pointer to the destination \n"
		"value pointer. defaultvalue   Default value character string.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_reset_category", _wrap_cbf_handle_struct_reset_category, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_category deletes all columns and rows from current category.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_reset_datablock", _wrap_cbf_handle_struct_reset_datablock, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_datablock deletes all categories from the current data \n"
		"block. cbf_reset_saveframe deletes all categories from the current \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_reset_datablocks", _wrap_cbf_handle_struct_reset_datablocks, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_datablocks (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_datablocks deletes all categories from all data blocks.\n"
		"The current data block does not change.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_reset_saveframe", _wrap_cbf_handle_struct_reset_saveframe, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_saveframe (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_datablock deletes all categories from the current data \n"
		"block. cbf_reset_saveframe deletes all categories from the current \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_rewind_blockitem", _wrap_cbf_handle_struct_rewind_blockitem, METH_O, "\n"
		"\n"
		"Returns : CBF_NODETYPE\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_blockitem (cbf_handle handle,\n"
		"                 CBF_NODETYPE * type);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_category makes the first category in the current data \n"
		"block the current category. cbf_rewind_saveframe makes the first \n"
		"saveframe in the current data block the current saveframe. \n"
		"cbf_rewind_blockitem makes the first blockitem (category or \n"
		"saveframe) in the current data block the current blockitem. The type \n"
		"of the blockitem (CBF_CATEGORY or CBF_SAVEFRAME) is returned in type.\n"
		"If there are no categories, saveframes or blockitems the function \n"
		"returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. type     CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_rewind_category", _wrap_cbf_handle_struct_rewind_category, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_category makes the first category in the current data \n"
		"block the current category. cbf_rewind_saveframe makes the first \n"
		"saveframe in the current data block the current saveframe. \n"
		"cbf_rewind_blockitem makes the first blockitem (category or \n"
		"saveframe) in the current data block the current blockitem. The type \n"
		"of the blockitem (CBF_CATEGORY or CBF_SAVEFRAME) is returned in type.\n"
		"If there are no categories, saveframes or blockitems the function \n"
		"returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. type     CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_rewind_column", _wrap_cbf_handle_struct_rewind_column, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_column (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_column makes the first column in the current category the \n"
		"current column.\n"
		"If there are no columns, the function returns CBF_NOTFOUND.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_rewind_datablock", _wrap_cbf_handle_struct_rewind_datablock, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_datablock makes the first data block the current data \n"
		"block.\n"
		"If there are no data blocks, the function returns CBF_NOTFOUND.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_rewind_row", _wrap_cbf_handle_struct_rewind_row, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_row makes the first row in the current category the \n"
		"current row.\n"
		"If there are no rows, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_rewind_saveframe", _wrap_cbf_handle_struct_rewind_saveframe, METH_O, "\n"
		"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_saveframe (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_category makes the first category in the current data \n"
		"block the current category. cbf_rewind_saveframe makes the first \n"
		"saveframe in the current data block the current saveframe. \n"
		"cbf_rewind_blockitem makes the first blockitem (category or \n"
		"saveframe) in the current data block the current blockitem. The type \n"
		"of the blockitem (CBF_CATEGORY or CBF_SAVEFRAME) is returned in type.\n"
		"If there are no categories, saveframes or blockitems the function \n"
		"returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. type     CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_row_number", _wrap_cbf_handle_struct_row_number, METH_O, "\n"
		"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_row_number (cbf_handle handle, unsigned int *row);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_row_number sets *row to the number of the current row of the \n"
		"current category.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. row      Pointer to the destination row number.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_select_category", _wrap_cbf_handle_struct_select_category, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_category (cbf_handle handle,\n"
		"                 unsigned int category);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_category selects category number category in the current \n"
		"data block as the current category.\n"
		"The first category is number 0.\n"
		"The current column and row become undefined.\n"
		"If the category does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. category   Number of the category to select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_select_column", _wrap_cbf_handle_struct_select_column, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_column (cbf_handle handle, unsigned int column);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_column selects column number column in the current \n"
		"category as the current column.\n"
		"The first column is number 0.\n"
		"The current row is not affected\n"
		"If the column does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. column   Number of the column to select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_select_datablock", _wrap_cbf_handle_struct_select_datablock, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_datablock (cbf_handle handle,\n"
		"                 unsigned int datablock);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_datablock selects data block number datablock as the \n"
		"current data block.\n"
		"The first data block is number 0.\n"
		"If the data block does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. datablock   Number of the data block to \n"
		"select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_select_row", _wrap_cbf_handle_struct_select_row, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_row (cbf_handle handle, unsigned int row);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_row selects row number row in the current category as the \n"
		"current row.\n"
		"The first row is number 0.\n"
		"The current column is not affected\n"
		"If the row does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. row      Number of the row to select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_3d_image", _wrap_cbf_handle_struct_set_3d_image, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_3d_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_3d_image_fs", _wrap_cbf_handle_struct_set_3d_image_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimfast,int dimmid,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_3d_image_fs(cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, unsigned int compression,\n"
		"                 void *array,      size_t elsize, int elsign, size_t ndimfast,\n"
		"                 size_t ndimmid, size_t      ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_3d_image_sf", _wrap_cbf_handle_struct_set_3d_image_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_3d_image_sf(cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, unsigned int compression,\n"
		"                 void *array,      size_t elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimmid, size_t      ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_axis_setting", _wrap_cbf_handle_struct_set_axis_setting, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String axis_id,Float start,Float increment\n"
		"\n"
		"C prototype: int cbf_set_axis_setting (cbf_handle handle,\n"
		"                 unsigned int reserved,      const char *axis_id, double start,\n"
		"                 double increment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_axis_setting sets the starting and increment values of the \n"
		"axis axis_id to start and increment.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. reserved    Unused. Any value other than 0 is \n"
		"invalid. axis_id     Axis id. start       Start value. increment   \n"
		"Increment value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_bin_sizes", _wrap_cbf_handle_struct_set_bin_sizes, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer element_number,Float slowbinsize_in,Float fastbinsize_in\n"
		"\n"
		"C prototype: int cbf_set_bin_sizes(cbf_handle handle,\n"
		"                 unsigned int element_number,      double slowbinsize_in,\n"
		"                double fastbinsize_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_bin_sizes sets slowbinsize to point to the value of the \n"
		"number of pixels composing one array element in the dimension that \n"
		"changes at the second-fastest rate and fastbinsize to point to the \n"
		"value of the number of pixels composing one array element in the \n"
		"dimension that changes at the fastest rate for the dectector element \n"
		"with the ordinal element_number. cbf_set_bin_sizes sets the the pixel \n"
		"bin sizes in the  \"array_intensities \" category to the values of \n"
		"slowbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the second-fastest rate and \n"
		"fastbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate for the dectector \n"
		"element with the ordinal element_number.\n"
		"In order to allow for software binning involving fractions of pixels, \n"
		"the bin sizes are doubles rather than ints.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. slowbinsize      Pointer to the \n"
		"returned number of pixels composing one array element in the \n"
		"dimension that changes at the second-fastest rate. fastbinsize      \n"
		"Pointer to the returned number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate. slowbinsize_in   \n"
		"The number of pixels composing one array element in the dimension \n"
		"that changes at the second-fastest rate. fastbinsize_in   The number \n"
		"of pixels composing one array element in the dimension that changes \n"
		"at the fastest rate.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_category_root", _wrap_cbf_handle_struct_set_category_root, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String categoryname,String categoryroot\n"
		"\n"
		"C prototype: int cbf_set_category_root (cbf_handle handle,\n"
		"                 const char*      categoryname_in, const char*categoryroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias. cbf_set_category_root sets \n"
		"categoryname_in as an alias of categoryroot in the dictionary \n"
		"associated with handle, creating the dictionary if necessary. \n"
		"cbf_require_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias, if there is one, or to the value of \n"
		"categoryname, if categoryname is not an alias.\n"
		"A returned categoryroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. categoryname      category name which \n"
		"may be an alias. categoryroot      pointer to a returned category \n"
		"root name. categoryroot_in   input category root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_crystal_id", _wrap_cbf_handle_struct_set_crystal_id, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_crystal_id (cbf_handle handle,\n"
		"                 const char *crystal_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_crystal_id sets the  \"diffrn.crystal_id \" entry to the \n"
		"ASCII value crystal_id.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. crystal_id   ASCII value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_current_timestamp", _wrap_cbf_handle_struct_set_current_timestamp, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer timezone\n"
		"\n"
		"C prototype: int cbf_set_current_timestamp (cbf_handle handle,\n"
		"                 unsigned int reserved,      int timezone);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_current_timestamp sets the collection timestamp to the \n"
		"current time. The timezone difference from UTC in minutes is set to \n"
		"timezone. If no timezone is desired, timezone should be \n"
		"CBF_NOTIMEZONE. If no timezone is used, the timest amp will be UTC. \n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"The new timestamp will have a precision of 1 second.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused.   Any value other than 0 is \n"
		"invalid. timezone   Timezone difference from UTC in minutes or \n"
		"CBF_NOTIMEZONE.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_datablockname", _wrap_cbf_handle_struct_set_datablockname, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_datablockname (cbf_handle handle,\n"
		"                 const char *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_datablockname changes the name of the current data block to \n"
		"datablockname. cbf_set_saveframename changes the name of the current \n"
		"save frame to saveframename.\n"
		"If a data block or save frame with this name already exists \n"
		"(comparison is case-insensitive), the function returns CBF_IDENTICAL.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The new data block name. \n"
		"datablockname   The new save frame name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_datestamp", _wrap_cbf_handle_struct_set_datestamp, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int year,int month,int day,int hour,int minute,double second,\n"
		"          int timezone,Float precision\n"
		"\n"
		"C prototype: int cbf_set_datestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 int      year, int month, int day, int hour, int minute,\n"
		"                 double second, int      timezone, double precision);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_datestamp sets the collection timestamp in seconds since \n"
		"January 1 1970 to the value specified by time. The timezone \n"
		"difference from UTC\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_dictionary", _wrap_cbf_handle_struct_set_dictionary, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : CBFHandle dictionary\n"
		"\n"
		"C prototype: int cbf_set_dictionary (cbf_handle handle,\n"
		"                 cbf_handle dictionary_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_dictionary sets *dictionary to the handle of a CBF which has \n"
		"been associated with the CBF handle by cbf_set_dictionary. \n"
		"cbf_set_dictionary associates the CBF handle dictionary_in with \n"
		"handle as its dictionary. cbf_require_dictionary sets *dictionary to \n"
		"the handle of a CBF which has been associated with the CBF handle by \n"
		"cbf_set_dictionary or creates a new empty CBF and associates it with \n"
		"handle, returning the new handle in *dictionary.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. dictionary      Pointer to CBF handle of \n"
		"dictionary. dictionary_in   CBF handle of dcitionary.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_diffrn_id", _wrap_cbf_handle_struct_set_diffrn_id, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_diffrn_id (cbf_handle handle, const char *diffrn_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_diffrn_id sets the  \"diffrn.id \" entry of the current \n"
		"datablock to the ASCII value diffrn_id.\n"
		"This function also changes corresponding  \"diffrn_id \" entries in \n"
		"the  \"diffrn_source \",  \"diffrn_radiation \",  \"diffrn_detector \n"
		"\" and  \"diffrn_measurement \" categories.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. diffrn_id   ASCII value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_divergence", _wrap_cbf_handle_struct_set_divergence, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Float div_x_source,Float div_y_source,Float div_x_y_source\n"
		"\n"
		"C prototype: int cbf_set_divergence (cbf_handle handle, double div_x_source,\n"
		"                 double      div_y_source, double div_x_y_source);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_divergence sets the source divergence parameters to the \n"
		"values specified by div_x_source, div_y_source and div_x_y_source.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. div_x_source     New value of \n"
		"div_x_source. div_y_source     New value of div_y_source. \n"
		"div_x_y_source   New value of div_x_y_source.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_doublevalue", _wrap_cbf_handle_struct_set_doublevalue, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String format,Float number\n"
		"\n"
		"C prototype: int cbf_set_doublevalue (cbf_handle handle, const char *format,\n"
		"                 double    number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_doublevalue sets the item at the current column and row to \n"
		"the floating-point value number written as an ASCII string with the \n"
		"format specified by format as appropriate for the printf function.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. format   Format for the number. number   \n"
		"Floating-point value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_gain", _wrap_cbf_handle_struct_set_gain, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Float gain,Float gain_esd\n"
		"\n"
		"C prototype: int cbf_set_gain (cbf_handle handle, unsigned int element_number,\n"
		"                 double      gain, double gain_esd);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_gain sets the gain of element number element_number to the \n"
		"values specified by gain and gain_esd.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. gain             New gain value. \n"
		"gain_esd         New gain_esd value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_image", _wrap_cbf_handle_struct_set_image, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_image_fs", _wrap_cbf_handle_struct_set_image_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimfast,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_image_fs(cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimfast,\n"
		"                 size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_image_sf", _wrap_cbf_handle_struct_set_image_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_image_sf(cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_integerarray", _wrap_cbf_handle_struct_set_integerarray, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elsigned,int elements\n"
		"\n"
		"C prototype: int cbf_set_integerarray (cbf_handle handle,\n"
		"                 unsigned int compression, int    binary_id, void *array,\n"
		"                 size_t elsize, int elsigned, size_t elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_integerarray_wdims", _wrap_cbf_handle_struct_set_integerarray_wdims, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elsigned,int elements,String byteorder,int dimfast,int dimmid,\n"
		"          int dimslow,int padding\n"
		"\n"
		"C prototype: int cbf_set_integerarray_wdims (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, int elsigned,    size_t elements,\n"
		"                 const char *byteorder, size_t dimfast, size_t dimmid,\n"
		"                    size_t dimslow, size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_integerarray_wdims_fs", _wrap_cbf_handle_struct_set_integerarray_wdims_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elsigned,int elements,String byteorder,int dimfast,int dimmid,\n"
		"          int dimslow,int padding\n"
		"\n"
		"C prototype: int cbf_set_integerarray_wdims_fs (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, int elsigned,    size_t elements,\n"
		"                 const char *byteorder, size_t dimfast, size_t dimmid,\n"
		"                    size_t dimslow, size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_integerarray_wdims_sf", _wrap_cbf_handle_struct_set_integerarray_wdims_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elsigned,int elements,String byteorder,int dimslow,int dimmid,\n"
		"          int dimfast,int padding\n"
		"\n"
		"C prototype: int cbf_set_integerarray_wdims_sf (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, int elsigned,    size_t elements,\n"
		"                 const char *byteorder, size_t dimslow, size_t dimmid,\n"
		"                    size_t dimfast, size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_integervalue", _wrap_cbf_handle_struct_set_integervalue, METH_VARARGS, "\n"
		"\n"
		"Returns : int number\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_integervalue (cbf_handle handle, int number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integervalue sets the item at the current column and row to \n"
		"the integer value number written as a decimal ASCII string.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. number   Integer value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_integration_time", _wrap_cbf_handle_struct_set_integration_time, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Float time\n"
		"\n"
		"C prototype: int cbf_set_integration_time (cbf_handle handle,\n"
		"                 unsigned int reserved,      double time);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integration_time sets the integration time in seconds to the \n"
		"value specified by time. The parameter reserved is presently unused \n"
		"and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle             CBF handle. reserved           Unused. Any value \n"
		"other than 0 is invalid. time Integration   time in seconds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_orientation_matrix", _wrap_cbf_handle_struct_set_orientation_matrix, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Float matrix_0,Float matrix_1,Float matrix_2,Float matrix_3,\n"
		"          Float matrix_4,Float matrix_5,Float matrix_6,Float matrix_7,\n"
		"          Float matrix_8\n"
		"\n"
		"C prototype: int cbf_set_orientation_matrix (cbf_handle handle,\n"
		"                 double ub_matrix[9]);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_orientation_matrix sets ub_matrix to point to the array of \n"
		"orientation matrix entries in the  \"diffrn \" category in the order \n"
		"of columns:\n"
		" \"UB[1][1] \"  \"UB[1][2] \"  \"UB[1][3] \"  \"UB[2][1] \"  \n"
		"\"UB[2][2] \"  \"UB[2][3] \"  \"UB[3][1] \"  \"UB[3][2] \"  \n"
		"\"UB[3][3] \"\n"
		"cbf_set_orientation_matrix sets the values in the  \"diffrn \" \n"
		"category to the values pointed to by ub_matrix.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. ubmatric   Source or destination array of 9 \n"
		"doubles giving the orientation matrix parameters.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_overload", _wrap_cbf_handle_struct_set_overload, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Integer element_number,Float overload\n"
		"\n"
		"C prototype: int cbf_set_overload (cbf_handle handle,\n"
		"                 unsigned int element_number,      double overload);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_overload sets the overload value of element number \n"
		"element_number to overload.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. overload         New overload value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_pixel_size", _wrap_cbf_handle_struct_set_pixel_size, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Int element_number,Int axis_number,Float pixel size\n"
		"\n"
		"C prototype: int cbf_set_pixel_size (cbf_handle handle,\n"
		"                 unsigned int element_number,      int axis_number,\n"
		"                 double psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_pixel_size and cbf_set_pixel_size_sf set the item in the  \n"
		"\"size \" column of the  \"array_structure_list \" category at the \n"
		"row which matches axis axis_number of the detector element \n"
		"element_number converting the double pixel size psize from meters to \n"
		"millimeters in storing it in the  \"size \" column for the axis \n"
		"axis_number of the detector element element_number. The axis_number \n"
		"is numbered from 1, starting with the slowest axis. \n"
		"cbf_set_pixel_size_fs sets the item in the  \"size \" column of the  \n"
		"\"array_structure_list \" category at the row which matches axis \n"
		"axis_number of the detector element element_number converting the \n"
		"double pixel size psize from meters to millimeters in storing it in \n"
		"the  \"size \" column for the axis axis_number of the detector \n"
		"element element_number. The axis_number is numbered from 1, starting \n"
		"with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the  \"array_structure_list \" category does not already exist, it \n"
		"is created.\n"
		"If the appropriate row in the  \"array_structure_list \" catgeory \n"
		"does not already exist, it is created.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"category \", the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, fastest first, starting from 1.\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_pixel_size_fs", _wrap_cbf_handle_struct_set_pixel_size_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Int element_number,Int axis_number,Float pixel size\n"
		"\n"
		"C prototype: int cbf_set_pixel_size_fs(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_pixel_size and cbf_set_pixel_size_sf set the item in the  \n"
		"\"size \" column of the  \"array_structure_list \" category at the \n"
		"row which matches axis axis_number of the detector element \n"
		"element_number converting the double pixel size psize from meters to \n"
		"millimeters in storing it in the  \"size \" column for the axis \n"
		"axis_number of the detector element element_number. The axis_number \n"
		"is numbered from 1, starting with the slowest axis. \n"
		"cbf_set_pixel_size_fs sets the item in the  \"size \" column of the  \n"
		"\"array_structure_list \" category at the row which matches axis \n"
		"axis_number of the detector element element_number converting the \n"
		"double pixel size psize from meters to millimeters in storing it in \n"
		"the  \"size \" column for the axis axis_number of the detector \n"
		"element element_number. The axis_number is numbered from 1, starting \n"
		"with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the  \"array_structure_list \" category does not already exist, it \n"
		"is created.\n"
		"If the appropriate row in the  \"array_structure_list \" catgeory \n"
		"does not already exist, it is created.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"category \", the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, fastest first, starting from 1.\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_pixel_size_sf", _wrap_cbf_handle_struct_set_pixel_size_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Int element_number,Int axis_number,Float pixel size\n"
		"\n"
		"C prototype: int cbf_set_pixel_size_sf(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_pixel_size and cbf_set_pixel_size_sf set the item in the  \n"
		"\"size \" column of the  \"array_structure_list \" category at the \n"
		"row which matches axis axis_number of the detector element \n"
		"element_number converting the double pixel size psize from meters to \n"
		"millimeters in storing it in the  \"size \" column for the axis \n"
		"axis_number of the detector element element_number. The axis_number \n"
		"is numbered from 1, starting with the slowest axis. \n"
		"cbf_set_pixel_size_fs sets the item in the  \"size \" column of the  \n"
		"\"array_structure_list \" category at the row which matches axis \n"
		"axis_number of the detector element element_number converting the \n"
		"double pixel size psize from meters to millimeters in storing it in \n"
		"the  \"size \" column for the axis axis_number of the detector \n"
		"element element_number. The axis_number is numbered from 1, starting \n"
		"with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the  \"array_structure_list \" category does not already exist, it \n"
		"is created.\n"
		"If the appropriate row in the  \"array_structure_list \" catgeory \n"
		"does not already exist, it is created.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"category \", the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, fastest first, starting from 1.\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_polarization", _wrap_cbf_handle_struct_set_polarization, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Float polarizn_source_ratio,Float polarizn_source_norm\n"
		"\n"
		"C prototype: int cbf_set_polarization (cbf_handle handle,\n"
		"                 double      polarizn_source_ratio,\n"
		"                 double polarizn_source_norm);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_polarization sets the source polarization to the values \n"
		"specified by polarizn_source_ratio and polarizn_source_norm.\n"
		"ARGUMENTS\n"
		"handle                  CBF handle. polarizn_source_ratio   New value \n"
		"of polarizn_source_ratio. polarizn_source_norm    New value of \n"
		"polarizn_source_norm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_real_3d_image", _wrap_cbf_handle_struct_set_real_3d_image, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_3d_image (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimslow, size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_real_3d_image_fs", _wrap_cbf_handle_struct_set_real_3d_image_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimfast,int dimmid,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_real_3d_image_fs(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimfast, size_t ndimmid, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_real_3d_image_sf", _wrap_cbf_handle_struct_set_real_3d_image_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_3d_image_sf(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimslow, size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_real_image", _wrap_cbf_handle_struct_set_real_image, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_image (cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, unsigned int compression,\n"
		"                 void      *array,size_t elsize, size_t ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_real_image_fs", _wrap_cbf_handle_struct_set_real_image_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimfast,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_real_image_fs(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimfast, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_real_image_sf", _wrap_cbf_handle_struct_set_real_image_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_image_sf(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast×ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast×ndimslow IEEE double or float elements of elsize \n"
		"bytes each, starting at array. cbf_set_3d_image, cbf_set_3d_image_fs \n"
		"and cbf_set_3d_image_sf write the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast×ndimmid×ndimslow IEEE \n"
		"double or float elements of elsize bytes each, starting at array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		"   CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET     \n"
		"Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE          No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_realarray", _wrap_cbf_handle_struct_set_realarray, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements\n"
		"\n"
		"C prototype: int cbf_set_realarray (cbf_handle handle,\n"
		"                 unsigned int compression, int    binary_id, void *array,\n"
		"                 size_t elsize, size_t elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_realarray_wdims", _wrap_cbf_handle_struct_set_realarray_wdims, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimfast,int dimmid,int dimslow,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_realarray_wdims (cbf_handle handle,\n"
		"                 unsigned int compression,    int binary_id, void *array,\n"
		"                 size_t elsize, size_t elements, const char    *byteorder,\n"
		"                 size_t dimfast, size_t dimmid, size_t dimslow,\n"
		"                 size_t    padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_realarray_wdims_fs", _wrap_cbf_handle_struct_set_realarray_wdims_fs, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimfast,int dimmid,int dimslow,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_realarray_wdims_fs (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, size_t elements,    const char *byteorder,\n"
		"                 size_t dimfast, size_t dimmid, size_t dimslow,\n"
		"                    size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_realarray_wdims_sf", _wrap_cbf_handle_struct_set_realarray_wdims_sf, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimslow,int dimmid,int dimfast,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_realarray_wdims_sf (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, size_t elements,    const char *byteorder,\n"
		"                 size_t dimslow, size_t dimmid, size_t dimfast,\n"
		"                    size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL       Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED          CCP4-style packing (section 3.3.2) CBF_PACKED_V2  \n"
		"     CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET    \n"
		" Simple  \"byte_offset \" compression. CBF_NIBBLE_OFFSET   Simple  \n"
		"\"nibble_offset \" compression. CBF_NONE            No compression. \n"
		"NOTE: This scheme is by far the slowest of the four and uses much \n"
		"more disk space. It is intended for routine use with small arrays \n"
		"only. With large arrays (like images) it should be used only for \n"
		"debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_reciprocal_cell", _wrap_cbf_handle_struct_set_reciprocal_cell, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_set_reciprocal_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_reciprocal_cell sets the reciprocal cell parameters to the \n"
		"double values given in cell[0:2] for the reciprocal cell edge lengths \n"
		"a^*, b^* and c^* in Ångstroms^-1, the double values given in \n"
		"cell[3:5] for the reciprocal cell angles α^*, β^* and γ^* in degrees, \n"
		"the double values given in cell_esd[0:2] for the estimated strandard \n"
		"deviations of the reciprocal cell edge lengths a^*, b^* and c^* in \n"
		"Ångstroms, and the double values given in cell_esd[3:5] for the \n"
		"estimated standard deviations of the reciprocal cell angles α^*, β^* \n"
		"and γ^* in degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the reciprocal cell parameters are not set.\n"
		"If cell_esd is NULL, the reciprocal cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the reciprocal cell parameters. cell_esd   Pointer to the array \n"
		"of 6 doubles for the reciprocal cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_reciprocal_cell_esd", _wrap_cbf_handle_struct_set_reciprocal_cell_esd, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : double cell_esd[6]\n"
		"\n"
		"C prototype: int cbf_set_reciprocal_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_reciprocal_cell sets the reciprocal cell parameters to the \n"
		"double values given in cell[0:2] for the reciprocal cell edge lengths \n"
		"a^*, b^* and c^* in Ångstroms^-1, the double values given in \n"
		"cell[3:5] for the reciprocal cell angles α^*, β^* and γ^* in degrees, \n"
		"the double values given in cell_esd[0:2] for the estimated strandard \n"
		"deviations of the reciprocal cell edge lengths a^*, b^* and c^* in \n"
		"Ångstroms, and the double values given in cell_esd[3:5] for the \n"
		"estimated standard deviations of the reciprocal cell angles α^*, β^* \n"
		"and γ^* in degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the reciprocal cell parameters are not set.\n"
		"If cell_esd is NULL, the reciprocal cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the reciprocal cell parameters. cell_esd   Pointer to the array \n"
		"of 6 doubles for the reciprocal cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_saveframename", _wrap_cbf_handle_struct_set_saveframename, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_saveframename (cbf_handle handle,\n"
		"                 const char *saveframename);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_datablockname changes the name of the current data block to \n"
		"datablockname. cbf_set_saveframename changes the name of the current \n"
		"save frame to saveframename.\n"
		"If a data block or save frame with this name already exists \n"
		"(comparison is case-insensitive), the function returns CBF_IDENTICAL.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The new data block name. \n"
		"datablockname   The new save frame name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_tag_category", _wrap_cbf_handle_struct_set_tag_category, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String tagname,String categoryname_in\n"
		"\n"
		"C prototype: int cbf_set_tag_category (cbf_handle handle, const char* tagname,\n"
		"                 const      char* categoryname_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_category sets categoryname to the category associated \n"
		"with tagname in the dictionary associated with handle. \n"
		"cbf_set_tag_category upddates the dictionary associated with handle \n"
		"to indicated that tagname is in category categoryname_in.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. tagname           tag name. \n"
		"categoryname      pointer to a returned category name. \n"
		"categoryname_in   input category name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_tag_root", _wrap_cbf_handle_struct_set_tag_root, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String tagname,String tagroot_in\n"
		"\n"
		"C prototype: int cbf_set_tag_root (cbf_handle handle, const char* tagname,\n"
		"                 const      char*tagroot_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_root sets *tagroot to the root tag of which tagname is \n"
		"an alias. cbf_set_tag_root sets tagname as an alias of tagroot_in in \n"
		"the dictionary associated with handle, creating the dictionary if \n"
		"necessary. cbf_require_tag_root sets *tagroot to the root tag of \n"
		"which tagname is an alias, if there is one, or to the value of \n"
		"tagname, if tagname is not an alias.\n"
		"A returned tagroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. tagname      tag name which may be an alias. \n"
		"tagroot      pointer to a returned tag root name. tagroot_in   input \n"
		"tag root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_timestamp", _wrap_cbf_handle_struct_set_timestamp, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : Float time,Integer timezone,Float precision\n"
		"\n"
		"C prototype: int cbf_set_timestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 double      time, int timezone, double precision);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_timestamp sets the collection timestamp in seconds since \n"
		"January 1 1970 to the value specified by time. The timezone \n"
		"difference from UTC\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_typeofvalue", _wrap_cbf_handle_struct_set_typeofvalue, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_typeofvalue (cbf_handle handle,\n"
		"                 const char *typeofvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_typeofvalue sets the type of the item at the current column \n"
		"and row to the type specified by the ASCII character string given by \n"
		"typeofvalue. The strings that may be used are:\n"
		" \"null \" for a null value indicated by a  \". \" or a  \"? \"  \n"
		"\"bnry \" for a binary value  \"word \" for an unquoted string  \n"
		"\"dblq \" for a double-quoted string  \"sglq \" for a single-quoted \n"
		"string  \"text \" for a semicolon-quoted string (multiline text \n"
		"field)  \"prns \" for a parenthesis-bracketed string (multiline text \n"
		"field)  \"brcs \" for a brace-bracketed string (multiline text field) \n"
		" \"bkts \" for a square-bracket-bracketed string (multiline text \n"
		"field)  \"tsqs \" for a treble-single-quote quoted string (multiline \n"
		"text field)  \"tdqs \" for a treble-double-quote quoted string \n"
		"(multiline text field)\n"
		"Not all types may be used for all values. Not all types are valid for \n"
		"all type of CIF files. In partcular the types  \"prns \",  \"brcs \", \n"
		" \"bkts \" were introduced with DDLm and are not valid in DDL1 or \n"
		"DDL2 CIFS. The types  \"tsqs \" and  \"tdqs \" are not formally part \n"
		"of the CIF syntax. No changes may be made to the type of binary \n"
		"values. You may not set the type of a string that contains a single \n"
		"quote followed by a blank or a tab or which contains multiple lines \n"
		"to  \"sglq \". You may not set the type of a string that contains a \n"
		"double quote followed by a blank or a tab or which contains multiple \n"
		"lines to  \"dblq \".\n"
		"ARGUMENTS\n"
		"handle        CBF handle. typeofvalue   ASCII string for desired type \n"
		"of value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_unit_cell", _wrap_cbf_handle_struct_set_unit_cell, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_set_unit_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_unit_cell sets the cell parameters to the double values given \n"
		"in cell[0:2] for the cell edge lengths a, b and c in Ångstroms, the \n"
		"double values given in cell[3:5] for the cell angles α, β and γ in \n"
		"degrees, the double values given in cell_esd[0:2] for the estimated \n"
		"strandard deviations of the cell edge lengths a, b and c in \n"
		"Ångstroms, and the double values given in cell_esd[3:5] for the \n"
		"estimated standard deviations of the the cell angles α, β and γ in \n"
		"degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the cell parameters are not set.\n"
		"If cell_esd is NULL, the cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the cell parameters. cell_esd   Pointer to the array of 6 doubles \n"
		"for the cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_unit_cell_esd", _wrap_cbf_handle_struct_set_unit_cell_esd, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : double cell_esd[6]\n"
		"\n"
		"C prototype: int cbf_set_unit_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_unit_cell sets the cell parameters to the double values given \n"
		"in cell[0:2] for the cell edge lengths a, b and c in Ångstroms, the \n"
		"double values given in cell[3:5] for the cell angles α, β and γ in \n"
		"degrees, the double values given in cell_esd[0:2] for the estimated \n"
		"strandard deviations of the cell edge lengths a, b and c in \n"
		"Ångstroms, and the double values given in cell_esd[3:5] for the \n"
		"estimated standard deviations of the the cell angles α, β and γ in \n"
		"degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the cell parameters are not set.\n"
		"If cell_esd is NULL, the cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the cell parameters. cell_esd   Pointer to the array of 6 doubles \n"
		"for the cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_value", _wrap_cbf_handle_struct_set_value, METH_VARARGS, "\n"
		"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_value (cbf_handle handle, const char *value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_value sets the item at the current column and row to the \n"
		"ASCII value value.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. value    ASCII value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { "cbf_handle_struct_set_wavelength", _wrap_cbf_handle_struct_set_wavelength, METH_VARARGS, "\n"
		"\n"
		"Returns : double wavelength\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_wavelength (cbf_handle handle, double wavelength);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_wavelength sets the current wavelength in Å to wavelength.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. wavelength   Wavelength in Å.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { "cbf_handle_struct_write_file", _wrap_cbf_handle_struct_write_file, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String filename,Integer ciforcbf,Integer Headers,Integer encoding\n"
		"\n"
		"C prototype: int cbf_write_file (cbf_handle handle, FILE *file, int readable,\n"
		"                 int    ciforcbf, int flags, int encoding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_write_file writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.0 conventions of 80 character lines. \n"
		"cbf_write_widefile writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.1 conventions of 2048 character lines. A \n"
		"warning is issued to stderr for ascii lines over the limit, and an \n"
		"attempt is made to fold lines to fit. No test is performed on binary \n"
		"sections.\n"
		"If a dictionary has been provided, aliases will be applied on output.\n"
		"Unlike cbf_read_file, the file does not have to be random-access.\n"
		"If the file is random-access and readable, readable can be set to \n"
		"non-0 to indicate to CBFlib that the file can be used as a buffer to \n"
		"conserve disk space. If the file is not random-access or not \n"
		"readable, readable must be 0.\n"
		"\n"
		""},
	 { "cbf_handle_struct_write_widefile", _wrap_cbf_handle_struct_write_widefile, METH_VARARGS, "\n"
		"\n"
		"Returns : \n"
		"*args   : String filename,Integer ciforcbf,Integer Headers,Integer encoding\n"
		"\n"
		"C prototype: int cbf_write_widefile (cbf_handle handle, FILE *file,\n"
		"                 int readable, int    ciforcbf, int flags, int encoding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_write_file writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.0 conventions of 80 character lines. \n"
		"cbf_write_widefile writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.1 conventions of 2048 character lines. A \n"
		"warning is issued to stderr for ascii lines over the limit, and an \n"
		"attempt is made to fold lines to fit. No test is performed on binary \n"
		"sections.\n"
		"If a dictionary has been provided, aliases will be applied on output.\n"
		"Unlike cbf_read_file, the file does not have to be random-access.\n"
		"If the file is random-access and readable, readable can be set to \n"
		"non-0 to indicate to CBFlib that the file can be used as a buffer to \n"
		"conserve disk space. If the file is not random-access or not \n"
		"readable, readable must be 0.\n"
		"\n"
		""},
	 { "cbf_handle_struct_swigregister", cbf_handle_struct_swigregister, METH_O, NULL},
	 { "cbf_handle_struct_swiginit", cbf_handle_struct_swiginit, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};

static PyMethodDef SwigMethods_proxydocs[] = {
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_shortArrayTo_p_short(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((short *)  ((shortArray *) x));
}
static void *_p_longArrayTo_p_long(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((long *)  ((longArray *) x));
}
static void *_p_intArrayTo_p_int(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((int *)  ((intArray *) x));
}
static void *_p_a_4__doubleArrayTo_p_a_4__double(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((double (*)[4])  ((doubleArray (*)[4]) x));
}
static void *_p_doubleArrayTo_p_double(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((double *)  ((doubleArray *) x));
}
static swig_type_info _swigt__p_CBF_NODETYPE = {"_p_CBF_NODETYPE", "enum CBF_NODETYPE *|CBF_NODETYPE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__double = {"_p_a_4__double", "double (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__doubleArray = {"_p_a_4__doubleArray", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_cbf_axis_struct = {"_p_cbf_axis_struct", "cbf_axis_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_detector_struct = {"_p_cbf_detector_struct", "cbf_detector|cbf_detector_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_handle_struct = {"_p_cbf_handle_struct", "cbf_handle|cbf_handle_struct *|handle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_node = {"_p_cbf_node", "cbf_node *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_positioner_struct = {"_p_cbf_positioner_struct", "cbf_positioner|cbf_goniometer|cbf_positioner_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_doubleArray = {"_p_doubleArray", "doubleArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_intArray = {"_p_intArray", "intArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_longArray = {"_p_longArray", "longArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_shortArray = {"_p_shortArray", "shortArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_CBF_NODETYPE,
  &_swigt__p_a_4__double,
  &_swigt__p_a_4__doubleArray,
  &_swigt__p_cbf_axis_struct,
  &_swigt__p_cbf_detector_struct,
  &_swigt__p_cbf_handle_struct,
  &_swigt__p_cbf_node,
  &_swigt__p_cbf_positioner_struct,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_doubleArray,
  &_swigt__p_int,
  &_swigt__p_intArray,
  &_swigt__p_long,
  &_swigt__p_longArray,
  &_swigt__p_p_char,
  &_swigt__p_short,
  &_swigt__p_shortArray,
  &_swigt__p_size_t,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_CBF_NODETYPE[] = {  {&_swigt__p_CBF_NODETYPE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__doubleArray[] = {{&_swigt__p_a_4__doubleArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__double[] = {  {&_swigt__p_a_4__doubleArray, _p_a_4__doubleArrayTo_p_a_4__double, 0, 0},  {&_swigt__p_a_4__double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_axis_struct[] = {  {&_swigt__p_cbf_axis_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_detector_struct[] = {  {&_swigt__p_cbf_detector_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_handle_struct[] = {  {&_swigt__p_cbf_handle_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_node[] = {  {&_swigt__p_cbf_node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_positioner_struct[] = {  {&_swigt__p_cbf_positioner_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_doubleArray, _p_doubleArrayTo_p_double, 0, 0},  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_doubleArray[] = {  {&_swigt__p_doubleArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_intArray, _p_intArrayTo_p_int, 0, 0},  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_intArray[] = {  {&_swigt__p_intArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},  {&_swigt__p_longArray, _p_longArrayTo_p_long, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_longArray[] = {  {&_swigt__p_longArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_shortArray, _p_shortArrayTo_p_short, 0, 0},  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_shortArray[] = {  {&_swigt__p_shortArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_CBF_NODETYPE,
  _swigc__p_a_4__double,
  _swigc__p_a_4__doubleArray,
  _swigc__p_cbf_axis_struct,
  _swigc__p_cbf_detector_struct,
  _swigc__p_cbf_handle_struct,
  _swigc__p_cbf_node,
  _swigc__p_cbf_positioner_struct,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_doubleArray,
  _swigc__p_int,
  _swigc__p_intArray,
  _swigc__p_long,
  _swigc__p_longArray,
  _swigc__p_p_char,
  _swigc__p_short,
  _swigc__p_shortArray,
  _swigc__p_size_t,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        "swigvarlink",                      /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        0,                                  /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
        0,                                  /* tp_del */
        0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
        0,                                  /* tp_prev */
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        memcpy(gv->name, name, size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *globals = 0;
    if (!globals) {
      globals = SWIG_newvarlink();
    }
    return globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
  /* -----------------------------------------------------------------------------
   * Method creation and docstring support functions
   * ----------------------------------------------------------------------------- */
  
  /* -----------------------------------------------------------------------------
   * Function to find the method definition with the correct docstring for the
   * proxy module as opposed to the low-level API
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
    /* Find the function in the modified method table */
    size_t offset = 0;
    int found = 0;
    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
        found = 1;
        break;
      }
      offset++;
    }
    /* Use the copy with the modified docstring if available */
    return found ? &SwigMethods_proxydocs[offset] : NULL;
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyInstanceMethod_New() used in Python 3
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
#if PY_VERSION_HEX >= 0x03000000
    return PyInstanceMethod_New(func);
#else
    return PyMethod_New(func, NULL, NULL);
#endif
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyStaticMethod_New()
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
    return PyStaticMethod_New(func);
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;
  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  SWIG_Python_SetConstant(d, "CBF_INTEGER",SWIG_From_int((int)(0x0010)));
  SWIG_Python_SetConstant(d, "CBF_FLOAT",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "CBF_CANONICAL",SWIG_From_int((int)(0x0050)));
  SWIG_Python_SetConstant(d, "CBF_PACKED",SWIG_From_int((int)(0x0060)));
  SWIG_Python_SetConstant(d, "CBF_PACKED_V2",SWIG_From_int((int)(0x0090)));
  SWIG_Python_SetConstant(d, "CBF_BYTE_OFFSET",SWIG_From_int((int)(0x0070)));
  SWIG_Python_SetConstant(d, "CBF_PREDICTOR",SWIG_From_int((int)(0x0080)));
  SWIG_Python_SetConstant(d, "CBF_NONE",SWIG_From_int((int)(0x0040)));
  SWIG_Python_SetConstant(d, "CBF_COMPRESSION_MASK",SWIG_From_int((int)(0x00FF)));
  SWIG_Python_SetConstant(d, "CBF_FLAG_MASK",SWIG_From_int((int)(0x0F00)));
  SWIG_Python_SetConstant(d, "CBF_UNCORRELATED_SECTIONS",SWIG_From_int((int)(0x0100)));
  SWIG_Python_SetConstant(d, "CBF_FLAT_IMAGE",SWIG_From_int((int)(0x0200)));
  SWIG_Python_SetConstant(d, "CBF_NO_EXPAND",SWIG_From_int((int)(0x0400)));
  SWIG_Python_SetConstant(d, "PLAIN_HEADERS",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "MIME_HEADERS",SWIG_From_int((int)(0x0002)));
  SWIG_Python_SetConstant(d, "MSG_NODIGEST",SWIG_From_int((int)(0x0004)));
  SWIG_Python_SetConstant(d, "MSG_DIGEST",SWIG_From_int((int)(0x0008)));
  SWIG_Python_SetConstant(d, "MSG_DIGESTNOW",SWIG_From_int((int)(0x0010)));
  SWIG_Python_SetConstant(d, "MSG_DIGESTWARN",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "PAD_1K",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "PAD_2K",SWIG_From_int((int)(0x0040)));
  SWIG_Python_SetConstant(d, "PAD_4K",SWIG_From_int((int)(0x0080)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_BRC",SWIG_From_int((int)(0x0100)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_PRN",SWIG_From_int((int)(0x0200)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_BKT",SWIG_From_int((int)(0x0400)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_BRACKETS",SWIG_From_int((int)(0x0700)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_TQ",SWIG_From_int((int)(0x0800)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_CIF2_DELIMS",SWIG_From_int((int)(0x1000)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_DDLm",SWIG_From_int((int)(0x0700)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_CIF2",SWIG_From_int((int)(0x1F00)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_DEFINES",SWIG_From_int((int)(0x2000)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_WIDE",SWIG_From_int((int)(0x4000)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_UTF8",SWIG_From_int((int)(0x10000)));
  SWIG_Python_SetConstant(d, "HDR_DEFAULT",SWIG_From_int((int)((0x0002|0x0004))));
  SWIG_Python_SetConstant(d, "MIME_NOHEADERS",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "CBF",SWIG_From_int((int)(0x0000)));
  SWIG_Python_SetConstant(d, "CIF",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "ENC_NONE",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "ENC_BASE64",SWIG_From_int((int)(0x0002)));
  SWIG_Python_SetConstant(d, "ENC_BASE32K",SWIG_From_int((int)(0x0004)));
  SWIG_Python_SetConstant(d, "ENC_QP",SWIG_From_int((int)(0x0008)));
  SWIG_Python_SetConstant(d, "ENC_BASE10",SWIG_From_int((int)(0x0010)));
  SWIG_Python_SetConstant(d, "ENC_BASE16",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "ENC_BASE8",SWIG_From_int((int)(0x0040)));
  SWIG_Python_SetConstant(d, "ENC_FORWARD",SWIG_From_int((int)(0x0080)));
  SWIG_Python_SetConstant(d, "ENC_BACKWARD",SWIG_From_int((int)(0x0100)));
  SWIG_Python_SetConstant(d, "ENC_CRTERM",SWIG_From_int((int)(0x0200)));
  SWIG_Python_SetConstant(d, "ENC_LFTERM",SWIG_From_int((int)(0x0400)));
  SWIG_Python_SetConstant(d, "ENC_DEFAULT",SWIG_From_int((int)((0x0002|0x0400|0x0080))));
  SWIG_Python_SetConstant(d, "CBF_UNDEFNODE",SWIG_From_int((int)(CBF_UNDEFNODE)));
  SWIG_Python_SetConstant(d, "CBF_LINK",SWIG_From_int((int)(CBF_LINK)));
  SWIG_Python_SetConstant(d, "CBF_ROOT",SWIG_From_int((int)(CBF_ROOT)));
  SWIG_Python_SetConstant(d, "CBF_DATABLOCK",SWIG_From_int((int)(CBF_DATABLOCK)));
  SWIG_Python_SetConstant(d, "CBF_SAVEFRAME",SWIG_From_int((int)(CBF_SAVEFRAME)));
  SWIG_Python_SetConstant(d, "CBF_CATEGORY",SWIG_From_int((int)(CBF_CATEGORY)));
  SWIG_Python_SetConstant(d, "CBF_COLUMN",SWIG_From_int((int)(CBF_COLUMN)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

